# 21. 빌트인 객체 - 22.03.14

---

## 용어

🖊️ **URI :** Uniform Resource Identifier 로 인터넷에 있는 유일한 주소를 말한다. URI의 하위 개념이 URL, URN

![Untitled](21%20%E1%84%87%E1%85%B5%E1%86%AF%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B5%20f5676/Untitled.png)

---

---

## 빌트인 객체

### 자바스크립트 객체의 분류

자바스크립트 객체는 다음과 같이 3개의 객체로 분류 할 수 있다.

- **표준 빌트인 객체**
    
    ECMAScript 사양에 정의된 객체를 말하며, 애플리케이션 전역의 공통 기능 제공
    
    자바스크립트 실행 환경과 관계없이 언제나 사용할 수 있다.
    
    전역 객체의 프로퍼티로서 제공되고 별도의 선언 없이 전역 변수처럼 언제나 참조할 수 있다. 
    
- **호스트 객체**
    
    ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행환경에서 추가로 제공하는 객체
    
    DOM, COM 등과 같은 클라이언트 사이드 Web API를 호스트 객체로 제공하고 Node에서는 고유의 API를 호스트 객체로 제공한다
    
- **사용자 정의 객체**
    
    사용자가 직접 정의한 객체
    

## 표준 빌트인 객체

Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체이다.

생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메서드와 정적 메서드를 제공

생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메서드만 제공

⇒ String , Number, Boolean, Function, Array, Date는 생성자 함수로 호출

```jsx
const strObj = new String('lee');
console.log(typeof strObj); //Object

const numObj = new Number(123);
console.log(typeof numObj); //Object

const boolObj = new Boolean(true);
console.log(typeof boolObj); //object

const func = new Function('x', 'return x * x*');
console.log(typeof func); //function

const regExp = new RegExp(/ab+c/i);
console.log(typeof regExp); //object

```

> 생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 **표준 빌트인 객체의 prototpye프로퍼티에 바인딩된 객체**다
> 

```jsx
const strObj = new String('lee');

console.log(Object.getPrototypeOf(strObj) === String.prototype); //true
```

표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체는 인스턴스 없이도 **호출 가능한 빌트인 정적 메서드**를 제공한다.

```jsx
const numObj = new Number(1.5);

//toFixed는 Number.prototype 의 프로토타입 메서드
console.log(numObj.toFixed()); //2

//isInteger는 Number 정적 메서드
console.log(Number.isInteger(0.5)); //false
```

## 원시값과 래퍼 객체

원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없는데, 원시값인 문자열이 마치 객체처럼 동작한다.

```jsx
const str = 'hello';

console.log(str.length); //5
console.log(str.toUpperCas()); //hello
```

원시값인 문자열, 숫자, 불리언 값의 경우 객체처럼 접근하면 자바스크립트 엔진이 일시적으로 연관된 객체로 변환해주기 때문이다.

<aside>
❓ **래퍼 객체**
문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 **임시 객체**

</aside>

```jsx
const str = 'hello';

//str은 String 생성자 함수의 인스턴스를 가지게됨
// . 으로 접근하여 메서드 사용 가능
console.log(str.length); //5
console.log(str.toUpperCas()); //hello

//사용 다 끝났으니 객체는 버려지고 원래의 원래의 원시값으로 돌아옴
//아니였으면 Object 가 나왔을 것
console.log(typeof str); //string
```

마침표 표기법으로 접근하면 String 생성자 함수의 인스턴스가 생성되고 문자열은 [[StringData]] 내부 슬롯에 할당된다

그리고 인스턴스에서 String.prototype의 메서드를 상속받아 사용할 수 있다. 

객체의 처리가 종료되면 식별자가 [[StringData]]에 있는 원시값을 갖도록 되돌리고 객체는 가비지컬렉터의 대상이 된다. 

> **문자, 숫자, 불리언, 심벌** 이외의 원시값은 래퍼 객체를 생성하지 않는다. 객체 처럼 사용하면 에러가 발생한다.
> 

## 전역 객체

자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 객체이다.

브라우저 환경에서는 window가 전역 객체를 가리키지만 Node.js에서는 global이 전역 객체를 가리킨다.

<aside>
⚠️ **globalThis**
브라우저 환경과 Node.js 환경에서 전역 객체를 가리키던 다양한 식별자를 통한 식별자
ECMAScript 표준 사양을 준수하는 모든 환경에서 사용 가능

```jsx
=== 브라우저 환경
globalThis === this //true
globalThis === window //true
globalThis === self //true
globalThis === frames //true

===node 환경
globalThis === this
****globalThis === global
```

</aside>

전역 객체는 표준 빌트인 객체와 환경에 따른 호스트 객체, var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.

즉 전역 객체는 모든 빌트인 객체의 최상위 객체다. 어떤 객체의 프로퍼티도 아니며 빌트인 객체와 호스트 객체를 프로퍼티로 소유한다는 의미이다.

### 전역 객체의 특징

- 개발자가 의도적으로 생성할 수 없다.
- 전역 객체의 프로퍼티를 참조할때 window, global을 생략할 수 있다.
- 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.
- 자바스크립트 실행 환경에 따라 추가적으로 프로퍼티와 메서드를 갖는다.
- var 키워드로 선언한 전역 변수와 암묵적 전역, 전역 함수는 전역 객체의 프로퍼티가 된다.

```jsx
//var 키워드 전역 변수
var foo = 1;
console.log(window.foo); //1

//암묵적 전역, 전역 객체의 프로퍼티
bar = 2;
console.log(window.bar); //2

//전역 함수
function baz() {return 3;}
console.log(window.bax()); //3
```

- let , cosnt 로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.
- 브라우저 환경에서는 하나의 전역 window를 공유한다. 자바스크립트 코드가 분리되어 있어도 하나의 전역을 공유함

### 빌트인 전역 프로퍼티

전역 객체의 프로퍼티를 의미함

**Infinity**

무한대를 나타내는 숫자값을 갖는다. 

```jsx
console.log(window.Infinity === Infinity); //true
```

**NaN**

Not-a-number 을 나타내는 숫자값을 갖는다.

```jsx
console.log(1*string); // NaN
console.log(typeof NaN); //number
```

**undefined**

원시타입 undefined를 값으로 갖는다. 

```jsx
var foo;
console.log(foo); // undefined
console.log(typeof undefined); //undefined
```

### 빌트인 전역 함수

애플리케이션 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메서드

**eval**

자바스크립트 코드를 나타내는 문자열을 인수로 전달받는다.

표현식이라면 런타임에 평가하여 값을 생성

 문이라면 eval 함수는 문자열 코드를 런타임에 실행한다. 여러개의 문으로 이뤄져 있다면 모든 문 실행

```jsx
eval('1 + 2;')l //3
eval ('var x = 5;'); //undefined

console.log(x); //5

//객체 리터럴은 반드시 괄호로 둘러싼다.
const o = eval('({ a : 1})');
console.log(o); //{a : 1}
//함수 리터럴은 반드시 괄호로 둘러싼다. 
const f = eval('(function () {return 1;})');
console.log(f()); //1
```

 자신이 호출된 위치에 해당하는 기존의 스코프를 동적으로 수정

```jsx
const x = 1;

function foo() {
	eval('var x = 2;');
	console.log(x);//2
}
foo();
console.log(x); //1
```

eval 함수는 foo 함수의 스코프에서 실행된다. 이처럼 **기존의 스코프를 런타임에 동적으로 수정**한다.

단, `strict mode` 에서 eval 함수는 기존의 스코프를 수정하지 않고 **자체적인 스코프를 생성**한다.

```jsx
const x = 1;

function foo() {
'use strict';
	eval('var x = 2; console.log(x);'); //2
	console.log(x);//1
}
foo();
console.log(x); //1
```

let , const 키워드를 사용한 변수 선언문일 경우 암묵적으로 strict mode가 적용된다. 

```jsx
const x = 1;

function foo() {
'use strict';
	eval('const x = 2; console.log(x);'); //2
	console.log(x);//1
}
foo();
console.log(x); //1
```

eval 함수는 보안에 취약하고 eval 함수를 실행하는 동안 자바스크립트 엔진에 의해 최적화가 수행되지 않으므로 속도가 느리다.

⇒ 쓰지 말자

**isFinite**

유한수 이면 true를 반환하고 무한수이면 false를 반환한다.

숫자가 아닐 경우 타입 변환 후 검사를 수행한다. NaN 값이면 false 반환

```jsx
isFinite(0); //true
inFinite('10'); //true

isFinite(null); //true => null을 숫자타입으로 변환하면 0이므로 true

isFinite('hello'); //false
isFinite(Infinity); //false
```

**isNaN**

전달받은 인수가 NaN인지 검사하여 불리언 타입으로 반환

숫자가 아닐 경우 타입 변환 후 검사를 수행

```jsx
isNaN('10.12'); //false
inNaN(10); //false
isNaN(''); //false ''=>0
isNaN(' '); //false ' '=> 0

isNaN({}); // true
```

**parseFloat** 

수로 해석하여 반환한다.

```jsx
parseFloat('3.14');
parseFloat('10.00');
```

**parseInt**

정수로 해석하여 반환한다. 

```jsx
parseInt('10'); //10
parseInt('10.23');// 10

//인수가 문자열이 아니면 문자열로 변환 후 해석
parseInt(10); //10

//뒤에 진법을 나타내는 기수 전달
parseInt('10',2); //1010
```

### 암묵적 전역

자바스크립트가 암묵적으로 전역 객체의 프로퍼티를 동적 생산하여 전역 변수 처럼 동작하는 것

```jsx
var x = 10;
function foo() {
	y = 20;
}
foo();

console.log(x+y);
```

1. y를 찾기 위해 스코프체인을 통해 선언된 변수 인지 확인
2. y 변수의 선언을 찾을 수 없으므로 자바스크립트 엔진은 window.y = 20으로 해석
3. 전역 객체의 프로퍼티를 동적 생성

```jsx
console.log(x); //undefined 
console.log(y); //referenceError

var x = 10;

function foo() {
	y = 20;
}
foo();

console.log(x+y); //30
```

⇒ 하지만 **y는 변수가 아니므로(선언하지 않았기 때문에)** 호이스팅이 발생하지 않음

y(변수가 아님) 는 `delete` 연산자로 삭제할 수 있다.  전역 변수는 프로퍼티이지만 안됨

```jsx
var x = 10;
function foo() {
	y = 20;
}
foo();

console.log(window.x); //10
console.log(window.y); //20

delete x; //전역변수는 삭제 안됨
delete y;

console.log(window.x); //10
console.log(window.y);//undefined
```

> **2022-03-14 TIL**
1. 자바스크립트 는 표준 빌트인, 호스트 객체, 사용자 정의 객체로 나눌 수 있음
2. 문자열, 숫자, 불리언, 심볼의 원시값은 객체처럼 사용할 수 있는데 자바스크립트가 래퍼 객체를 만들어 줘서 그럼
3. 래퍼는 . 으로 접근하면 임시로 생성되는 객체인데 식별자가 이 객체를 가리키게 되고 원시값은 [[ooData]] 슬롯에 들어감
4. 참조가 끝나면 다시 식별자가 원시값을 가리키게 함
5. 그리고 전역 변수, 전역 함수, 암묵적 전역은 모두 전역 객체의 프로퍼티임
6. 근데 암묵적 전역은 변수가 아니고 프로퍼티임을 기억하자. delete로 삭제가 가능하고 변수 호이스팅이 발생하지 않음
>