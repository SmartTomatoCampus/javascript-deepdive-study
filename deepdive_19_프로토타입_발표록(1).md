# 발표문 - 19장 프로토타입

# 초생님

### 최고 잘한 것 : 마이크를 사셨다.

1. 모든 객체는 `prototype`이라는 내부 슬롯을 가지는데 안에 뭐가 많이 들어 있다.
2. 근데 우리는 이 내부 슬롯에 직접 들어갈 수 없고 `__proto__` 접근자를 통해서만 접근 가능하다.
3. 그 프로토타입 안에는 컨스트럭터 속성이 있는데 얘로 생성자 함수에 접근할 수 있다.
4. 생성자 함수는 자시 자신의 프로토타입으로 생성자 함수.프로토타입에 접근가능하다.

```
[오후 11:36] 명성님의 발언 : Circle.prototype.getArea 이라고 선언해야 프로토타입이 됩니다!
[오후 11:36] 애한: 정확히는 모든 객체는 프로토타입이 하나씩있습니다
[오후 11:36] 애한: 그러한 프로토타입에 메소드를 이용해서 추가하면
[오후 11:37] 애한: 해당 메소드는 상속되는 모든 객체에 적용됩니다
[오후 11:37] 애한: 즉 예제에서 Circle 객체를 생성하였을때
[오후 11:37] 애한: 해당 객체의 프로토타입을 콘솔로그에 찍어보면
[오후 11:37] 애한: constructor 하나만있는데
[오후 11:37] 애한: 거기에 getArea라는 메소드를 새로 추가한것.
```

# 명성님

경고창 : 초생님의 마이크 구매로 인한 메타인지 기능을 잃게 되어버렸다.

```jsx
function circle(radius) {
  this.radius = radius;
  this.getArea = function() {
    //Math.PI는 원주율을 나타내는 상수다.
    return Math.PI * this.radius ** 2
  };
}
const circle1 = new Circle(1);
const circle2 = new Circle(2);

- Circle의 모든 프로퍼티를 받는 것 이기 때문에 prototype을 통해 상속이 내려오는 걸 꺠달았다.
- 즉 상속은 부모꺼라 자식한테 없다는걸 알게되었다.
```

```jsx
funcion Circle(radius) {
  this.radius = radius;

  Circle.prototype.getArea = function() {
    return Math.PI * this.radius ** 2
  };
}
  const circle1 = new Circle(1);
  const circle2 = new Circle(2);

- hasOwnPropery를 사용할 경우 getArea는 가지고 있지 않다라고 나온다.
```

```jsx
**너두님 왈** : 상속이라는 것이 같은 자료형을 가지고 있어야만 같은 공유가
부모와 자식이 프로퍼티를 가지고 있어야지 상속이 된다.
```

*(읍니다 최소 50년생)*

# 꽁치님

- 프로토타입은 객체 간 상속을 구현하기 위해 생겨났고, 모든 객체는 프로토타입을 상속 받는다.
- `[[Prototype]]` 은 내부 슬롯이지 프로퍼티가 아니며, 상위 객체의 프로토타입에 접근하기 위해 있는 접근자 프로퍼티가 `__proto__` 다.
    
    ### 그럼 `__proto__`   를 사용하는 이유 ?
    
    - `__proto__` 는 객체가 직접 소유하는 것이 아니라 `Object.prototype` 꺼고 `Object.prototype` 의 접근자 프로퍼티이며, 단지 모든 객체가 `Object.prototype` 을 상속받기 때문에 `__proto__`  또한 상속받아 사용할 수 있는 것이다.
    - `__proto__`   는 서로가 서로의 프로토타입이 되는 것을 막아준다.
- 생성자 함수로 생성한 객체나, 함수나 모든 프로토타입은 `constructor` 프로퍼티를 가진다.
- 생성자 함수는 본인을 생성한 함수, 객체 등등 다 `constructor` 프로퍼티를 가지고 있다.
- 놀랍게도 함수도 객체기 때문에 프로토타입을 파고파고 들면 `Object` 로 연결된다.
- 객체 리터럴로 객체를 생성해도 `constructor` 는 `Object` 다.

```
**명성님 질문 왈** : 질문있습니다 서로가 서로의 프로퍼티가 되면 어떤일이 발생합니까!
**꽁치님 답변** : 부자유친 붕우유신 삼강오륜의 뜻이다.
```

```
**초생님 질문 왈** : 하나의 파일 안에 여러 객체들이 있으면,
객체들 끼리 상속관계가 생기게 되는데, 여러개의 __proto__ 가지고 상속하는게 아니라
하나의 __proto__ 를 가지고 상속하는 건가요 ?
{
	**해석** : 트리구조로 계속해서 상속되는 형식의 객체가 있다고 가정했을때 최종적으로 
				가장 위에 있는 하나의 객체의 prototype을 바탕으로 상속받느냐
}
**꽁치님 답변** : 끝까지 파고들면 최상위 즉 , 본질의 객체를 확인 할 수 있다.
```

# 루피님

### 원래 알고 있던 내용이긴 했지만 한문장으로 설명 되어있는게 좋았습니다.

- 객체는 상태 데이터와 동작을 하나의 논리적인 위로 묶은 복합적 자료구조이다

### 몰랐는데 알게 되어서 좋았던 내용

- 프로토 타입은 생성자 함수의 prototype 속성에(?) 바인딩된다
- `**Object.getPrototypeOf**`는 프로토타입의 참조를 취하고 싶을때 사용한다
- `**Object.setPrototypeOf**`는 프로토타입을 교체하고 싶을때 사용한다

```
**애한님 질문** : 루피님께 복습할겸 질문하나 드리자면. 
프로토타입이 없는 함수가 있나요? 있다면 어떤건가요?
**루피님 왈** : 상속을 구현할때? .prototype으로 하자나여?
그리고 그 생성자로 객체를 구현할때 생성자 함수의
prototype이라는 속성이 프로토타임을 참조해서 객체를 생성한다는 말이 하고싶었나봅니다

**꽁치님 질문** : 프로토 타입은 생성자 함수의 prototype 속성에 바인딩
된다는것을 풀어서 설명 바랍니다.
```

# 야너두님

- `**non-constructo**` 인 화살표 함수와 ES6 메서드 축약 표현으로 정의한 메서드에는 `**prototype**` 프로퍼티를 소유하지 않으며 프로토타입도 생성하지 않는다.
- 프로토로 상속을 받는게 아니고
- 프로토타입 참조는 **`Object.getPrototypeOf`**를 써야하고
- 프로토타입 교체는 **`Object.setPrototypeOf`** 오브를 써야한다.

### 저러한 함수를 써야하는게 권장사양이라는게 특이했다

# 뽀또님

- 자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다. 중복을 제거하는 방법은 기존의 코드를 적극적으로 재사용 하는 것이다. 코드 재사용은 개발 비용을 현저히 줄일 수 있는 잠재력이 있으므로 매우 중요하다.
- 모든 프로토타입은 `**constructor**` 프로퍼티를 갖는다.
- 프로토타입 체인은 단반향 링크드 리스트로 구현되어야 한다. 즉 프로퍼티 검색 방향이 한쪽 방향으로만 흘러가야 한다.
1. __proto__를 권장하지 않으므로 사용 될수 잇는 메서드
    1. 참조를 취득하고 싶은 경우 **`Object.getPrototypeOf`** 메서드를 사용하고,
    2. 프로토타입을 교체 하고 싶은 경우 **`Object.setPrototypeOf`** 메서드를 사용하는 것을 권장한다.

```
**명성님 왈** : 내용이 혼모노라 질문하기가 너무 어렵읍니다
```

# 애한님

1. 객체지향 프로그래밍 언어 4대 속성 : `**캡슐화**`, `**상속**`, `**추상화**`, `**다형성**`
    - 캡슐화 (Encapsulation)
    - 상속 (Inheritance)
    - 정보 은닉 (Information Hiding)
    - 다형성 (Polymorphism)
2. `**추상화**` : 다양한 속성중에 프로그래밍에 필요한 속성만 간추려내어 표현하는 것
3. `**javascript**`에서는 상속을 프로토타입을 기반으로 구현
4. 모든 객체는 하나의 프로토타입을 가진다. `**non-constructor**`는 프로토타입이 없다.
5. 리터럴 표기법으로 생성한 객체는 프로토타입이 있으나 미묘하게 다르다.
    1. ( 객체 리터럴 생성 객체 == 생성자 함수 생성 객체 )
    2. ( 객체 리터럴 생성 객체 !=== 생성자 함수 생성 객체 (생성과정, 스코프, 클로저 등의 차이))

```
**명성님 태글** : 다양성이 아니라 다형성 아닌가요 ?
```

- 애한님의 요약하기전 내용
    - 자바스크립트를 이루고 있는 거의 모든 것(원시타입 값 제외)이 객체
        객체지향 프로그래밍의 4대 속성 : 캡슐화, 상속, 추상화, 다양성
        추상화 : 다양한 속성중에 프로그래밍에 필요한 속성만 간추려내어 표현하는 것
        상속 : 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것.
        * javascript는 프로토타입을 기반으로 상속 구현
        모든 객체는 하나의 프로토타입을 갖는다.
        모든 프로토타입은 생성자함수와 연결되어 있다.
        
        **`__proto__`** 
        
        접근자 프로퍼티를 통해 간접적으로 접근이 가능하다.
            * 프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다.
        
        **`__proto__`** 
        
        접근자 프로퍼티를 코드내에서 직접 사용하는 것은 비권장
        프로토타입의 참조를 취득하고 싶을 때 : Object.getPrototypeOf 메서드 사용
         프로토타입을 교체하고 싶을 때 `**Object.setPrototypeOf**` 메서드 사용
         prototype 프로퍼티는 생성자 함수가 생성한 객체의 프로토타입을 가리킨다
        
         ( == non-constructor 메서드는 prototype 프로퍼티를 소유하지 않음)
        리터럴 표기법으로 생성한 객체는 프로토타입이 존재하나, 프로토타입에서 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수는 없다.
