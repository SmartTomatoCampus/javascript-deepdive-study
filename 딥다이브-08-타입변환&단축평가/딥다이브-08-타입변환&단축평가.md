# [JavaScript] 타입 변환과 단축 평가

## 타입 변환이란?

- 개발자의 의도에 따라 의도적으로 값의 타입을 변환하는 것을 **명시적 타입 변환** 또는 **타입 캐스팅**이라고 함
    
    ```jsx
    let x = 10
    
    // 명시적 타입 변환
    // 숫자를 문자열로 타입 캐스팅
    let str1 = x.toString()
    console.log(typeof str1, str1) // string 10
    
    // x 변수의 값이 변경되지는 않음
    console.log(typeof x, x) // number 10
    ```
    
- 개발자의 의도와는 상관 없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것을
**암묵적 타입 변환** 또는 **타입 강제 변환**이라고 함
    
    ```jsx
    let x = 10
    
    // 암묵적 타입 변환
    // 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다.
    let str2 = x + '';
    console.log(typeof str2, str2) // string 10
    
    // x의 값이 변경된 것은 아니다.
    console.log(typeof x, x) // number 10
    ```
    

> **명시적 타입 변환 & 암묵적 타입 변환**
> 
> 
> ---
> 
> - 명시적 타입 변환과 암묵적 타입 변환 모두 기존의 변수 x 변수가 새로운 타입으로 재할당되는 것은 아님
> - 그러나 개발자의 의지가 담겨있냐 담겨있지 않느냐의 차이
> - 둘중에 정답이 있는 것은 아님. 타입 변환을 명시적으로 적어야 할 때도 있고 가독성 차원에서 암묵적 타입 변환을 이용할 수도 있음
>     
>     ⇒ **중요한 것은 동료가 알아볼 수 있는 코드를 작성해야 함!!**
>     

### 암묵적 타입 변환 방법

- 1) 문자열 타입으로 변환
    
    ```jsx
    // 숫자 타입
    0 + ''    // "0"
    -0 + ''   // "0"
    1 +  ''   // "1"
    -1 + ''   // "-1"
    NaN + ''  // "NaN"
    Infinity + '' // "Infinity"
    -Infinity + '' // "-Infinity"
    
    // 불리언 타입
    true + ''    // "true"
    false + ''   // "false"
    
    // null 타입
    null + ''    // "null"
    
    // undefined 타입
    undefined + ''  // "undefined"
    
    // 객체 타입
    ({}) + ''    // "[object Object]"
    Math + ''    // "[object Math]"
    [] + ''      // ""
    [10, 20] + ''  // "10, 20"
    ```
    
- 2) 숫자 타입으로 변환
    
    ```jsx
    // 문자열 타입
    +''       // 0
    +'0'      // 0
    +'1'      // 1
    +'string' // NaN
    
    // 불리언 타입
    +true     // 1
    +false    // 0
    
    // null 타입
    +null     // 0
    
    // undefined 타입
    +undefined    // NaN
    
    // 객체 타입
    +{}     // NaN
    +[]     // 0
    +[10, 20]  // NaN
    +(function(){})  // NaN
    ```
    
- 3) 불리언 타입으로 변환
    
    Truthy 값과 Falsy 값을 잘 기억하자
    

### 명시적 타입 변환 방법

- 1) 문자열 타입으로 변환
    
    ```jsx
    // 1. String 생성자 함수를 new 연산자 없이 호출
    String(1)       // "1"
    String(NaN)     // "NaN"
    String(Infinity)// "Infinity"
    String(true)    // "true"
    
    // 2. Object.prototype.toString() 메서드를 활용
    (1).toString()     // "1"
    (Nan).toString()   // "NaN"
    (true).toString()  // "true"
    
    // 3. 문자열 연결 연산자를 활용
    1 + ''        // "1"
    NaN + ''      // "NaN"
    true + ''     // "true"
    ```
    
- 2) 숫자 타입으로 변환
    
    ```jsx
    // 1. Number 생성자 함수를 new 연산자 없이 호출
    Number('0')      // 0
    Number('-1')     // -1
    Number(true)     // 1
    Number(false)    // 0
    
    // 2. parseInt, parseFloat 함수를 사용하는 방법 (문자열만 가능)
    parseInt('0')    // 0
    parseInt('-1')   // -1
    parseFloat('10.53') // 10.53
    
    // 3. + 단항 산술 연산자를 이용하는 방법
    + '0'      // 0
    + '-1'     // -1
    + true     // 1
    + false    // 0
    
    // 4. * 산술 연산자를 이용ㅇ하는 방법
    '0' * 1     // 0
    '-1' * 1    // -1
    true * 1    // 1
    false * 1   // 0
    ```
    
- 3) 불리언 타입으로 변환
    
    ```jsx
    // 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
    Boolean('x')      // true
    Boolean('')       // false
    Boolean('false')  // true
    
    Boolean(0)        // false
    Boolean(1)        // true
    Boolean(NaN)      // false
    Boolean(Infinity) // true
    
    Boolean(null)     // false
    Boolean(undefined) // false
    
    Boolean({})       // true
    Boolean([])       // true
    
    // 2. ! 부정 논리 영산자를 두번 사용하는 방법
    !!'x'        // true
    !!''         // false
    !!'false'    // true
    
    !!0          // false
    !!1          // true
    !!NaN        // false
    !!Infinity   // true
    
    !!null       // false
    !!undefined  // false
    
    !!{}         // true
    !![]         // true
    ```
    

## 단축 평가

- && 연산자는 두 개 피연산자가 모두 true 일 때 true 반환 ⇒ 좌항에서 우항으로 평가 진행
- || 연산자는 두 개의 피연산자 중 하나만 true 여도 true 를 반환 ⇒ 좌항에서 우항으로 평가 진행 ⇒ 첫번쨰 피연산자 'Cat' 을 반환

**단축 평가 표현식**

| 단축 평가 표현식 | 평가 결과 |
| --- | --- |
| true || anything | true |
| false || anything | anything |
| true && anything | anything |
| false && anything | false |

```jsx
'Cat' || 'Dog'    // 'Cat'
'false' || 'Dog'  // 'Dog'
'Cat' || false    // 'Cat'

'Cat' && 'Dog'    // 'Dog'
false && 'Dog'    // false
'Cat' && false    // false
```

### 객체를 가리키기를 기대하는 변수가 `null` 또는 `undefined` 가 아닌지 확인하고 프로퍼티를 참조할 때

```jsx
var elem = null
// elem 이 null이나 Undefined 와 같은 Falsy 값이면 elem 으로 평가되고
// elem 이 Truthy 값이면 elem.value 로 평가된다.
var value = elem && elem.value  // null
```

### 함수 매개변수에 기본값을 설정할 때

- 함수를 호출할 떄 인수를 전달하지 않으면 매개변수에 undefined 가 할당되지만,
단축 평가를 사용해서 기본값을 설정해 에러를 방지할 수 있음

```jsx
function getStringLength(str) {
	str = str || ''
	return str.length
}

// ES6 문법에서 매개변수의 기본값 설정
function getStringLength(str = '') {
	return str.length
}
```

### 옵셔널 체이닝 연산자

- ES11 에서 도입된 옵셔널 체이닝의 연산자 `?.` 는 좌항의 피연산자가 null 또는 undefined 인 경우 undefined 를 반환하고,
그렇지 않으면 우항의 프로퍼티 참조를 이어감

```jsx
var elem = null

var value = elem?.value
console.log(value)
```

### null 병합 연산자

- ES11 에서 도입된 null 병합 연산자 `??` 는
좌항의 피연산자가 `null` 또는 `undefined` 인 경우 우항의 피연산자를 반환하고,
그렇지 않으면 좌항의 피연산자를 반환함
- null 병합 연산자 `??` 는 변수에 기본값을 설정할 때 유용함

```jsx
var foo = null ?? 'default string'
console.log(foo)   // "default string"
```

- 하지만 null 병합 연산자 `??` 는 좌항의 피연산자가 false 로 평가되는 Falsy 값이라도 null 또는 undefined 가 아니면 좌항의 피연산자를 그대로 반환함

```jsx
var foo = '' ?? 'default string'
console.log(foo)   // ""
```