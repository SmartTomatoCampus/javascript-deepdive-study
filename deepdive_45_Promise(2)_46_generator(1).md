# JavaSciprt 45장 프로미스(2) ~ 46장 제너레이터 async/await (1)

# 꽁치

1. Promise.all 메서드는 프로미스를 요소로 갖는 배열 등의 이터러블의 인수를 받고 모두 처리가 완료되면 결과를 배열에 저장해 새로운 프로미스를 반환한다!
2. 마이크로태스크 큐는 프로미스의 후속 처리 메서드 콜백 함수가 일시 저장되며 콜스택이 비면 이벤트 루프는 마이크로태스크 큐부터 챙기고 태스크 큐를 가장 마지막에 콜스택에 푸시한다.
3. fetch 는 404, 500 에러의 경우 불리언 값을 갖는 ok 프로퍼티만 false 로 한다. 하지만 axios 는 404, 500 을 포함한 모든 에러를 catch 로 보낸다.
4. 제너레이터 함수*는 함수 제어권을 호출자에 양도(yield)하고, 함수 호출을 yield 가 있는 시점마다 일시 중지시킬 수 있다!!

# 너두

### 알게된것

리덕스 사가만의 기술이 아니였다

제너레이터는 화살표 함수로 정의할 수 없다

제너레이터 함수는 new 연산자와 함꼐 생성자 함수로 호출할 수 없다

### 모르겟는것

리절트 객체가 뭐엿더라

# 명성

generator 함수 내 yield는 제네레이터 리절트 객체의 중요한 지표가 된다

제네레이터의 첫 호출 시 next에 인수를 전달하여도 에러는 뜨지 않으며 무시된다.

# 뽀또

##

**프로미스의 정적 메서드**

###

**Promise.resolve / Promise.reject**

- Promise.resolve 와 Promise.reject 메서드는 이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해 사용한다.

###

**Promise.all**

- Promise.all 메서드는 여러 개의 비동기 처리를 모두 병렬 처리할 때 사용한다.
-

**Promise.all 메서드는 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받는다.**

###

**Promise.race**

- Promise.race 메서드는 Promise.all 메서드와 동일하게프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받는다.

###

**Promise.allSettled**

- Promise.allSettled 메서드는 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받는다.
- 전달받은 프로미스가 모두settled 상태(비동기 처리가 수행된 상태, 즉 fulfilled 또는 rejected 상태)가 되면 처리 결과를 배열로 반환한다.

##

**마이크로태스크 큐**

-

**프로미스의 후속 처리 메서드(then, catch, finally)의 콜백 함수는 태스크 큐가 아니라 마이크로태스크 큐에 저장되기 때문이다**

- 마이크로태스크 큐는 별도의 큐다. 마이크로태스크 큐에는 프로미스의 후속 처리 메서드의 콜백 함수가 일시 저장된다. 그 외의 비동기 함수의 콜백 함수나 이벤트 핸들러는 태스크 큐에 일시 저장된다.
- 마이크로태스크 큐는 태스크 큐보다 우선순위가 높다.

## fetch

- fetch 함수는 XMLHttpRequest 객체와 마찬가지로 HTTP 요청 전송 기능을 제공하는 클라이언트 사이드 Web API다.
- fetch 함수는 XHLHttpRequest 객체보다 사용법이 간단하고, 프로미스를 지원하기 때문에 비동기 처리를 위한 콜백 패턴의 단점에서 자유롭다.

#

**제너레이터**

-

**`제너레이터(generator)`**

: 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수
    - 특징
        - 함수 호출자에게 함수 실행의 제어권을 양도(yield)할 수 있음(함수 호출자가 함수 실행 제어 가능)
        - 함수 호출자에게 상태를 전달할 수 있고 함수 호출자로부터 상태를 전달 받을 수도 있음
        - 제너레이터 함수 호출시 이터러블이면서 동시에 이터레이터인 제너레이터 객체를 반환함 (함수 코드 실행 X)
-

**`function*`**

,

**`yield`**

사용
    - 화살표 함수로 정의 불가
    - new 연산자와 함꼐 생성자 함수로 호출 불가

##

**제너레이터 객체**

- 제너레이터 객체는 이터러블이면서 동시에 이터레이터 임
- 제너레이터 객체는 next 메서드를 가지는 이터레이터 이므로 Symbol.iterator 메서드를 호출해서 별도로 이터레이터를 생성할 필요가 없음
-

**`제너레이터 객체 메서드`**

-

**`next()`**

: 제너레이터 함수의 yield 표현식 까지 코드 블록을 실행하고, yield된 값을 value 프로퍼티 값으로, false를 done 프로퍼티 값으로 갖는 이터레이터 result 객체를 반환
        -

**인수를 넣으면 yield 표현식을 할당받는 변수에 할당 됨**

- 처음 호출되는 next는 인수를 넣어도 무시됨
    -

**`return(value)`**

: 인수로 전달받은 값을 value 프로퍼티 값으로, true를 done 프로퍼티 값으로 갖는 이터레이터 result 객체 반환

-**`throw(error)`**

: 전달 받은 에러를 발생시키고 undefined를 value 프로퍼티 값, true를 done 프로퍼티 값으로 갖는 이터레이터 result 객체를 반환

## **제너레이터의 일시 중지와 재개**

- yield 키워드와 next 메서드를 통해 실행 중지와 재개를 할 수 있음
- next 메서드 호출시 yield 표현식 까지 실행되고 일시 중지 됨 -> 함수 제어권 호출자로 양도
- next 호출시 반환된 result 객체에는 yield 표현식 뒤에 값이 value 프로퍼티에 할당되고, done 프로퍼티에 제너레이터 함수가 끝까지 실행 되었는지 불리언 값 할당

# 초생

1. fetch 함수가 반환하는 프로미스는 기본적으로 에러가 발생해도 에러를 reject 하지 않고 Respone 객체를 resolve 한다. 네트워크나 CORS 에러에 의해 에러난 경우만 reject 한다. 그래서 불리언 타입의 ok를 체크해서 명시적으로 에러 처리를 해야한다.
2. 제너레이터는 코드 블록의 실행을 일시 중지했다가 필요할 때 재개할 수 있는 함수다.
3. 실행 제어권과 함수 상태를 함수 호출자와 전달할 수 있다.
4. 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다. 이 객체는 이터러블이면서 이터레이터이다.
5. yield 키워드와 next 메서드를 통해 실행을 일시 중지 했다가 필요 시점에 재개할 수 있다.
6. yield 키워드는 제너레이터 함수의 실행을 중지 시키거나 뒤에 오는 표현식의 평가 결과를 제너레이터 함수 호출자에게 반환하고, next 메서드를 호출하면 yield 표현식까지 실행되고 일시중지된다.

# 애한

1. 프로미스에 대해서 다시 숙지하는 계기가 되었습니다.

콜백헬 문제와 에러처리의 한계 때문에 등장!!

성공했을 땐 resolve, 실패하면 reject

then, catch, finally 메서드에 대해서 배웠습니다. 아직 어떻게 사용하는지 명확하지는 않지만 일단 이런게 있구나 하고 넘어가겠습니다.

promise.all - 여러개의 비동기 처리를 모두 병렬할 때 사용(처리순서보장)

promise.race - 여러개의 비동기처리를 동시에 실행해 가장 먼저 fulfilled 상태가 된 프로미스의 처리결과를 resolve
   - 우선순위는 마이크로태스크 큐 > 태스크 큐
2. 제너레이터에 대해서 처음 알았습니다.

코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수.

function* 키워드로 선언, 하나 이상의 yield 표현식을 포함, next 메서드를 통해 실행을 일시중지 했다가 필요한 시점에 다시 재개 가능.

이터러블의 구현이나 비동기처리를 할 때 쓰입니다.
   - 내일 배울 내용을 살짝 봤는데 왜 제너레이터를 처음듣나 했더니 이를 보다 개선한 async/await의 도입으로 잘 사용하지 않는다고 하네요. 프로미스를 기반으로 동작하여 프로미스의 후속 처리 메서드 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있습니다.