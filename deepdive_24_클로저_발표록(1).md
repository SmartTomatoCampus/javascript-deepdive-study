# 딥다이브 24장 클로저 발표록(1)

### 꽁치

1. 렉시컬 환경의 “외부 렉시컬 환경에 대한 참조"에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정되는 것이 렉시컬 스코프라고 하는데, 그냥 간단하게 결국 함수는 정의된 그 위치에서 평가된다고 알면 될 것 같다.
2. 함수는 자신의 호출 위치와 상관없이 정의된 위치를 기억하기 위해서 `[[Environment]]` 내부슬롯에 상위 스코프에 대한 참조를 저장한다는 것을 알았다.
3. 외부함수의 생명주기가 종료되었음에도 내부 중첩함수가 남아서 생명 주기가 종료된 외부함수의 변수를 참조하는, 그러한 중첩함수를 ‘클로저'라고 한다는 것을 알게됐다!!!!!
4. 이론적으로 모든 함수는 클로저지만,
외부함수의 식별자를 참조하면서도 외부 함수가 소멸되고서도 중첩함수가 살아남아 외부 함수의 렉시컬 환경을 `[[Environment]]` 에 담아 참조를 계속 하는 중첩함수만을 클로저라고 부른다는 것을 알게됐다

### 명성

“클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다"라는 MDN 문서의 설명을 이해할 수 있었다.

지난 시간 실행 컨텍스트의 생성과정을 몸소 느끼며 함수와 함수가 선언된 렉시컬 환경이라는 것을 가늠할 수 있었다.

함수 코드 평가때 첫번째로 만들어지는 함수 실행 컨텍스트는 렉시컬 환경과 외부 렉시컬 환경에 대한 참조로 이루어진다.

함수 실행 컨텍스트의 렉시컬 환경이란 지역 변수,arguments 객체, 매개변수로 이루어진 함수 환경 레코드, 상위 스코프를 지칭하는 외부 렉시컬 환경에 대한 참조 두가지로 이루어 져 있다.
그렇기에 클로저는 내부 함수와 그 함수가 조작할 수 있는 매개변수,인자,지역변수, 상위 스코프라고 할 수 있겠다

또한 스코프라는게 추상적인게 아닌 [[Environment]] 라는 내부슬롯에 의해 명시된다는 것을 알게 되었다.

함수는 정의될 때 내부슬롯 [[Environment]]에 상위 스코프를 결정하므로
함수를 어디서 호출했는지는 상위 스코프를 결정하는데에 있어 어떠한 영향을 주지 않는다.

이 [[Environment]] 내부슬롯은 의 생성시점
→ 함수 코드 또는 전역 코드는 실행 컨텍스트를 이미 생성한 상태이며, 실행 컨텍스트 내부의 렉시컬 호나경을 생성할 때 현재 실행 중인 실행컨텍스트 (변수 또는 함수)를 등록해놓았기 때문이다.

### 루피

1. 함수는 어디서 호출되는지가 아니라 어디서 정의되었는지에 따라 상위 스코프를 결정하고 이것을 렉시컬 스코프라고 한다.
2. 외부함수보다 중첩함수가 더 오래 유지되는 경우 중첩함수는 이미 생명주기가 종료한 외부함수의 변수를 참조할 수 있다. 이를 클로저라고 부른다.
3. 가비지 컬렉터는 참조하고 있는 메모리공간을 함부로 해제하지 않기 때문에 외부함수의 생존과 관계 없이 내부함수에서 상위 스코프의 식별자를 참조 할 수 있고 식별자의 값을 변경 할 수도 있다.
4. 클로저는 상태가 의도치 않게 변경되지 않도록 은닉하고 특정 함수에게만 상태변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용한다.

### 애한

1. 자바스크립트의 모든 함수는 자신의 상위 스코프를 기억한다
    
    (피치님 왈: “아주 중요한 포인트!” )
    
2. 해당 함수가 동작하고 있는 동안 또는 다른 무언가가 해당 함수(또는 내부의 식별자?)를 참조하고 있는 동안에는 가비지 컬렉션의 대상이 되지 않는다
3. 클로저는 일종의 해당 필요한 정보(식별자가 가리키는 값)를 기억하기 위한 장치라고 생각한다.

### 피치세트

클로저가 외부함수의 식별자를 참조하고 조작한다

클로저는 외부함수의 식별자를 조작할 수 있는 ‘접근 권한'을 가지고 있고, 그렇게 하기 위해 즉시실행함수로 외부함수를 감싸서 바로 실행해버리면 외부함수를 조작할 권한이 아무에게도 없고 오직 클로저 내부함수만이 접근 권한을 가지게 된다