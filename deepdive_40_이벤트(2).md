# 발표문 - 이벤트(2)

# 애한님

## 오늘 요약

1. 이벤트 객체의 공통 프로퍼티에 대해서 학습.
2. 마우스, 키보드 정보취득 이벤트 및 프로퍼티에 대해 학습
3. 이벤트 전파단계에 대해 배웠다.(캡처링/버블링)

한줄 소감 : 어제 예고편으로 캡처링과 버블링에 대해서 배워서 드라마를 보는데 별 감흥이 없었는데, 드라마를 보고 있는데 남주와 여주가 키스하기 직전에 드라마 끝난 느낌이다... 그래서 이벤트 위임을 미리 봤는데 머리가 터질 것 같습니다.

# 꽁치님

1. 이벤트 핸들러에는 첫번째 매개변수에 브라우저가 암묵적으로 이벤트 객체를 할당해준다.
2. 이벤트가 발생하면 암묵적으로 생성되는 이벤트 객체도 생성자 함수에 의해 실행되며 프로토타입 체인의 일원이 된다.
3. 모르겠는 점: isTrusted 프로퍼티는 사용자의 행위에 의해 발생한 이벤트인지의 여부를 boolean 으로 나타낸다는데 click 메서드는 왜 false 인지 궁금하다

# 초생님

1. 이벤트가 발생하면 이벤트 객체가 동적으로 생성되는데 생성된 이벤트 객체는 이벤트 핸들러의 첫번째 인수로 전달된다.
2. 이벤트 핸들러 어트리뷰트 방식으로 이벤트 핸들러를 등록했다면 event를 통해 이벤트 객체를 받을 수 있는데 매개 변수 이름이 무조건 event여야 한다.
3. Event.prototype에 정의되어 있는 이벤트 관련 프로퍼티는 모든 파생 이벤트 객체에 상속된다.
4. DOM 트리 상에 존재하는 DOM 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다. DOM 트리를 통해 전파되는 이벤트는 이벤트 패스에 위치한 모든 DOM 요소에서 캐치할 수 있다.
5. 캡처링 : 이벤트가 상위→하위 요소 전파 
6. 타깃단계 : 이벤트가 이벤트 타깃에 도달 
7. 버블링 : 이벤트가 하위 → 상위 요소 전파

# 너두님

### 알게된것

이벤트는 생성자 함수다

프로토타입 체인에 해당되는걸 알게 되었지만 자세히는 모르겠음

무슨 이벤트가 이리많나 봐도 모르겠다는걸 알게됬음

이벤트 타겟에서 드디어 버블링에 대한 이야기가 다뤄졌다는건 알겠음

### 모르겠는것

버블링단계에서 이벤트가 하→상 요소로 전파했는데 뭐가 달라지는거임

# 뽀또님

### **Event 객체**

**event 객체는 이벤트를 발생시킨 요소와 발생한 이벤트에 대한 유용한 정보를 제공한다.**

**이벤트가 발생하면 event 객체는 동적으로 생성되며 이벤트를 처리할 수 있는 이벤트 핸들러에 인자로 전달된다.**

**그러나 이벤트 핸들러를 선언할 때, event 객체를 전달받을 첫번째 매개변수를 명시적으로 선언하여야 한다.**

### **Event Property**

**Event.target : 실제로 이벤트를 발생시킨 요소를 가리킨다. 버블링에 인해서 쌩뚱맞는 다른 타겟이 인식 될 수 있다.**

### **Event.currentTarget**

**코드에서 이벤트에 바인딩된 DOM 요소를 가리킨다. 즉, addEventListener 앞에 기술된 객체를 가리킨다.**

**따라서 이벤트 핸들러 함수 내에서 currentTarget과 this는 언제나 일치한다.**

**[코드에선 div를 이벤트 등록했는데, button을 클릭할경우, 이벤트 발생]**

- this : div
- e.target : button
- e.currentTarget : div

### **Event.type**

**발생한 이벤트의 종류를 나타내는 문자열을 반환한다.**

### **Event.cancelable**

**요소의 기본 동작을 취소시킬 수 있는지 여부(true/false)를 나타낸다.**

### **Event.eventPhase**

**이벤트 흐름(event flow) 상에서 어느 단계(event phase)에 있는지를 반환한다.**

- 0 : 이벤트 없음
- 1 : 캡처링 단계
- 2 : 타깃
- 3 : 버블링 단계

### **Event Delegation (이벤트 위임)**

**일반적으로 모든 li 요소가 클릭 이벤트에 반응하는 처리를 구현하고 싶은 경우, li 요소에 이벤트 핸들러를 바인딩하면 총 6개의 이벤트 핸들러를 바인딩하여야 한다.**

**만일 li 요소가 100개라면 100개의 이벤트 핸들러를 바인딩하여야 한다.**

**이는 실행 속도 저하의 원인이 될 뿐 아니라 코드 또한 매우 길어지며 작성 또한 불편하다.**

**그리고 동적으로 li 요소가 추가되는 경우, 아직 추가되지 않은 요소는 DOM에 존재하지 않으므로 이벤트 핸들러를 바인딩할 수 없다.**

**이벤트 위임(Event Delegation)은 다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신 하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법이다.**

**위의 경우 6개의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 것 대신 부모 요소(ul#post-list)에 이벤트 핸들러를 바인딩하는 것이다.**

**또한 DOM 트리에 새로운 li 요소를 추가하더라도 이벤트 처리는 부모 요소인 ul 요소에 위임되었기 때문에 새로운 요소에 이벤트를 핸들러를 다시 바인딩할 필요가 없다.**

**이는 이벤트가 이벤트 흐름Visit Website에 의해 이벤트를 발생시킨 요소의 부모 요소에도 영향(버블링)을 미치기 때문에 가능한 것이다.**

**실제로 이벤트를 발생시킨 요소를 알아내기 위해서는 Event.target을 사용한다.**
