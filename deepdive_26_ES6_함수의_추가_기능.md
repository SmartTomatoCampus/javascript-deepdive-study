# 발표문 - ES6 함수의 추가 기능

# 초생님

1. `ES6` 부터 메서드를 구분하기 시작
2. 메서드란 메서드 축약 표현으로 정의된 함수만을 의미함
3. `ES6` 메서드는 `[[HomeObject]]` 사용해서 수퍼클래스 참조한다.
4. 화살표 함수는 인스턴스를 생성할 수 없고 중복된 이름의 매개변수 선언을 할 수 없다.
    1. 그리고 `this`, `arguments`, `super` 이런 애들 안 가짐
5. 화살표 함수에서 `this`, `arguments`, `super` 참조하면 상위 스코프의 `this`, `arguements`, `super` 참조함
6. `Rest`는 함수에 전달된 인수들의 목록을 배열로 전달받는다.

### spread 연산자(전개연산자) 와 rest 파라미터(나머지 연산자)의 차이

`Rest 파라미터`는 쉽게말해 spread 연산의 반대라고 생각하면 편하다. spread 연산은 배열을 개별적으로 전개하지만 `Rest 파라미터`는 개별을 배열로 묶어준다.

# 뽀또님

- 화살표 함수에서는 `this`, `super`, `argument`, `prototype`이 먹히질 않는다.
- this 바인딩을 갖지 않기 때문에 `call` / `apply` / `bind` 가 안됨
- Rest 파라미터. 매우 좋은 기능 자주쓰고 자주보게될테다 !

# 루피님

1. 메서드는 메서드 축약 표현으로 정의된 함수만을 의미하고, 이는 인스턴스를 생성 할 수 없는 `non-constructor`이다.
2. 내부 슬롯 `[[HomeObject]]`를 갖는 `ES6` 메서드는 `super` 키워드를 사용 할 수 있다.
3. 화살표 함수의 `this`는 함수 자체의 `this`를 갖지 않는다. 따라서 화살표 함수 내부에서 `this`를 참조하면 상위 스코프의 `this`를 그대로 참조한다. 이를 `lexical this`라고 한다.
4. `Rest` 파라미터는 점 `...` 을 붙여 정의한 매개변수를 의미하고 함수에 전달된 인수들의 목록을 배열로 전달받는다.
5. 매개변수 기본값을 사용하면 인수 체크 및 초기화를 간소화 할 수 있다.

```jsx
function sum(x, y = 1) {
    console.log(arguments);
}
sum(1)

// 1, 1
```

# 명성님

- 화살표 함수는 표현만 간략한 것이 아니라, 내부 동작도 기존의 함수보다 간략하다.
- 화살표 함수의 `this`는 개발자를 괴롭히기 위한것이 아니라,
`this`가 전역 객체를 가리키는 문제를 해결하기 위한 대안이다
화살표 함수는 다른 함수의 인수로 전달되어 콜백 함수로 사용되는 경우가 많다.
- 화살표 함수의 `this`는 일반 함수의 `this`와 다르게 동작하여 콜백 함수 내부의 `this` 문제인 내부의 `this`가 외부 함수의 `this`와 다르기 때문에 발생하는 문제를 해결하기 위해 의도적으로 설계된 것이다.
- `this`의 바인딩은 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.
(이말은 함수가 어디에서 정의되었는지에 따라 렉시컬 환경의 스코프 체인이 정적으로 생성되는 것과는 정 반대의 개념이다.)

## this가 동적으로 결정된다?

어떤 메서드 내부에서의 `this`를 사용할 때,메서드 안에서의 this는 호출한 객체를 가리킨다.
(여기서 메서드는 `ES6` 이상의 축약형 표현으로 정의된 메서드이다.)

만약 그 메서드가 콜백함수가 필요하고, 그 콜백함수를 일반 함수를 사용한다면 모든 `this`는 `undefined`나 전역객체를 가리킬것이다.

### why undefined?

일반 함수로서 호출되는 모든 함수 내부의 `this`는 전역 객체를 가리킨다.
만약 `class` 내부의 메서드에서 콜백함수를 불러온다면, `class` 내부의 모든 코드에는 `stric mode`가 암묵적으로 적용 된다.
`stric mode`에서 일반 함수로서 호출된 함수 내부의 `this`에는 `undefined`가 바인딩되므로 일반 함수로서 호출된 메서드의 콜백 함수 내부의 `this`는 `undefined`가 바인딩된다.

```jsx
what is solution ? >>> Arrow function
```

### lexical this

화살표 함수는 함수 자체의 `this` 바인딩을 갖지 않는다.
따라서 화살표 함수 내부에서 `this`를 참조하면 상위 스코프의 `this`를 그대로 참조한다.
마치 렉시컬 스코프와 같이 화살표 함수의 `this`가 정의된 위치에 의해 결정된다는 것을 의미한다.

# 꽁치님

1.  `ES5` 까지는 함수의 구분이 없었지만 이로 인해 불필요한 프로토타입을 생성하는 등 성능상의 문제가 있었기 때문에 `ES6` 부터 함수들을 구분해놓았다는 것을 알았다.
2. 일반 함수는 함수를 호출하는 방식, 즉 누가 호출하냐에 따라서 (일반함수, 메서드, 생성자함수)
3. `this`가 달라졌지만, 화살표함수는 함수 자체의 `this`바인딩을 갖지 않기 때문에 상위 스코프의 `this`를 따라간다.
4. `Rest` 파라미터를 쓰면 가변인자들을 바로 배열로 받을 수 있기 때문에 `arguments` 객체를 사용하는 것보다 편하고, 또한 화살표함수에서는 `arguments` 를 직접 갖지 않기 때문에 `Rest` 파라미터가 유용할 수 있다는 것을 알았다.

# 애한님

## es5 이전과 es6 이후의 함수

1. ES6이전의 모든 함수는 callable이면서 constructor이다.
2. ES6이후
    1. 일반함수 : 함수선언문, 함수표현식
    2. ES6 메서드(축약표현), 화살표함수 : non-constructor
3. ES6 이후 메서드
    1. 축약표현(기존의 모호한 정의를 보다 구체적으로 변경)
    2. 자신을 바인딩한 객체를 가리키는 내부슬롯 [[HomeObject]] 를 가짐
    3. constructor 사용불가, super 사용가능
4. 화살표함수 정의 (중요하니까 전부 가져왔습니다.)
    1. 함수선언문으로 정의 불가, 함수표현식으로 정의해야 함.
    2. 매개변수가 여러개인 경우 소괄호 ()안에 매개변수 선언
    3. 매개변수가 한 개인경우 소괄호 () 생략 가능
    4. 매개변수가 없는 경우 소괄호 () 생략 불가
    5. 함수 몸체가 하나의 문으로 구성된다면 중괄호{} 생략가능
    함수 몸체 내부의 문이 값으로 평가될 수 있는 표현식인 문이라면 암묵적으로 반환(표현식이 아닌 문은 반환 불가 -> 중괄호 생략 불가)
    6. 객체 리터럴을 반환하는 경우 객체리터럴을 소괄호()로 감싸 주어야 함.
    7. 객체 리터럴을 소괄호()로 감싸지 않으면 객체 리터럴의 중괄호 {}를 함수 몸체를 감싸는 중괄호 {}로 잘못 해석한다.
    8. 함수 몸체가 여러개의 문으로 구성된다면 함수 몸체를 감싸는 중괄호{}를 생략 불가, 이 때 반환값이 있다면 명시적으로 반환해야한다.
    9. 화살표함수도 일급객체이므로 고차함수에 인수로 전달 가능 -> 일반적인 함수 표현식보다 표현이 간결하고 가독성이 좋음.
5. 화살표 함수와 일반 함수의 차이
    1. 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor다.
    2. 화살표함수는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않음
    3. 중복된 매개변수 이름을 선언할 수 없다.
    4. 일반 함수는 중복된 매개변수 이름을 선언해도 에러 발생 x (strict mode 제외)
    5. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.

```
4.  this

- 화살표 함수는 다른 함수의 인수로 전달되어 콜백 함수로 사용되는 경우가 많다.
- this 바인딩은 함수의 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정
- 일반함수로서 호출되는 콜백함수 -> 중첩함수
- 일반함수로서 호출되는 모든 함수 내부의 this는 전역 객체를 가리킨다.
- 콜백함수 내부의 this 문제( 클래스 내부의 모든 코드는 strict 모드가 암묵적으로 적용되므로 undefined가 바인딩됨)

  - ES6 이전 : this를 다른 변수에 넣어서 회피시킨후 콜백 함수 내부에서 해당 변수를 사용하여 사용.
  - ES6 이후 : 화살표 함수 사용(함수 자체의 this 바인딩이 없음. 따라서 화살표 함수 내부에서 this 참조시 상위 스코프의 this 참조

  - 메서드를 화살표 함수로 정의하는 것은 피해야 함.
  - 메서드를 정의할 때는 ES6 메서드 축약표현으로 정의한 ES6 메서드를 사용하는 것이 좋다.

```

1. Rest 파라미터
    - 화살표 함수로 가변 인자 함수를 구현해야 할때 사용.
    - Rest 파라미터 : 매개변수 이름 앞에 세개의 점 ... 을 붙여서 정의한 매개변수
    - 함수에 전달된 인수들의 목록을 배열로 전달받는다.
    - **마지막 파라미터**
    - **하나만 사용가능**

## Rest 파라미터와 arguments 객체

화살표 함수는 함수 자체의 arguments 객체를 갖지 않으므로 가변 인자 함수를 구현해야 할 때는 Rest 파라미터를 사용해야 함

### 매개변수 기본 값

- 인수가 전달되지 않은 매개변수의 값은 undefined => 방어코드 사용
- ES6에서 도입된 매개변수 기본값을 사용해 인수체크 및 초기화를 간소화 가능
- 매개변수 기본값: 매개변수에 인수를 전달하지 않은 경우, udnefined를 전달한 경우에만 유효
- Rest 파라미터에는 기본값 지정 불가
- 매개변수 기본값은 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티와 arguments 객체에 영향을 주지 않는다.
