# DeepDive #39장 DOM

![9940603359C8B6CD31](https://user-images.githubusercontent.com/34502254/161761263-9729cc4e-9b2b-4dd8-9171-30c09611e443.jpg)


# 39장 DOM

DOM은 HTML 문서의 계층적 구조와 정보를 표현하며 이를 제어할 수 있는 API, 즉 프로퍼티와 메서드를 제공하는 트리 자료구조다.

## 39.1 노드

### 39.1.1 HTML 요소와 노드 객체

HTML 요소는 HTML 문서를 구성하는 개별적인 요소를 의미한다.

![Untitled](https://user-images.githubusercontent.com/34502254/161761290-9ab3a159-5908-4cfc-b372-103c862612cf.png)

HTML요소는 렌더링 엔진에 의해 파싱되어 DOM을 구성하는 요소 노드 객체로 변환된다. 이때 HTML 요소의 어트리뷰트는 어트리뷰트 노드로, HTML 요소의 텍스트 콘텐츠는 텍스트 노드로 변환된다.

![Untitled 1](https://user-images.githubusercontent.com/34502254/161761310-5f950c8f-2e44-4cd8-9112-a8c566309d5a.png)

HTML 문서는 HTML 요소들의 집합으로 이뤄지며, HTML 요소는 중첩 관계를 갖는다.

HTML 요소 간에는 중첩 관계에 의해 계층적인 부자 관계가 형성된다. 이러한 HTML 요소 간의 부자 관계를 반영하여 HTML 문서의 구성 요소인 HTML 요소를 객체화한 모든 노드 객체들을 트리 자료를 구조로 구성한다.

### 트리 자료구조

트리 자료구조는 노드들의 계층 구조로 이뤄진다. 즉 트리 자료구조는 부모노드와 자식노드로 구성되어 있는 도드간의 계층적 구조를 표현하는 비선형 자료구조를 말한다.

트리 자료구조는 하나의 최상위 노드에서 시작한다. 

루트 노드 : 최상위 노드는 부모 노드가 없다.

리프 노드 : 자식 노드가 없다.

![Untitled 2](https://user-images.githubusercontent.com/34502254/161761324-a34e7ce1-e474-49ab-baa9-3499a95e17df.png)

노드 객체들로 구성된 트리 자료구조를 DOM 이라 한다. 노드 객체의 트리로 구조화되어 있기 때문에 DOM을 DOM 트리라고 부른다.

### 39.1.2 노드 객체의 타입

```jsx
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
    <script src="app.js"></script>
  </body>
</html>
```

![Untitled 3](https://user-images.githubusercontent.com/34502254/161761340-6e0522cc-31d5-42a8-8a4d-6c0762911461.png)

<aside>
📜 공백 테스트 노드 = 
HTML 요소 사이의 개해잉나 공백은 텍스트 노드가 된다.

</aside>

 DOM 노드 객체의 계층적인 구조로 구성된다. 노드 객체는 종류가 있고 상속 구조를 갖는다. 노드 객체는 총 12개의 종류가 있다. 그중 가장 중요한 4가지 노트 타입이 있다.

### 문서 노드

최상위 존재하는 루트 노드로서 document 객체를 가리킨다. document 객체는 브라우저가 렌더링한 HTML 문서를 전체를 가리키는 객체로서 전역 객체 window의 document 프로퍼티에 바인딩 되어있다.

### 요소 노드

HTML 요소를 가리키는 객체다. 요소 노드는 HTML 요소 간의 중첩에 의해 부자 관계를 가지며, 이 부자 관계를 통해 정보를 구조화한다.

### 어트리뷰트 노드

어트리뷰트 노드는 HTML 요소의 어트리뷰트를 가리키는 객체다. 어트리뷰트 노드는 어트리뷰트가 지정된 HTML 요소의 요소 노드와 연결되어 있다. 단 요소 노드는 부모 노드와 연결되어 있지만, 어트리뷰트 노드는 부모 노드와 연결되어 있지 않고 요소 노드에만 연결되어 있다.

### 텍스트 노드

HTML 요소의 텍스트를 가리키는 객체다. 요소 노드가 문서의 구조를 표현한다면 텍스트 노드는 문서의 정보를 표현한다고 할 수 있다. 텍스트 노드의 요소 노드의 자식 노드이며, 자식 노드를 가질 수 없는 리프 노드다. 

### 39.1.3 노드 객체의 상속 구조

DOM은 HTML 문서의 계층적 구조와 정보를 표현하며, 이를 제어할 수 있는 API 즉, 프로퍼티와 메서드를 제공하는 트리 자료구조라고 했다. 

DOM을 구성하는 노드 객체는 자신의 구조와 정보를 제어할 수 있는 DOM API를 사용할 수 있다. 이를 통해 노드 객체는 자신의 부모, 형제, 자식을 탐색할 수 있으며, 자신의 어트리뷰트와 텍스트를 조작할 수도 있다.

DOM을 구성하는 노드 객체는 ECMAScript 사양에 정의 된 표준 빌트인 객체가 아니라 브라우저 환경에서 추가적으로 제공하는 호스트 객체다.

![Untitled 4](https://user-images.githubusercontent.com/34502254/161761350-03ad3734-3ab5-4b32-9293-31d09b6bc550.png)

모든 노드 객체는 Object, EventTarget, Node 인터페이스를 상속받는다. 추가적으로 문서 노드는 Document, HTMLDocument 인터페이스를 상속받고 어트리뷰트는 노드는 Attr, 텍스트 노드는 CharacterData 인터페이스를 각각 상속받는다.

요소 노드는 Element 인터페이스를 상속받는다. 또한 요소 노드는 추가적으로 HTMLElement와 태그의 종류별로 세분화된 인터페이스를 상속받는다.

![Untitled 5](https://user-images.githubusercontent.com/34502254/161761359-1be83abd-2a94-4df5-9f12-c08d50265e6b.png)

```jsx
<!DOCTYPE html>
<html>
<body>
  <input type="text">
  <script>
    // input 요소 노드 객체를 선택
    const $input = document.querySelector('input');

    // input 요소 노드 객체의 프로토타입 체인
    console.log(
      Object.getPrototypeOf($input) === HTMLInputElement.prototype,
      Object.getPrototypeOf(HTMLInputElement.prototype) === HTMLElement.prototype,
      Object.getPrototypeOf(HTMLElement.prototype) === Element.prototype,
      Object.getPrototypeOf(Element.prototype) === Node.prototype,
      Object.getPrototypeOf(Node.prototype) === EventTarget.prototype,
      Object.getPrototypeOf(EventTarget.prototype) === Object.prototype
    ); // 모두 true
  </script>
</body>
</html>
```

배열이 객체인 동시에 배열인 것처럼 input 요소 노드 객체도 다양한 특성을 갖는 객체이며, 이러한 특성을 나타내는 기능들을 상속을 통해 제공 받는다.

| input 요소 노드 객체의 특성 | 프로토타입을
제공하는 객체 |
| --- | --- |
| 객체 | Object |
| 이벤트를 발생시키는 객체 | EventTarget |
| 트리 자료구조의 노드 객체 | Node |
| 브라우저 렌더링할 수 있는 웹 문서의 요소를 표현하는 객체 | Element |
| 웹 문서의 요소 중에서 HTML 요소를 표현하는 객체 | HTMLElement |
| HTML 요소 중에서 input 요소를 표현하는 객체 | HTMLInputElement
 |

![Untitled 6](https://user-images.githubusercontent.com/34502254/161761375-d54828fc-0419-4bfc-92bc-1f9776c73d6c.png)

**DOM은 HTML 문서의 계층적 구조와 정보를 표현하는 것은 물론 노드 객체의 종류, 즉 노드 타입에 따라 필요한 기능을 프로퍼티와 메서드의 집합인 DOM API로 제공한다. DOM API를 통해 HTML의 구조나 내용 또는 스타일 등을 동적으로 조작할 수 있다.**

## 39.2 요소 노드 취득

HTML의 구조나 내용 또는 스타일 등을 동적으로 조작하려면 먼저 요소 노드를 취득해야 한다. 텍스트 노드는 요소 노드의 자식 노드이고, 어트리뷰트 노드는 요소 노드와 연결되어 있기 때문에 텍스트 노드나 어트리뷰트 노드를 조작하고자 할 때도 마찬가지이다.

### 39.2.1 id를 이용한 요소 노드 취득

Document.prototype.getElementById 메서드는 인수로 전달한 id 어트리뷰트 값을 갖는 하나의 요소 노드를 탐색하여 반환한다.

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
    <script>
      // id 값이 'banana'인 요소 노드를 탐색하여 반환한다.
      // 두 번째 li 요소가 파싱되어 생성된 요소 노드가 반환된다.
      const $elem = document.getElementById('banana');

      // 취득한 요소 노드의 style.color 프로퍼티 값을 변경한다.
      $elem.style.color = 'red';
    </script>
  </body>
</html>
```

- 중복된 id 값을 반환하더라도, 첫 번째 요소 노드만 반환한다.
- id 값이 HTML에 존재하지 않을 경우 null 을 반환한다.

### 39.2.2 태그 이름을 이용한 요소 노드 취득

Document.prototype/Element.prototype.getElementsByTagName 메서드는 인수로 전달한 태그 이름을 갖는 모든 요소 노드들을 탐색하여 반환한다.

메서드 이름에 포함된 Elements가 복수형인 것에서 알 수 있듯이 getElementByTagName 메서드는 여러 개의 요소 노드 객체를 갖는 DOM 컬렉션 객체인 HTMLCollection 객체를 반환한다.

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li id="apple">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
    <script>
      // 태그 이름이 li인 요소 노드를 모두 탐색하여 반환한다.
      // 탐색된 요소 노드들은 HTMLCollection 객체에 담겨 반환된다.
      // HTMLCollection 객체는 유사 배열 객체이면서 이터러블이다.
      const $elems = document.getElementsByTagName('li');

      // 취득한 모든 요소 노드의 style.color 프로퍼티 값을 변경한다.
      // HTMLCollection 객체를 배열로 변환하여 순회하며 color 프로퍼티 값을 변경한다.
      [...$elems].forEach(elem => { elem.style.color = 'red'; });
    </script>
  </body>
</html>
```

함수는 하나의 값만 반환할 수 있으므로 여러 개의 반환하려면 배열이나 객체와 같은 자료구조에 담아 반환해야 한다. getElementByTagName 메서드가 반환하는 DOM 컬렉션 객체인 HTMLCollection 객체는 유사 배열 객체이면서 이터러블이다.

![Untitled 7](https://user-images.githubusercontent.com/34502254/161761392-8876b221-c7be-44d3-a96d-8a2ec4deadf9.png)

HTML 문서의 모든 요소 노드를 취득하려면 메서드의 인수를 `*` 를 전달한다.

### 39.2.3 class를 이용한 요소 노드 취득

Document.prototype/Element.prototype.getElementsByClassName 메서드는 인수로 전달한 class 어트리뷰트 값을 갖는 모든 요소 노드들을 탐색하여 반환한다.

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul>
      <li class="fruit apple">Apple</li>
      <li class="fruit banana">Banana</li>
      <li class="fruit orange">Orange</li>
    </ul>
    <script>
      // class 값이 'fruit'인 요소 노드를 모두 탐색하여 HTMLCollection 객체에 담아 반환한다.
      const $elems = document.getElementsByClassName('fruit');

      // 취득한 모든 요소의 CSS color 프로퍼티 값을 변경한다.
      [...$elems].forEach(elem => { elem.style.color = 'red'; });

      // class 값이 'fruit apple'인 요소 노드를 모두 탐색하여 HTMLCollection 객체에 담아 반환한다.
      const $apples = document.getElementsByClassName('fruit apple');

      // 취득한 모든 요소 노드의 style.color 프로퍼티 값을 변경한다.
      [...$apples].forEach(elem => { elem.style.color = 'blue'; });
    </script>
  </body>
</html>
```

- class 값을 갖는 요소가 존재하지 않는 경우  getElementsByClassName 메서드는 빈 HTMLCollection 객체를 반환한다.

### 39.2.4 CSS 선택자를 이용한 요소 노드 취득

CSS 선택자는 스타일을 적용하고자 하는 HTML 요소를 특정할 때 사용하는 문법이다.

```jsx
/* 전체 선택자: 모든 요소를 선택 */
* { ... }
/* 태그 선택자: 모든 p 태그 요소를 모두 선택 */
p { ... }
/* id 선택자: id 값이 'foo'인 요소를 모두 선택 */
#foo { ... }
/* class 선택자: class 값이 'foo'인 요소를 모두 선택 */
.foo { ... }
/* 어트리뷰트 선택자: input 요소 중에 type 어트리뷰트 값이 'text'인 요소를 모두 선택 */
input[type=text] { ... }
/* 후손 선택자: div 요소의 후손 요소 중 p 요소를 모두 선택 */
div p { ... }
/* 자식 선택자: div 요소의 자식 요소 중 p 요소를 모두 선택 */
div > p { ... }
/* 인접 형제 선택자: p 요소의 형제 요소 중에 p 요소 바로 뒤에 위치하는 ul 요소를 선택 */
p + ul { ... }
/* 일반 형제 선택자: p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소를 모두 선택 */
p ~ ul { ... }
/* 가상 클래스 선택자: hover 상태인 a 요소를 모두 선택 */
a:hover { ... }
/* 가상 요소 선택자: p 요소의 콘텐츠의 앞에 위치하는 공간을 선택
   일반적으로 content 프로퍼티와 함께 사용된다. */
p::before { ... }
```

### querySelector

Document.prototype/Element.prototype.querySelector 메서드는 인수로 전달한 CSS 선택자를 만족시키는 하나의 요소 노드를 탐색하여 반환한다.

- 인수로 전달한 CSS 선택자를 만족시키는 요소 노드가 여러 개인 경우 첫 번째 요소 노드만 반환한다.
- 인수로 전달한 CSS 선택자를 만족시키는 요소 노드가 존재하지 않을 경우 null을 반환한다.
- 인수로 전달한 CSS 선택자가 문법에 맞지 않는 경우 DOMException 에러가 발생한다.

### querySelectorAll

Document.prototype/Element.prototype.querySelectorAll 메서드는 인수로 전달한 CSS 선택자를 만족시키는 모든 요소 노드를 탐색하여 반환한다. querySelectorAll메서드는 여러개의 요소 노드 객체를 갖는 DOM 컬렉션 객체인 NodeList 객체인 유사 배열 객체이면서 이터러블을 반환한다 .

- 인수로 전달된 CSS 선택자를 만족시키는 요소가 존재하지 않는 경우 빈 NodeList 객체를 반환한다.
- 인수로 전달한 CSS 선택자가 문법에 맞지 않는 경우 DOMException 에러가 발생한다.

**id를 선택할땐 getElementById 메서드를 사용하고 그 외에는 querySelector, querySelectorAll 메서드를 사용하는 것을 권장한다.**

### 39.2.5 특정 요소 노드를 취득할 수 있는지 확인

Element.prototype.matches 메서드는 인수로 전달한 CSS 선택자를 통해 특정 요소 노드를 취득할 수 있는지 확인한다.

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
  </body>
  <script>
    const $apple = document.querySelector('.apple');

    // $apple 노드는 '#fruits > li.apple'로 취득할 수 있다.
    console.log($apple.matches('#fruits > li.apple'));  // true

    // $apple 노드는 '#fruits > li.banana'로 취득할 수 없다.
    console.log($apple.matches('#fruits > li.banana')); // false
  </script>
</html>
```

**Element.prototype.matches 메서든느 이벤트 위임을 사용할 때 유용하다.**

### 39.2.6 HTMLCollection과 NodeList

DOM 컬렉션 객체인 HTMLCollection과 NodeList 는 DOM API 여러 개의 결과값을 반환하기 위한 DOM 컬렉션 객체다.

HTMLCollection과 NodeList는 모두 유사 배열 객체이면서 이터러블이다. 따라서 for...of 문으로 순회할 수 있으며 스프레드 문법을 사용하여 간단히 배열로 변환할 수 있다.

HTMLCollection 과 NodeList 의 중요한 특징은 노드 객체의 상태 변화를 실시간으로 반영하는 살아있는 객체라는 것이다. HTMLCollection은 언제나 live 객체로 동작한다. 단 NodeList는 대부분의 경우 노드 객체의 상태 변화를 실시간으로 반영하지 안혹 과거의 정적 상태를 유지하는 non-live 객체로 동작하지만 경우에 따라 live 객체로 동작할 때가 있다.

### HTMLCollection

- 노드 객체의 상태 변화를 실시간으로 반영하는 살아 있는 DOM 컬렉션 객체다.
- 객체를 for 문으로 순회하면서 노드 객체의 상태를 변경해야 할 때 주의해야한다.
- 또흔 while 문을 사용하여 HTMLCollection 객체에 노드 객체가 나망 있지 않을 때가지 무한 반복하는 방법으로 회피할 수 있다.

### NodeList

- querySelectorAll 메서드를 사용하여 DOM 컬렉션 캑체인 NodeList를 반환한다.
- childNodes 프로퍼티가 반환하는 NodeList 객체는 HTMLCollection 객체와 같이 실시간으로 노드 객체의 상태 변경을 반영하는 live 객체로 동작하므로 주의가 필요하다.
- 노드 객체의 상태 변겨오가 상관없이 안전하게 DOM 컬렉션을 사용하려면 HTMLCollection이나 NodeList 객체를 배열로 변환하여 사용하는 것을 권장한다.

## 39.3 노드 탐색

요소 노드를 취득한 다음, 취득한 요소 노드를 기점으로 DOM 트리의 노드를 옮겨 다니며, 부모, 형제, 자식 노드 등을 탐색해야 할때가 있다.

![Untitled 8](https://user-images.githubusercontent.com/34502254/161761409-ae50b9dd-a12a-43b7-bdaf-61a70b71f832.png)

노드 탐색 프로퍼티는 모두 접근자 프로퍼티다. 단 노드 탐색 프로퍼티는 setter 없이 getter 만 존재하여 참조만 가능한 읽기 전용 접근자 프로퍼티다.

![Untitled 9](https://user-images.githubusercontent.com/34502254/161761421-12e3abfc-4cc6-4b68-b867-23326e5c0df6.png)

### 39.3.1 공백 텍스트 노드

HTML 요소 사이의 스페이스, 탭, 줄바꿈, 등의 공백 문자는 텍스트 노드를 생성한다.

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li class="apple">Apple</li>
      <li class="banana">Banana</li>
      <li class="orange">Orange</li>
    </ul>
  </body>
</html>
```

![Untitled 10](https://user-images.githubusercontent.com/34502254/161761472-6d2a3302-aba1-4c16-b0e6-5de01c253983.png)

HTML 문서의 공백 문자는 공백 텍스트 노드를 생성한다. 따라서 노드를 탐색할 때는 공백 문자가 생성한 공백 텍스트 노드에 주의해야한다. 다음과 같이 인위적으로 HTML 문서의 공백 문자를 제거하면 공백 텍스트 노드를 생성하지 않는다.

### 39.3.2 자식 노드 탐색

자식 노드를 탐색하기 위해서는 노드 탐색 프로퍼티를 사용한다.

| 프로퍼티 | 설명 |
| --- | --- |
| Node.prototype.childNodes | 자식 노드를 모두 탐색하여 DOM 컬렉션 객체인 NodeList에 담아 반환한다. childNodes 프로퍼티가 반환한 NodeList에는 요소 노드뿐만 아니라 텍스트 노드도 포함되어 있을 수 있다. |
| Element.prototype.children | 자식 노드 중에서 요소 노드만 모두 탐색하여 DOM 객체인 HTMLCollection에 담아 반환한다. children 프로퍼티가 반환한 HTMLCollection에는 텍스트 노드가 포함되지 않는다. |
| Node.prototype.firstChild | 첫 번째 자식 노드를 반환한다. |
| Node.prototype.lastChild | 마지막 자식 노드를 반환한다. |
| Element.prototype.firstElementChild |  첫 번째 자식 요소 노드를 반환한다. |
| Element.prototype.lastElementChild | 마지막 자식 요소 노드를 반환한다. |

### 39.3.3 자식 노드 존재 확인

자식 노드가 존재하는지 확인하려면 Node.prototype.hasChildNodes 메서드를 사용한다. hasChildNodes 메서드는 자식 노드가 존재하면 true, 자식 노드가 존재하지 않으면 false를 반환한다.

### 39.3.4 요소

요소노드의 텍스트 노드는 요소 노드의 자식노드다. 따라서 요소 노드의 텍스트 노드는 firstChild 프로퍼티로 접근할 수 있다.

firstChild프로퍼티는 첫 번째 자식 노드를 반환한다. firstChild 프로퍼티가 반환한 노드는 텍스트 노드이거나 요소 노드다.

### 39.3.5 부모 노드 탐색

부모 노드를 탐색하려면 Node.prototype.parentNode 프로퍼티를 사용한다. 텍스트 노드는 DOM 트리의 최종단 노드인 리프 노드 이므로 부모 노드가 텍스트 노드인 경우는 없다.

### 39.3.6 형제 노드 탐색

부모 노드가 같은 형제 노드를 탐색하려면 노드 탐색 프로퍼티를 사용한다. 단 어트리뷰트 노드는 요소 노드와 연결되어 있지만, 부모노드가 같은 형제 노드가 아니기 때문에 반환되지 않는다.

| 프로퍼티 | 설명 |
| --- | --- |
| Node.prototype.previousSibling | 부모노드가 같은 형제 노드 중에서 자신의 이전 형제 노드를 탐색하여 반환한다. |
| Node.prototype.nextSibling | 부모 노드가 같은 형제 노드 중에서 자신의 다음 형제 노드를 탐색하여 반환한다. |
| Element.prototype.previousElementSibling | 부모 노드가 같은 형제 요소 노드 중에서 자신의 이전 형제 요소 노드를 탐색하여 반환한다. |
| Element.prototype.nextElementSibling | 부모 노드가 같은 형제 요소 노드 중에서 자신의 다음 형제 노드를 탐색하여 반환한다. |

## 39.4 노드 정보 취득

**Node.prototype.nodeType**

노드 객체의 종류, 즉 노드 타입을 나타내는 상수를 반환한다. 노드 타입 상수는 Node에 정의 되어 있다.

- Node.ELEMENT_NODE : 요소 노드 타입을 나타내는 상수 1을 반환.
- Node.TEXT_NODE : 텍스트 노드 타입을 나타내는 상수 3을 반환
- Node.DOCUMENT_NODE : 문서 노드 타입을 나타내는 상수 9를 반환.

**Node.prototype.nodeName**

노드의 이름을 문자열로 반환한다.

- 요소 노드 : 대문자 문자열로 태그 이름을 반환.
- 텍스트 노드 : 문자열 “#text”를 반환
- 문서 노드 : 문자열 “#document”를 반환

## 39.5 요소 노드의 텍스트 조작

### 39.5.1 nodeValue

Node.prototype.nodeValue 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티다. 

노드 객체의 nodeValue 프로퍼티를 참조하면 노드 객체의 값을 반환한다. 노드 객체의 값이란 텍스트 노드의 텍스트다. 따라서 텍스트 노드가 아닌 노드, 즉 문서 노드나 요소 노드의 nodeValue 프로퍼티를 참조하면 null을 반환한다.

텍스트 노드의 nodeValue 프로퍼티에 값을 할당하면 텍스트 노드의 값 , 즉 텍스트를 변경할 수 있다.

1. 텍스트를 변경할 요소 노드를 취득한 다음 취득한 요소 노드의 텍스트 노드를 탐색한다.  텍스트 노드의 요소 노드의 자식 노드이므로 firstChild 프로퍼티를 사용하여 탐색한다.
2. 탐색한 텍스트 노드의 nodeValue 프로퍼티를 사용하여 텍스트 노드의 값을 변경한다.

### 39.5.2 textContent

Node.prototype.textContent 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티로서 요소 노드의 텍스트와 모든 자손 노드의 텍스트를 모두 취득하거나 변경한다.

요소 노드의 textContent 프로퍼티를 참조하면 요소 노드의 콘텐츠 영역 내의 텍스트를 모두 반환한다. 

textContent 프로퍼티와 유사한 동작을 하는 innerText 프로퍼티가 있다.

innerText 프로퍼티는 사용하지 않는것이 좋다.

- innerText 프로퍼티는 CSS에 순종적이다.
- innerText 프로퍼티는 CSS 고려해야 하므로 textContent 프로퍼티보다 느리다.

## 39.6 DOM 조작

새로운 노드를 생성하여 DOM에 추가하거나 기존 노드를 삭제 또는 교체하는 것을 말한다.

DOM 조작에 의해 DOM에 새로운 노드가 추가되거나 삭제되면 리플로우와 리페인트가 발생하는 원이이 되므로 성능에 영향을 준다. 따라서 복잡한 콘텐츠를 다루는 DOM 조작은 성능 최적화를 위해 주의해서 다루어야 한다.

### 39.6.1 innerHTML

Element.prototype.innerHTML 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티로서 요소 노드의 HTML 마크업을 취득하거나 변경한다. 요소 노드의 innerHTML 프로퍼티를 참조하면 요소 노드의 콘텐츠 영역 내에 포함된 모든 HTML 마크업을 문자열로 반환한다.

textContent 프로퍼티를 참조하면 HTML 마크업을 무시하고 텍스트만 반환하지만 innterHTML은 HTML 마크업이 포함된 문자열을 그대로 반환한다.

요소 노드의 innerHTML 프로퍼티에 할당한 HTML 마크업 문자열은 렌더링 엔진에 의해 파싱되어 요소 노드의 자식으로 DOM에 반영된다. 이때 사용자로부터 입력받은 데이터를 그대로 innerHTML 프로퍼티에 할당하는 것은 크로스 사이트 스크립트 공격에 취약하므로 위험하다.

HTML 마크업 내에 자바스크립트 악성 코드가 포함되어 있다면 파싱 과정에서 그대로 실행될 가능성이 있기 때문이다.

<aside>
📜 HTML 새니티제이션 - 
사용자로부터 입력받은 데이터에 의해 발생할 수 있는 크로스 사이트 스크립팅 공격을 예방하기 위해 잠재적 위험을 제거하는 기능을 말한다. 새니티제이션 함수를 직접 구현할 수도 있겠지만 DOMPurify 라이브러리를 상요하는 것을 권장한다.

</aside>

### 39.6.2 insertAdjacentHTML 메서드

Element.prototype.insertAdjacentHTML 메서드는 기존 요소를 제거하지 않으면서 위치를 지정해 새로운 요소를 삽입한다.

insertAdjacentHTML 메서드는 두 번째 인수로 전달한 HTML 마크업 문자열을 파싱하고 그 결과로 생성된 노드를 첫 번째 인수로 전달한 위치에 삽입하여 DOM에 반영한다.

첫 번째 인수로 전달할 수 있는 무자열을 beforebegin, afterbegin, beforend, afterend 4가지다.

![Untitled 11](https://user-images.githubusercontent.com/34502254/161761495-6aefa09c-7b09-48d0-963f-53f6a8f2c4f3.png)

단 innerHTML 프로퍼티와 마찬가지로 insertAdjacentHTML 메서드는 HTML 마크업 문자열을 파싱하므로 크로스 사이트 스크립팅 공격에 취약하다는 점은 동일하다.

### 39.6.3 노드 생성과 추가

DOM은 노드를 직접 생성/삽입/삭제/치환 하는 메서드도 제공한다.

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li>Apple</li>
    </ul>
  </body>
  <script>
    const $fruits = document.getElementById('fruits');

    // 1. 요소 노드 생성
    const $li = document.createElement('li');

    // 2. 텍스트 노드 생성
    const textNode = document.createTextNode('Banana');

    // 3. 텍스트 노드를 $li 요소 노드의 자식 노드로 추가
    $li.appendChild(textNode);

    // 4. $li 요소 노드를 #fruits 요소 노드의 마지막 자식 노드로 추가
    $fruits.appendChild($li);
  </script>
</html>
```

### 요소 노드 생성

Document.prototype.createElement(tagName) 메서드는 요소 노드를 생성하여 반환한다.

```jsx
// 1. 요소 노드 생성
const $li = document.createElement('li');
```

### 텍스트 노드 생성

Document.prototype.createTextNode(text) 메서드는 텍스트 노드를 생성하여 반환한다. createTextNode 메서드의 매개변수 text에는 텍스트 노드의 값으로 사용할 문자열을 인수로 전달한다.

```jsx
// 2. 텍스트 노드 생성
const textNode = document.createTextNode('Banana');
```

### 텍스트 노드를 요소 노드의 자식 노드로 추가

Node.prototype.appendChild(childNode) 메서드는 childNode 에게 인수로 전달할 노드를 appendChild 메서드를 호출한 노드의 마지막 자식 노드로 추가한다.

```jsx
// 3. 텍스트 노드를 $li 요소 노드의 자식 노드로 추가
$li.appendChild(textNode);
```

### 요소 노드를 DOM에 추가

Node.prototype.appendChild 메서드를 사용하여 텍스트 노드와 부자관계로 연결한 요소 노드를 #fruits 요소 노드의 마지막 자식 요소로 추가한다.

```jsx
// 4. $li 요소 노드를 #fruits 요소 노드의 마지막 자식 노드로 추가
$fruits.appendChild($li);
```

### 39.6.4 복수의 노드 생성과 추가

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits"></ul>
  </body>
  <script>
    const $fruits = document.getElementById('fruits');

    ['Apple', 'Banana', 'Orange'].forEach(text => {
      // 1. 요소 노드 생성
      const $li = document.createElement('li');

      // 2. 텍스트 노드 생성
      const textNode = document.createTextNode(text);

      // 3. 텍스트 노드를 $li 요소 노드의 자식 노드로 추가
      $li.appendChild(textNode);

      // 4. $li 요소 노드를 #fruits 요소 노드의 마지막 자식 노드로 추가
      $fruits.appendChild($li);
    });
  </script>
</html>
```

실제로 DOM 변경이 발생하는 것은 한 번 뿐이며 리플로우와 리페인트도 한 번만 실행된다. 따라서 여러개의 요소 노드를 DOM 추가하는 경우 DocumentFragment 노드를 사용하는 것이 더 효율적이다.

### 39.6.5 노드 삽입

### 마지막 노드로 추가

Node.prototype.appendChild 메서드는 인수로 전달받은 노드를 자신을 호출한 노드의 마지막 자식 노드로 DOM에 추가한다.

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li>Apple</li>
      <li>Banana</li>
    </ul>
  </body>
  <script>
    // 요소 노드 생성
    const $li = document.createElement('li');

    // 텍스트 노드를 $li 요소 노드의 마지막 자식 노드로 추가
    $li.appendChild(document.createTextNode('Orange'));

    // $li 요소 노드를 #fruits 요소 노드의 마지막 자식 노드로 추가
    document.getElementById('fruits').appendChild($li);
  </script>
</html>
```

![Untitled 12](https://user-images.githubusercontent.com/34502254/161761517-33833854-3b57-4932-a615-02e6f0078b4a.png)

### 지정한 위치에 노드 삽입

Node.prototype.insertBefor(newNode, childNode) 메서드는 첫 번째 인수로 전달받은 노드를 두 번째 인수로 전달받은 노드 앞에 삽입한다.

두 번째 인수로 null 이면 첫 번째 인수로 전달 받은 노드를 appendChild 메서드 처럼 작동하게 된다.

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li>Apple</li>
      <li>Banana</li>
    </ul>
  </body>
  <script>
    const $fruits = document.getElementById('fruits');

    // 요소 노드 생성
    const $li = document.createElement('li');

    // 텍스트 노드를 $li 요소 노드의 마지막 자식 노드로 추가
    $li.appendChild(document.createTextNode('Orange'));

    // $li 요소 노드를 #fruits 요소 노드의 마지막 자식 요소 앞에 삽입
    $fruits.insertBefore($li, $fruits.lastElementChild);
    // Apple - Orange - Banana
  </script>
</html>
```

![Untitled 13](https://user-images.githubusercontent.com/34502254/161761536-677ba4f8-24ed-487d-86e6-ff07bbbddaef.png)

### 39.6.6 노드 이동

DOM에 이미 존재하는 노드를 appendChild 또는 insertBefore 메서드를 사용하여 DOM에 다시 추가하면 현재 위치에서 노드를 제거하고 새로운 위치에 노드를 추가한다.

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li>Apple</li>
      <li>Banana</li>
      <li>Orange</li>
    </ul>
  </body>
  <script>
    const $fruits = document.getElementById('fruits');

    // 이미 존재하는 요소 노드를 취득
    const [$apple, $banana, ] = $fruits.children;

    // 이미 존재하는 $apple 요소 노드를 #fruits 요소 노드의 마지막 노드로 이동
    $fruits.appendChild($apple); // Banana - Orange - Apple

    // 이미 존재하는 $banana 요소 노드를 #fruits 요소의 마지막 자식 노드 앞으로 이동
    $fruits.insertBefore($banana, $fruits.lastElementChild);
    // Orange - Banana - Apple
  </script>
</html>
```

![Untitled 14](https://user-images.githubusercontent.com/34502254/161761555-a7979fa9-173f-4cb1-810c-91af33d484a4.png)

### 39.6.7 노드 복사

Node.prototype.cloneNode([deep: true | false]) 메서드는 노드의 사본을 생성하여 반환한다. 매개변수 deep에 true를 인수로 전달하면 노드를 깊은 복사하여 모든 자손 노드가 포함된 사본을 생성하고, false를 인수로 전달하거나 생략하면 노드를 얕은 복사하여 노드 자신만의 사본을 생성한다. 얕은 복사로 생성된 요소 노드는 자손 노드를 복사하지 않으므로 텍스트 노드도 없다.

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li>Apple</li>
    </ul>
  </body>
  <script>
    const $fruits = document.getElementById('fruits');
    const $apple = $fruits.firstElementChild;

    // $apple 요소를 얕은 복사하여 사본을 생성. 텍스트 노드가 없는 사본이 생성된다.
    const $shallowClone = $apple.cloneNode();
    // 사본 요소 노드에 텍스트 추가
    $shallowClone.textContent = 'Banana';
    // 사본 요소 노드를 #fruits 요소 노드의 마지막 노드로 추가
    $fruits.appendChild($shallowClone);

    // #fruits 요소를 깊은 복사하여 모든 자손 노드가 포함된 사본을 생성
    const $deepClone = $fruits.cloneNode(true);
    // 사본 요소 노드를 #fruits 요소 노드의 마지막 노드로 추가
    $fruits.appendChild($deepClone);
  </script>
</html>
```

![Untitled 15](https://user-images.githubusercontent.com/34502254/161761566-953653c9-00b7-470d-9c46-7f5ac615f801.png)

### 39.6.8 노드 교체

Node.prototype.replaceChild(newChild, oldChild) 메서드는 자신을 호출한 노드의 자식 노드를 다른 노드로 교체한다.

첫 번째 매개변수 newChild에는 교체할 새로운 노드를 인수로 전달한다.

두 번째 매개변수 oldChild에는 이미 존재하는 교체될 노드를 인수로 전달한다. 

oldChild 매개변수에 인수로 전달한 노드는 replaceChild 메서드를 호출한 노드의 자식 노드이어야 한다.

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li>Apple</li>
    </ul>
  </body>
  <script>
    const $fruits = document.getElementById('fruits');

    // 기존 노드와 교체할 요소 노드를 생성
    const $newChild = document.createElement('li');
    $newChild.textContent = 'Banana';

    // #fruits 요소 노드의 첫 번째 자식 요소 노드를 $newChild 요소 노드로 교체
    $fruits.replaceChild($newChild, $fruits.firstElementChild);
  </script>
</html>
```

![Untitled 16](https://user-images.githubusercontent.com/34502254/161761584-3f8fd841-3859-40e8-9694-758145a2fb32.png)

### 39.6.9 노드 삭제

Node.prototype.removeChild(child) 메서드는 child 매개변수에 인수로 전달한 노드를 DOM에서 삭제한다. 인수로 전달한 노드는 removeChild 매서드를 호출한 노드의 자식 노드이어야 한다.

```jsx
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li>Apple</li>
      <li>Banana</li>
    </ul>
  </body>
  <script>
    const $fruits = document.getElementById('fruits');

    // #fruits 요소 노드의 마지막 요소를 DOM에서 삭제
    $fruits.removeChild($fruits.lastElementChild);
  </script>
</html>
```

![Untitled 17](https://user-images.githubusercontent.com/34502254/161761598-694251b6-c515-40b9-9ad4-00aced2a3940.png)

## 39.7 어트리뷰트

### 39.7.1 어트리뷰트 노드와 attributes 프로퍼티

HTML 문서의 구성 요소인 HTML 요소는 여러 개의 어트리뷰트를 가질 수 있다. HTML 요소의 동작을 제어하기 위한 추가적인 정보를 제공하는 HTML 어트리뷰트는 HTML 요소의 시작 태그에 어트리뷰트 이름=”어트리뷰트 값” 형식으로 정의한다.

```jsx
<input id="user" type="text" value="ungmo2">
```

```jsx
<!DOCTYPE html>
<html>
<body>
  <input id="user" type="text" value="ungmo2">
  <script>
    // 요소 노드의 attribute 프로퍼티는 요소 노드의 모든 어트리뷰트 노드의 참조가 담긴 NamedNodeMap 객체를 반환한다.
    const { attributes } = document.getElementById('user');
    console.log(attributes);
    // NamedNodeMap {0: id, 1: type, 2: value, id: id, type: type, value: value, length: 3}

    // 어트리뷰트 값 취득
    console.log(attributes.id.value); // user
    console.log(attributes.type.value); // text
    console.log(attributes.value.value); // ungmo2
  </script>
</body>
</html>
```

### 39.7.2 HTML 어트리뷰트 조작

요소 노드의 attributes 프로퍼티는 getter 만 존재하는 읽기 전용 접근자 프로퍼티 이므로 HTML 어트리뷰트 값을 취득할 수 있지만 변경할 수는 없다. 또한 attruibutes.id.value와 같이 attributes 프로퍼티를 통해야만 HTML 어트리뷰트 값을 취득할 수 있기 때문에 불편한다.

```jsx
<!DOCTYPE html>
<html>
<body>
  <input id="user" type="text" value="ungmo2">
  <script>
    const $input = document.getElementById('user');

    // value 어트리뷰트 값을 취득
    const inputValue = $input.getAttribute('value');
    console.log(inputValue); // ungmo2

    // value 어트리뷰트 값을 변경
    $input.setAttribute('value', 'foo');
    console.log($input.getAttribute('value')); // foo
  </script>
</body>
</html>
```

특정 어트리뷰트가 존재하는지 확인하려면 Element.prototype.hasAttribute

특정 어트리뷰트를 삭제하려면 Element.prototype.removeArrtibute

### 39.7.3 HTML 어트리뷰트 vs. DOM 프로퍼티

요소 노드 객체에는 HTML 어트리뷰트에 대응하는 프로퍼티가 존재한다. 이 DOM 프로퍼티들은 HTML 어트리뷰트 값을 초기값으로 가지고 있다.

DOM 프로퍼티는 seter와 getter 모두 존재하는 접근자 프로퍼티다. 따라서 DOM 프로퍼티는 참조와 변경이 가능하다.

**HTML 어트리뷰트의 역할은 HTML 요소의 초기 상태를 지정하는 것이다. HTML 어트리뷰트 값은 HTML 요소의 초기 상태를 의미하며 이는 변하지 않는다.**

```jsx
<!DOCTYPE html>
<html>
<body>
  <input id="user" type="text" value="ungmo2">
  <script>
    const $input = document.getElementById('user');

    // attributes 프로퍼티에 저장된 value 어트리뷰트 값
    console.log($input.getAttribute('value')); // ungmo2

    // 요소 노드의 value 프로퍼티에 저장된 value 어트리뷰트 값
    console.log($input.value); // ungmo2
  </script>
</body>
</html>
```

**요소 노드는 2개의 상태 즉 초기 상태와 최신 상태를 관리해야 하낟. 요소 노드의 초기 상태는 어트리뷰트 노드가 관리하며, 요소 노드의 최신 상태는 DOM 프로퍼티가 관리한다.**

### 어트리뷰트 노드

**HTML 어트리뷰트로 지정한 HTML 요소의 초기 상태는 어트리뷰트 노드에서 관리한다.** 

어트리뷰트 노드에서 관리하는 어트리뷰트 값은 사용자의 입력에 의해 상태가 변경되어도 변하지 않고 HTML 어트리뷰트로 지정한 HTML 어트리뷰트로 지정한 HTML 요소의 초기 상태를 그대로 유지한다.

```jsx
// attributes 프로퍼티에 저장된 value 어트리뷰트 값을 취득한다. 결과는 언제나 동일하다.
document.getElementById('user').getAttribute('value'); // ungmo2
```

### DOM 프로퍼티

**사용자가 입력한 최신 상태는 HTML 어트리뷰트에 대응하는 요소 노드의 DOM 프로퍼티가 관리한다. DOM 프로퍼티는 사용자의 입력에 의한 상태 변화에 반응하여 언제나 최신 상태를 유지한다.**

```jsx
<!DOCTYPE html>
<html>
<body>
  <input id="user" type="text" value="ungmo2">
  <script>
    const $input = document.getElementById('user');

    // 사용자가 input 요소의 입력 필드에 값을 입력할 때마다 input 요소 노드의
    // value 프로퍼티 값, 즉 최신 상태 값을 취득한다. value 프로퍼티 값은 사용자의 입력에
    // 의해 동적으로 변경된다.
    $input.oninput = () => {
      console.log('value 프로퍼티 값', $input.value);
    };

    // getAttribute 메서드로 취득한 HTML 어트리뷰트 값, 즉 초기 상태 값은 변하지 않고 유지된다.
    console.log('value 어트리뷰트 값', $input.getAttribute('value'));
  </script>
</body>
</html>
```

### HTML 어트리뷰트와 DOM 프로퍼티의 대응 관계

대부분의 HTML 어트리뷰트는 HTML 어트리뷰트 이름과 동일한 DOM 프로퍼티 1:1로 대응한다.

- id 어트리뷰트와 id 프로퍼티는 1:1 대응하며, 동일한 값으로 연동한다.
- input 요소의 value 어트리뷰트는 value 프로퍼티와 1:1 대응한다. 하지만 value 어트리뷰트는 초기 상태를, value 프로퍼티는 최신 상태를 갖는다.
- class 어트리뷰트는 className, classList 프로퍼티와 대응한다.
- for 어트리뷰트는 htmlFor 프로퍼티와 1:1 대응한다.
- td 요소와 colspan 어트리뷰트는 대응하는 프로퍼티가 존재하지 않는다.
- textContent 프로퍼티는 대응하는 어트리뷰트가 존재하지 않는다.
- 어트리뷰트 이름은 대소문자를 구별하지 않지만 대응하는 프로퍼티 키는 카멜 케이스를 따른다.

### DOM 프로퍼티 값의 타입

getAttribute 메서드로 취득한 어트리뷰트 값은 언제나 문자열이다. 하지만 DOM 프로퍼티로 취득한 최신 상태 값은 문자열이 아닐 수도 있다.

```jsx
<!DOCTYPE html>
<html>
<body>
  <input type="checkbox" checked>
  <script>
    const $checkbox = document.querySelector('input[type=checkbox]');

    // getAttribute 메서드로 취득한 어트리뷰트 값은 언제나 문자열이다.
    console.log($checkbox.getAttribute('checked')); // ''

    // DOM 프로퍼티로 취득한 최신 상태 값은 문자열이 아닐 수도 있다.
    console.log($checkbox.checked); // true
  </script>
</body>
</html>
```

### 39.7.4 data 어트리뷰트와 dataset 프로퍼티

data 어트리뷰트와 dataset 프로퍼티를 사용하면 HTML 요소에 정의한 사용자 정의 어트리뷰트와 자바스크립트 간에 데이터를 교환할 수 있다. data 어트리뷰트는 data-user-id, data-role과 같이 data- 접두가 다음의 임의의 이름을 붙여 사용한다.

```jsx
<!DOCTYPE html>
<html>
<body>
  <ul class="users">
    <li id="1" data-user-id="7621" data-role="admin">Lee</li>
    <li id="2" data-user-id="9524" data-role="subscriber">Kim</li>
  </ul>
  <script>
    const users = [...document.querySelector('.users').children];

    // user-id가 '7621'인 요소 노드를 취득한다.
    const user = users.find(user => user.dataset.userId === '7621');
    // user-id가 '7621'인 요소 노드에서 data-role의 값을 취득한다.
    console.log(user.dataset.role); // "admin"

    // user-id가 '7621'인 요소 노드의 data-role 값을 변경한다.
    user.dataset.role = 'subscriber';
    // dataset 프로퍼티는 DOMStringMap 객체를 반환한다.
    console.log(user.dataset); // DOMStringMap {userId: "7621", role: "subscriber"}
  </script>
</body>
</html>
```

data 어트리뷰트의 값은 HTMLElement.dataset 프로퍼티로 취득할 수 있다. dataset 프로퍼티는 HTML 요소의 모든 data 어트리뷰트의 정보를 제공하는 DOMStringMap 객체를 반환한다.

## 39.8 스타일

### 39.8.1 인라인 스타일 조작

HTMLElement.prototype.style 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티로서 요소 노드의 인라인 스타일을 취득하거나 추가 변경한다.

```jsx
<!DOCTYPE html>
<html>
<body>
  <div style="color: red">Hello World</div>
  <script>
    const $div = document.querySelector('div');

    // 인라인 스타일 취득
    console.log($div.style); // CSSStyleDeclaration { 0: "color", ... }

    // 인라인 스타일 변경
    $div.style.color = 'blue';

    // 인라인 스타일 추가
    $div.style.width = '100px';
    $div.style.height = '100px';
    $div.style.backgroundColor = 'yellow';
  </script>
</body>
</html>
```

CSS 프로퍼티는 케밥케이스를 따른다. 이에 대응하는 CSSStyleDeclaration 객체의 프로퍼티는 카멜 케이스를 따른다.

```jsx
$div.style.backgroundColor = 'yellow';
$div.style['background-color'] = 'yellow';
$div.style.width = '100px';
```

### 39.8.2 클래스 조작

`.` 으로 시작하는 클래스 선택자를 사용하는 CSS Class를 미리 정의한 다음, HTML 요소의 class 어트리뷰트 값을 변경하여 HTML 요소의 스타일을 변경할 수도 있다.

className과 classList를 이용하여 DOM 프로퍼티의 style을 변경할 수 있다.

### className

Element.prototype.className 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티로서 HTML 요소의 class 어트리뷰트 값을 취득하거나 변경한다.

```jsx
<!DOCTYPE html>
<html>
<head>
  <style>
    .box {
      width: 100px; height: 100px;
      background-color: antiquewhite;
    }
    .red { color: red; }
    .blue { color: blue; }
  </style>
</head>
<body>
  <div class="box red">Hello World</div>
  <script>
    const $box = document.querySelector('.box');

    // .box 요소의 class 어트리뷰트 값을 취득
    console.log($box.className); // 'box red'

    // .box 요소의 class 어트리뷰트 값 중에서 'red'만 'blue'로 변경
    $box.className = $box.className.replace('red', 'blue');
  </script>
</body>
</html>
```

### classList

Element.prototype.classList 프로퍼티는 class 어트리뷰트의 정보를 담은 DOMTokentList 객체를 반환한다.

```jsx
<!DOCTYPE html>
<html>
<head>
  <style>
    .box {
      width: 100px; height: 100px;
      background-color: antiquewhite;
    }
    .red { color: red; }
    .blue { color: blue; }
  </style>
</head>
<body>
  <div class="box red">Hello World</div>
  <script>
    const $box = document.querySelector('.box');

    // .box 요소의 class 어트리뷰트 정보를 담은 DOMTokenList 객체를 취득
    // classList가 반환하는 DOMTokenList 객체는 HTMLCollection과 NodeList와 같이
    // 노드 객체의 상태 변화를 실시간으로 반영하는 살아 있는(live) 객체다.
    console.log($box.classList);
    // DOMTokenList(2) [length: 2, value: "box blue", 0: "box", 1: "blue"]

    // .box 요소의 class 어트리뷰트 값 중에서 'red'만 'blue'로 변경
    $box.classList.replace('red', 'blue');
  </script>
</body>
</html>
```

DOMTokentList 객체는 class 어트리뷰트의 정보를 나타내는 컬렉션 객체로서 유사 배열 객체이면서 이터러블이다.

```jsx
$box.classList.add('foo'); // -> class="box red foo"
$box.classList.add('bar', 'baz'); // -> class="box red foo bar baz"
```

```jsx
$box.classList.remove('foo'); // -> class="box red bar baz"
$box.classList.remove('bar', 'baz'); // -> class="box red"
$box.classList.remove('x'); // -> class="box red"
```

```jsx
$box.classList.item(0); // -> "box"
$box.classList.item(1); // -> "red"
```

```jsx
$box.classList.contains('box');  // -> true
$box.classList.contains('blue'); // -> false
```

```jsx
$box.classList.replace('red', 'blue'); // -> class="box blue"
```

```jsx
$box.classList.toggle('foo'); // -> class="box blue foo"
$box.classList.toggle('foo'); // -> class="box blue"
```

```jsx
// class 어트리뷰트에 강제로 'foo' 클래스를 추가
$box.classList.toggle('foo', true); // -> class="box blue foo"
// class 어트리뷰트에서 강제로 'foo' 클래스를 제거
$box.classList.toggle('foo', false); // -> class="box blue"
```

### 39.8.3 요소에 적용되어 있는 CSS 스타일 참조

style 프로퍼티는 인라인 스타일만 반환한다. 따라서 클래스를 적용한 스타일이나 상속을 통해 암묵적으로 적용된 스타일은 style 프로퍼티를 참조할 수 없다. HTML 요소에 적용되어 있는 모든 CSS 스타일을 참조해야할 경우 getComputedStyle 메서드를 사용한다.

```jsx
<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      color: red;
    }
    .box {
      width: 100px;
      height: 50px;
      background-color: cornsilk;
      border: 1px solid black;
    }
  </style>
</head>
<body>
  <div class="box">Box</div>
  <script>
    const $box = document.querySelector('.box');

    // .box 요소에 적용된 모든 CSS 스타일을 담고 있는 CSSStyleDeclaration 객체를 취득
    const computedStyle = window.getComputedStyle($box);
    console.log(computedStyle); // CSSStyleDeclaration

    // 임베딩 스타일
    console.log(computedStyle.width); // 100px
    console.log(computedStyle.height); // 50px
    console.log(computedStyle.backgroundColor); // rgb(255, 248, 220)
    console.log(computedStyle.border); // 1px solid rgb(0, 0, 0)

    // 상속 스타일(body -> .box)
    console.log(computedStyle.color); // rgb(255, 0, 0)

    // 기본 스타일
    console.log(computedStyle.display); // block
  </script>
</body>
</html>
```

getComputedStyle 메서드의 두번째 인수로 :after, :before와 같은 의사요소를 지정하는 문자열을 전달할 수 있다.

```jsx
<!DOCTYPE html>
<html>
<head>
  <style>
    .box:before {
      content: 'Hello';
    }
  </style>
</head>
<body>
  <div class="box">Box</div>
  <script>
    const $box = document.querySelector('.box');

    // 의사 요소 :before의 스타일을 취득한다.
    const computedStyle = window.getComputedStyle($box, ':before');
    console.log(computedStyle.content); // "Hello"
  </script>
</body>
</html>
```

## 39.9 DOM 표준

HTML과 DOM표준은 W3C과 WHATWG이라는 두 단체가 나름대로 협력하면서 공통된 표준을 만들어 온다.

| 레벨 | 표준 문서 URL |
| --- | --- |
| DOM Level 1 | https://www.w3.org/TR/REC-DOM-Level-1 |
| DOM Level 2 | https://www.w3.org/TR/DOM-Level-2-Core |
| DOM Level 3 | https://www.w3.org/TR/DOM-Level-3-Core |
| DOM Level 4 | https://dom.spec.whatwg.org |

# 알았거나 몰랐거나 알게된점

## part 1.

### DOM

- **`DOM(Document Object Model)`**:
    - HTML 문서의 계층적 구조와 정보를 표현
    - HTML 요소를 제어할 수 있는 API로 프로퍼티와 메서드를 제공하는 노드 객체들로 구성된 트리 자료 구조
- **`HTML 요소`**: HTML 문서를 구성하는 개별적인 요소
    - HTML 요소 -(JS엔진에 의한 파싱)-> 요소 노드 객체
    - HTML 어트리뷰트 -(파싱)-> 어트리뷰트 노드
    - HTML 요소의 콘텐츠 -(파싱)-> 텍스트 노드
        - 시작태그
        - 어트리뷰트 이름
        - 어트리뷰트 값
        - 콘텐츠
        - 종료태그
    - HTML 요소의 중첩 관계 특성으로 다른 요소로 포함 가능함 -> 모든 노드들이 트리 자료 구조로 구성
- **`트리 자료구조`**: 부모노드, 자식노드로 구성되어 노드들의 계층 구조(비선형 자료구조)로 이뤄짐
    - 비선형 자료구조: 하나의 자료 뒤에 여러개의 자료가 존재할 수 있는 자료구조
    - 루트노드: 최상위 노드(부모 노드가 없음)
    - 리프노드: 자식 노드가 없는 노드

### 12개의 노드 타입

- Node.ELEMENT_NODE - 1
- Node.ATTRIBUTE_NODE - 2
- Node.TEXT_NODE - 3
- Node.CDATA_SECTION_NODE - 4
- Node.ENTITY_REFERENCE_NODE - 5
- Node.ENTITY_NODE - 6
- Node.PROCESSING_INSTRUCTION_NODE - 7
- Node.COMMENT_NODE - 8
- Node.DOCUMENT_NODE - 9
- Node.DOCUMENT_TYPE_NODE - 10
- Node.DOCUMENT_FRAGMENT_NODE - 11
- Node.NOTATION_NODE - 12

### 노드 객체의 상속 구조

- DOM을 구성하는 노드 객체는 DOM API를 통해 자신의 부모, 형제, 자식 탐색 가능, 자신의 어트리뷰트와 텍스트를 조작 가능
- DOM을 구성하는 노드 객체는 호스트 객체이자, JS 객체이므로 **프로토타입에 의한 상속 구조**를 갖음
- 개발자 도구의 Elements의 Properties 패널에서 상속 구조 확인 가능
- 모든 노드 객체는 Object, EventTarget, Node 인터페이스를 상속 받음
    - Document, HTMLDocument 인터페이스 - (상속) -> 문서 노드
    - Attr 인터페이스 - (상속) -> 어트리뷰트 노드
    - CharacterData 인터페이스 - (상속) -> 텍스트 노드
    - Element, 세분화된 HTMLhtmlElement, HTMLHeadElement, HTMLBodyElement, HTMLUListElement 등의 인터페이스 - (상속) -> 요소 노드
- 상속 구조
    - Object (객체)
    - EventTarget (이벤트를 발생시키는 객체)
    - Node (트리 자료구조의 노드 객체)
    - Element (브라우저가 렌더링할 수 있는 웹 문서의 요소(HTML,XML,SVG)를 표현하는 객체)
    - HTMLElement (웹 문서의 요소 중에서 HTML요소를 표현하는 객체)
    - HTML특정Element (HTML 요소중에서 특정 요소를 표현하는 객체)
    - 특정 요소 노드 객체

## **HTMLCollection, NodeList**

- DOM API가 여러 개의 결과값을 반환하기 위한 DOM 컬랙션 객체
- 둘다, 유사 배열 객체이면서 이터러블로 **for...of, 스프레드 문법, Array.from 사용하여 간단히 배열로 변환 가능**
- HTMLCollection은 노드 객체의 상태 변화를 실시간으로 반영하는 살아 있는 객체임
    - NodeList는 아님
- **`HTMLCollection`**
    - getElementsByTagName, getElementsByClassName 메서드가 반환하는 객체
    - 노드 객체의 상태 변화를 실시간으로 반영하는 살아있는 DOM 컬렉션 객체임
        - 순회 사용시 순회 과정에서 처리하면 바로 상태를 변경시키기 때문에 주의 해야함(담아온 객체에 바로 반영어 순회중에도 객체가 변함)
        - **HTMLCollection을 처리 할때는 배열에 풀어 배열 형태로 만들어 배열 고차 함수로 순회할 것을 추천**
- **`NodeList`**
    - querySellectorAll 메서드가 반환하는 객체로 실시간으로 노드 객체의 상태 변경을 하지 않는 객체임
    - 순회시 NodeList.prototype.forEach 메서드 상속받아 사용 가능
    - **단, childNodes 프로퍼티가 반환하는 NodeList 객체는 실시간으로 노드 객체 상태 변경 반영함**
        - 배열에 풀어 배열 형태로 만들어 배열 고차 함수로 순회할 것을 추천

## part 2.

### ****노드 탐색****

- 취득한 요소 노드를 기점으로 DOM 트리의 노드를 옮겨 다니며 부모, 형제, 자식 노드등을 탐색하는 것
    - 노드 탐색 프로퍼티 (getter 접근자 프로퍼티로, 읽기 전용이고 값 할당 불가)
    - Node, Element 인터페이스가 트리 탐색 프로퍼티를 제공
    - Node.prototype -> parentNode, previousSibling, firstChild, childNodes 프로퍼티
    - Element.prototype -> previousElementSibling, nextElementSibling, children 프로퍼티
- **`공백 텍스트 노드`**
    - HTML 사이의 스페이스, 탭, 개행 등의 공백 문자는 텍스트 노드를 생성함
- **`자식 노드 탐색`**
    - Node.prototype.childNodes : 자식 노드를 모두 탐색하여 NodeList에 담아 반환(텍스트 노드도 포함되어 있음)
    - **Element.prototype.children** : 자식 노드 중에서 요소 노드만 탐색하여 HTMLCollection에 담아 반환(텍스트 노드 불포함)
    - Node.prototype.firstChild : 첫번째 자식 노드를 반환(텍스트 or 요소 노드임)
    - Node.prototype.lastChild : 마지막 자식 노드를 반환(텍스트 or 요소 노드임)
    - **Element.prototype.firstElementChild : 첫번째 자식 요소 노드 반환(요소 노드만 반환)**
    - **Element.prototype.lastElementChild : 마지막 자식 요소 노드 반환(요소 노드만 반환)**
- **`자식 노드 존재 확인`**
    - Node.prototype.hasChildNodes : 자식 노드가 존재하면 true, 아니면 false 반환(텍스트 노드 포함)
    - **Element.prototype.children.length 프로퍼티** (텍스트 노드 불포함)
    - **Element.prototype.childElementCount 프로퍼티** (텍스트 노드 불포함)
- **`부모 노드 탐색`**
    - Node.prototype.parentNode 프로퍼티 (부모노드는 텍스트 노드 일 수 없음)
- **`형제 노드 탐색`**
    - Node.prototype.previousSibling : 부모 노드가 같은 형제노드 중 자신의 이전 형제 노드 반환(텍스트 노드 포함)
    - Node.prototype.nextSibling : 부모 노드가 같은 형제노드 중 자신의 이후 형제 노드 반환(텍스트 노드 포함)
    - **Element.prototype.previousElementSibling** : 부모 노드가 같은 형제노드 중 자신의 이전 형제 요소 노드를 탐색 반환(텍스트 노드 X)
    - **Element.prototype.nextElementSibling** : 부모 노드가 같은 형제노드 중 자신의 이후 형제 요소 노드를 탐색 반환(텍스트 노드 X)

## part 3.

### **노드 정보 취득**

- **`Node.prototype.nodeType`** : 노드 타입을 나타내는 상수 반환
    - Node.ELEMENT_NODE: 요소 노드 타입 상수 1
    - Node.TEXT_NODE: 텍스트 노드 타입 상수 3
    - Node.DOCUMENT_NODE: 문서 노드 타입 상수 9
- **`Node.prototype.nodeName`**: 노드 이름을 문자열로 반환
    - 요소노드 -> 대문자 문자열로 태그 이름 반환
    - 텍스트 노드 -> #text 반환
    - 문서노드 -> #document 반환

### **요소 노드의 텍스트 조작**

- **`Node.prototype.nodeValue 프로퍼티`** : 노드 객체의 값(텍스트 노드의 텍스트)을 반환
    - setter, getter 존재하는 접근자 프로퍼티 (할당, 참조 모두 가능)
    - 텍스트 노드가 아닌 노드에 nodeValue 프로퍼티를 참조하면 null 반환
    - 텍스트 노드의 nodeValue 프로퍼티에 값 할당시 텍스트를 변경할 수 있음
- **`Node.prototype.textContent 프로퍼티`** : 요소 노드의 텍스트와 모든 자손 노드의 텍스트를 모두 취득하거나 변경함
    - setter, getter 존재하는 접근자 프로퍼티 (할당, 참조 모두 가능)
    - 노드 구조를 무시하고, 해당 노드 아래로 모두 텍스트를 취함
    - 텍스트 노드가 아닌 노드에 nodeValue 프로퍼티를 참조하면 null 반환
    - **textContent에 값을 할당하면, 모든 자식 노드가 제거되고 할당한 문자열이 텍스트로 추가됨**
        - **HTML 마크업을 text로 할당해도 파싱되지 않고, 문자열로 취급됨**
    - **`innerText 프로퍼티`** : CSS에의해 visibility: hidden으로 된 요소노드의 텍스트를 반환하지 않음
        - 그리고 textContetn 보다 느림

## part 4.

### **DOM 조작**

- **`DOM 조작`** : 새로운 노드를 생성하여 DOM에 추가하거나 기존 노드를 삭제 또는 교체하는 것
    - DOM 조작시 새로운 노드 추가, 삭제 되면서 리플로우와 리페인트가 발생하므로 주의해야함
- **`Element.prototype.innerHTML 프로퍼티`** : 요소 노드의 콘텐츠 영역 내에 포함된 모든 HTML 마크업을 문자열로 반환함
    - setter, getter 존재하는 접근자 프로퍼티 (할당, 참조 모두 가능)
        - textContent 프로퍼티는 HTML 마크업을 무시하고 텍스트만 반환
        - innerHTML 프로퍼티는 HTML 마크업이 포함된 문자열을 반환
    - innerHTML 프로퍼티에 문자열 할당시 요소 노드의 모든 자식 노드가 제거되고 할당한 **문자열에 포함된 HTML 마크업이 파싱되어 요소 노드의 자식 노드로 DOM에 반영**
    - 단점:
        - **`+=`** 연산자를 통해서 계속 추가한다고 해도, 기존의 있던 것도 모두 제거하고 다시 생성함 -> 비효율적
        - 삽입될 새로운 요소의 위치 지정 불가함
    - **`XXS(크로스 사이트 스크립팅 공격)`**
        - 사용자로 부터 입력받은 데이터를 그대로 innerHTML 프로퍼티에 할당하는 것은 **XSS(크로스 사이트 스크립팅 공격)**에 취약함
            - HTML5의 경우 innerHTML에 삽인된 script 요소 내의 JS 코드는 실행하지 않음
            - 하지만, 에러 이벤트를 강제로 발생시켜 자바스크립트 코드가 실행되도록 할 수 있음
    - **`HTML 새니티제이션(HTML sanitization)`** :
        - 크로스 사이트 스크립팅 공격 예방을 위해 잠재적 위험 제거 기능
        - **DOMPurify 라이브러리 사용 권장**
- **`Element.prototype.insertAdjacentHTML(position, DOMString)`**
    - 기존 요소를 제거하지 않으면서 위치를 지정해서 새로운 요소 삽입
    - position : 'beforebegin', 'afterbegin', 'beforeend', 'afterend'
        - 해당 요소 시작 태그와 종료 태그를 기준으로 함
    - DOMString : 추가할 HTML 마크업 문자열

### **노드 조작**

**생성**

- **`Document.prototype.createElement(tagName)`** : 요소 노드를 생성하여 반환
    - 요소 노드를 생성할 뿐 DOM에 추가하진 않음
- **`Document.prototype.createTextNode(text)`** : 텍스트 노드를 생성하여 반환
    - 텍스트 노드를 생성할 뿐 요소 노드의 자식 노드로 추가하진 않음

**추가**

- **`Node.prototype.appendChild(childNode)`** : 호출한 노드의 **마지막 자식 노드로** 인수로 전달한 노드를 추가함
    - 생성된 텍스트 노드를 요소노드 자식으로 추가하는 것은 textContent 프로퍼티로 하는 것이 간편함
    - 생성된 요소 노드를 DOM으로 연결된 요소의 자식으로 추가하면 DOM 트리에 추가되어 연결됨
    - 다수의 요소 노드를 DOM으로 연결시
        - 매번 생성해서 바로 DOM으로 추가하면, 그 추가하는 횟수 만큼 리플로우와 리페인트가 실행됨
        - **`Document.prototype.createDocumentFragment()`** : 비어있는 DocumentFragment 노드를 생성하여 반환함
            - **DocumentFragment 노드를 생성하여 DocumentFragment노드에 추가할 여러 노드를 구현해 놓고, DOM으로 1번만에 연결함**
                - DocumentFragment 노드는 Dom과 연결시 자신은 제거됨
- **`Node.prototype.insertBefore(newNode, childNode)`**: newNode를 childNode의 앞에 삽입함
    - childNode 인수: 두번째 인수의 노드는 반드시 insertBefore 메서드를 호출한 노드의 자식 노드이어야 함
        - childNode가 null이면 insertBefore를 호출한 노드의 마지막 자식 노드로 추가됨 (appenchild 처럼)

**이동**

- 이미 존재하는 노드를 appendChild 또는 insertBefore 사용하여 추가하면 새로운 위치로 이동함(기존의 위치에서 제거하고)

**복사**

- **`Node.prototype.cloneNode(deep)`** : 호출한 노드의 사본을 생성하여 반환
    - deep: true(노드를 모든 자손 노드 포함된 사본 생성), false or 생략(노드 자신만의 사본을 생성)

**교체**

- **`Node.prototype.replaceChild(newChild, oldChild)`** : 자신을 호출 노드의 자식 노드를 다른 노드로 교체
    - newChild : 교체할 새로운 노드
    - oldChild : 이미 존재하는 교체될 노드 (replaceChild를 호출한 노드의 자식 노드이어야 함)

**삭제**

- **`Node.prototype.removeChild(child)`** : 호출한 노드에서 전달한 child노드를 삭제함
    - child : 제거할 노드(removeChild를 호출한 노드의 자식 노드이어야 함)

### **어트리뷰트**

- **`어트리뷰트`** : HTML 요소의 동작 제어를 위한 추가적인 정보를 제공함
    - 어트리뷰트 이름="어트리뷰트 값" 형식으로 정의
    - 글로벌 어트리뷰트 : id, class, style, title, lang, tabindex, draggble, hidden 등
    - 이벤트 핸들러 어트리뷰트 : onclikc, onchange, onfocus, onblur, oninput, onkeypress, onkeydown, onkeyup, onmouseover, onsubmit, onload 등
    - 특정 어트리뷰트 :
        - type, value, cheked -> input 요소에서만 사용
    - HTML 요소의 어트리뷰트 -(파싱)-> 어트리뷰트 노드
    - 어트리뷰트 값은 항상 문자열 임
- **`Eleement.prototype.attributes 프로퍼티`**
    - 요소 노드의 모든 어트리뷰트 노드의 참조가 담긴 NamedNodeMap 객체 반환
    - getter만 존재하는 읽기 전용임
    - **요소 노드의 attributes 프로퍼티의 어트리뷰트 노드들이 관리됨**
- **`Element.prototype.hasAttribute(attributeString)`**
    - 요소 노드에 해당 어트리뷰트가 있는지 확인
- **`Element.prototype.removeAtrribute(attributeString)`**
    - 요소 노드에 해당 어트리뷰트 삭제
- **`어트리뷰트 노드`** : HTML 요소의 초기 상태(초기 값)의 어트리뷰트를 어트리뷰트 노드에서 관리
    - **`Element.prototype.getAttribute(attributeString)`** :
    - **`Element.prototype.setAttribute(attributeString, attributeValue)`** :
        - 요소 노드에서 메서드를 통해 직접 HTML 어트리뷰트 초기값 취득 또는 변경 가능
- **`DOM 프로퍼티`**:
    - 사용자가 입력한 HTML 어트리뷰트 최신 상태의 값을 관리(요소 노드의 프로퍼티로 각 어트리뷰트에 대한 프로퍼티가 있음)
    - setter, getter 모두 존재하는 접근자 프로퍼티 임
        - 최신 상태 값을 변경하는 것으로, 기존 HTML 지정 값은 변하지 않음
        - 사용자 입력과 관련된 어트리뷰트만 최신 상태 값을 가짐
- **`DOM 프로퍼티 vs attributes프로퍼티의 어트리뷰트 노드`**
    - **요소 노드의 초기 상태 -> 어트리뷰트 노드**
    - **요소 노드의 최신 상태 -> DOM 프로퍼티가 관리**
- **`DOM 프로퍼티와 HTML 어트리뷰트의 대응 관계`**
    - id 어트리뷰트 - id 프로퍼티 : 항상 1:1 대응, 동일 값 유지
    - input value 어트리뷰트 - value 프로퍼티 : 1:1 대응, 서로 값은 다를 수 있음
    - class 어트리뷰트 - className, classList 프로퍼티
    - td요소 colspan 어프리뷰트 대응 프로퍼티 X
    - textContent 프로퍼티 대응 어트리뷰트 X
    - 어트리뷰트 이름 대소문자 구분X / 프로퍼티 키 = 카멜케이스
    - DOM 프로퍼티 값은 문자열이 아닐수 있음

### **data 어트리뷰트와 data 프로퍼티**

- **data 어트리뷰트와 data프로퍼티를 통해서 HTML과 JS 간의 데이터 교환 가능**
- **`data 어트리뷰트`**
    - 'data-이름' 형식으로 어트리뷰트 이름을 사용함
- **`HTMLElement.dataset 프로퍼티`** : data 어트리뷰트 값 취득 가능
    - **DOMStringMap 객체 반환** (HTML 요소의 data 어트리뷰트에 따른 모든 data 프로퍼티를 담고 있음)
- **`data 프로퍼티`**
    - data 어트리뷰트에 대응하여, 카멜케이스로 만들어진 프로퍼티
        - data 어트리뷰트의 값 취득 및 변경 가능
        - data 어트리뷰트에 존재하지 않는 이름을 키로 사용하여 dataset 프로퍼티에 값 할당시 동적으로 data 어트리뷰트가 추가됨(케밥 케이스 형태로 어트리뷰트가 추가됨)

### **스타일**

- **`HTMLElement.prototype.style 프로퍼티`** : 요소 노드의 인라인 스타일을 취득, 추가, 변경
    - setter, getter 모두 존재하는 접근자 프로퍼티
    - CSSStyleDeclaration 타입 객체 반환
    - **`CSSStyleDeclaration 객체`**
        - 다양한 CSS 프로퍼티에 대응하는 프로퍼티로 구성됨
        - CSSStyleDeclaration 객체의 프로퍼티는 카멜 케이스 사용 (케밥 케이스 사용시 대괄호 사용)
        - **CSSStyleDeclaration 객체의 프로퍼티 값은 항상 `단위`를 붙여야함**
    - **`CSS 프로퍼티`** :
        - 해당 프로퍼티에 값 할당시 반영됨
        - CSS 프로퍼티는 케밥 케이스 사용

### **클래스 조작**

- class 어트리뷰트에 대응하는 DOM프로퍼티는 className, classList 프로퍼티 임
- **`Element.prototype.className 프로퍼티`** : HTML 요소의 class 어트리뷰트 값을 취득하거나 변경
    - setter, getter 모두 존재
- **`Element.prototype.classList 프로퍼티`** : class 어트리뷰트 정보를 담은 **DOMTokenList 객체 반환**
    - **`DOMTokenList`** : 유사 배열 객체이면서 이터러블 임
        - **`add(...className)`** : 인수로 전달한 1개 이상의 문자열을 class 어트리뷰트 값으로 추가
        - **`remove(...className)`** : 인수로 전달한 1개 이상의 문자열과 일치하는 class 어트리뷰트 값을 제거함 (없으면 무시됨)
        - **`item(index)`** : index에 해당하는 클래스를 class 어트리뷰트에서 반환함
        - **`contains(className)`** : 인수로 전달한 문자열과 일치하는 클래스가 class 어트리뷰트에 있는지 확인
        - **`replace(oldClassName, newClassName)`** : class 어트리뷰의 특정 클래스를 찾아 새로운 클래스 이름으로 변경함
        - **`toggle(className, 조건식)`** : class 어트리뷰트에 인수로 전달한 문자열과 일치하는 클래스 존재시 제거, 존재안하면 추가
            - 전달한 조건식의 평가가 true이면 첫번째 인수의 문자열을 추가, false이면 제거
        - forEach, entries, keys, values, supports 등 메서드 제공
- **`window.getComputedStyle(element, pseudo)`**
    - stype 프로퍼티의 값 뿐만 아니라, 클래스를 적용한 스타일, 암묵적으로 적용된 스타일을 보기 위해 사용함
        - element에 적용되어 평가된 스타일을 CSSStyleDeclaration 객체에 담아 반환(최종적으로 적용된 스타일 확인 가능)
        - pseudo: 가상요소 선택자를 넣어서 해당 가상요소에 대한 스타일을 볼수 있음
            - :after, :before

### **DOM 표준**

- 현재 WHATWG이 단일 표준을 내놓음
- DOM은 현재 4개의 버전이 있음

##
