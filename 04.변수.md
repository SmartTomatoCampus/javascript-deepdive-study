# Deep Dive #04장 변수

![993671415C62E8F11D](https://user-images.githubusercontent.com/34502254/155888878-3be5dcf7-8f5b-4581-8c9a-3cfe482926fc.png)

# **04장 변수**

## **4.1 변수란 무엇인가? 왜 필요한가?**

애플리케이션은 데이터를 다룬다. 아무리 복잡한 애플리케이션이라 해도 데이터를 입력받아 처리하고 그 결과를 출력하는 것이 전부다.

변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념이다.

변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.

### 변수에 여러 개의 값을 저장하는 방법

```jsx
// 변수는 하나의 값을 저장하기 위한 수단이다.
const userId = 1;
const userName = 'Jang';
// 객체나 배열 같은 자료구조를 사용하면 여러 개의 값을 하나로
// 그룹화해서 하나의 값처럼 사용할 수 있다.
const user = { id: 1 , name: "Jang" };
const users = [
{ id: 1, name: "Jang" }
{ id: 2, name: "Kim" }
]
```

변수에 값을 저장하는 것을 assignment ( 할당 )

변수에 저장된 값을 읽어 들이는 것을 reference ( 참조 )

## **4.2 식별자**

식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.

## **4.3 변수 선언**

변수를 사용하려면 반드시 선언이 필요하다. 변수를 선언할 때는 var , let , const 사용하나, var는 이제 버리자.

### ES5 vs. ES6

```jsx
var 키워드는 여러 단점이 있다.
var 키워드의 여러 단점 중에서 가장 대표적인 것이 블록 레벨 스코프를 지원하지 않고,
함수 레벨 스코프를 지원한다는 것이다.
이로 인해 전역변수로 선언되어 심각한 부작용이 발생한다.
```

```jsx
ES6는 기본적으로 하위 호환성을 유지하면서 ES5의 기반 위에 새로운 기능을 추가한것이다. 다시말해 ES6는 ES5의 상위 집합이다.
```

### undefined - 자바스크립트에서 제공하는 원시 타입의 값이다.

### 변수 이름은 어디에 등록되는가 ?

```jsx
변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다.
실행 컨텍스트는 자바스크립트 엔진이 소스코드를 평가하고
실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.
자바스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리한다.
```

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되는 것이다.

자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행된다.

즉 호이스팅이란 , 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라고 한다. ( variable hoisting )

## 4.5 값의 할당

변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만, 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

```jsx
console.log(score); // undefined

score = 80; // 값의 할당
var score; // 변수 선언

console.log(score); // ??
```

## 4.6 값의 재할당

재할당은 변수에 저장된 값을 다른 값으로 변경한다. 그래서 변수라고 하는 거싱다.

만약 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라고 한다.

상수는 한번 정해지면 변하지 않는 값이다. 다시 말해 상수는 단 한 번만 할당할 수 있는 변수다.

```jsx
var score = 80; // 변수 선언과 값의 할당
score = 90; // 값의 재할당
```

### 가비지 콜렉터

가비지 콜렉터는 애플리케이션 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다. 더 이상 사용되지 않는 메모리란 간단히 말하자면 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다. 자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서 가비지 콜렉터를 통해 **메모리누수**를 방지한다.

### 언매니지드 언어와 매니지드언어

- 언매니지드
  - 언어는 메모리 제어를 개발자가 주도할 수 있으므로 개발자의 역량에 따라 최적의 성능을 확보할 있지만 그 반대의 경우 치명적 오류를 생산할 가능성도 있다.
- 매니지드
  - 매니지드 언어는 메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자의 직접적인 메모리 제어를 허용하지 않는다.

## 4.7 식별자 네이밍 규칙

식별자는 네이밍 규칙을 준수해야 한다.

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어, 달러기호를 포함할 수 있다.
- 단, 식별자는 특수문자를 제외한 문자, 언더스코어, 달러기호로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.
- 예약어는 식별자로 사용할 수 없다.

| await     | break    | case       | catch  | class   | const      |
| --------- | -------- | ---------- | ------ | ------- | ---------- |
| continue  | debugger | default    | delete | do      | else       |
| enum      | export   | extends    | false  | finally | for        |
| function  | if       | implements | import | in      | instanceof |
| interface | let      | new        | null   | package | private    |
| protected | public   | return     | super  | static  | switch     |
| this      | throw    | true       | try    | typeof  | var        |
| void      | while    | with       | yield  |         |            |

네이밍 컨벤션은 하나 이상의 영어단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙이다.

일관성을 유지한다면 , 네이밍 컨벤션을 유지해도 좋지만, 자바스크립트에서는 일반적으로 카멜 케이스를 사용하고, 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용한다.
