# 17. 생성자 함수에 의한 객체 생성

생성일: 2022년 3월 7일 오후 8:47

## 17. 1 Object 생성자 함수

- 생성자 함수란 new 연산자와 함께 호출하여 객체(인스턴스)를 호출하는 함수를 말한다.
- 생성자 함수에 의해 생성된 객체를 인스턴스라 한다.
- Object를 이용해 객체를 생성하는 방식은 그닥 유용하지는 않다
- 주로 리터럴을 이용해 객체를 생성한다.

```jsx
// 빈 객체 생성
const person = new Object();

// 프로퍼티 추가
person.name = 'Lee';
perseon.sayHello = function(){
	console.log('Hi: My name is ' + this.name);
}

console.log(person);
pereson.sayHello();
```

## 17. 2 생성자 함수

### 17. 2. 1 객체 리터럴에 의한 객체 생성방식의 문제점

- 객체 리터럴의 객체 생성방식은 하나의 객체만 생성하기 때문에 동일한 프로퍼티를 갖는 객체를 여러개 생성해야 할 경우 같은 프로퍼티를 기술해야 하기 때문에 비효율적이다.

```jsx
const circle1 = {
	radius: 5,
	getDiameter(){
		return 2 * this.radius;
	}
};

console.log(circle1.getDiameter());  // 10

const circle2 = {
	radius: 10,
	getDiameter(){
		return 2 * this.radius;
	}
};

console.log(circle2.getDiameter()); // 20
```

### 17. 2. 2 생성자 함수에 의한 객체 생성 방식의 장점

- 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.

```jsx
function Circle(radius){
	// 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
	this.radius = radius;
	this.getDiameter = function(){
		return 2 * this.radius;
	};
}

// 인스턴스의 생성
const circle1 = new Circle(5);   // 반지름이 5인 Circle 객체를 생성
const circle2 = new Circle(10);  // 반지름이 10인 Circle 객체를 생성

console.log(circle1.getDiameter());  // 10
console.log(circle2.getDiameter());  // 20
```

<aside>
💡 **this**
this는 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기참조 변수로, this의 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.

</aside>

| 함수 호출 방식 | this가 가리키는 값(this 바인딩) |
| --- | --- |
| 일반 함수로서 호출 | 전역 객체 |
| 메서드로서 호출 | 메서드를 호출한 객체(마침표 앞의 객체) |
| 생성자 함수로서 호출 | 생성자 함수가 (미래에) 생성할 인스턴스 |

```jsx
function foo(){
	console.log(this);
}

// 일반 함수로서 호출
foo(); // window -> 전역객체는 브라우저 환경에선 window, node 환경에서는 global을 가리킨다.

// 메서드로서 호출
const obj = { foo }; 
obj.foo();  // obj -> 메서드를 호출한 객체

// 생성자 함수로서 호출
const inst = new foo();  // inst
```

## 17. 2. 3 생성자 함수의 인스턴스 생성과정

- 생성자 함수의 역할은 동일한 프로퍼티 구조를 갖는 인스턴스를 생성하기 위한 템플릿(클래스)으로 동작해서 인스턴스를 생성하고 생성된 인스턴스를 초기화 하는 것이다.
- 자바스크립트는 다음과 같은 과정으로 암묵적으로 인스턴스를 생성하고 인스턴스를 초기화 한 뒤 암묵적으로 인스턴스를 반환한다.

1. **인스턴스 생성과 this 바인딩**
암묵적으로 빈 객체가 생성된다. 인스턴스는 this에 바인딩된다.
2. 인스턴스 초기화
생성자 함수에 기술되어있는 코드가 한 줄씩 실행되어서 this에 바인딩 되어있는 인스턴스를 초기화한다. 
3. 인스턴스 반환
생성자함수 내부의 처리가 끝나면 인스턴스가 바인딩 된 this가 암묵적으로 반환된다.

```jsx
function Circle(radius){
	// 1. 암묵적으로 빈 객체 생성, this에 바인딩 됨
  // 2. this에 바인딩되어 있는 인스턴스를 초기화
  this.radius = radius;
  this.getDiameter = function(){
		return 2 * this.radius;
	}
	// 3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환
	// 명시적으로 원시값 반환 시 원시 값은 무시되고 암묵적으로 this가 반환됨
  return 100;
}

// 인스턴스 생성, Circle 생성자함수는 암묵적으로 this를 반환한다.
const circle = new Circle(1);
console.log(circle);
```

### 17. 2. 4 내부 메서드 [[Call]]과 [[Construct]]

- 함수 객체는 일반 객체가 갖고 있는 내부 슬롯 뿐 아니라 [[Call]], [[Construct]] 같은 내부 메서드를 추가로 갖고 있다.
- 일반함수로서 호출되는 경우 함수 내부 메서드 call이 호출되고 생성자함수로서 호출되면 construct가 호출된다.
- 내부 메서드 [[Call]]을 갖는 함수 객체를 callable이라고 하고, [[Construct]]를 갖는 함수 객체를 constructor, [[Constructor]]를 갖지 않는 함수 객체를 non-constructor라고 부른다.
- 모든 함수 객체는 내부 메서드를 갖고 있기때문에 호출 할수 있지만, 모든 함수가 [[Construct]]를 갖는 것은 아니다.

![Untitled](17%20%E1%84%89%E1%85%A2%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8C%20f6f34/Untitled.png)

### 17. 2. 5 constructor와 non-constructor의 구분

- constructor : 함수 선언문, 함수 표현식, 클래스
- non-constructor : 메서드(ES6 메서드 축약표현), 화살표 함수

```jsx
// 함수 선언문, 함수 표현식
function foo(){}
const bar = function (){};
// 프로퍼티 x 값으로 할당된 것은 일반 함수로 정의된 함수다. 이는 메서드로 인정하지 않는다.
const baz = {
	x: function(){}
};

new foo();  // -> foo {}
new bar();  // -> bar {}
new bar.x();  // -> x {}

// 화살표 함수
const arrow = () => {};
new arrow();  // TypeError -> non-constructor이기 때문에
const obj = {
	x() {}
};

new obj.x()  // TypeError: obj.x is not a constructor
```

### 17. 2. 6 new 연산자

- new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다.

```jsx
// 생성자 함수
funciton Circle(radius){
	this.radius = radius;
	this.getDiameter = function(){
	return 2 * this.radius;
	};
}

// new 연산자 없이 호출하는 경우 일반함수로 인식함
const circle = Circle(5);
console.log(circle); // undefined
console.log(radius); // 5
console.log(getDiameter()); // 10

circle.getDiameter();  // TypeError
```

### 17. 2. 7 new.target

- new 연산자 없이 생성자 함수가 일반 함수로서 호출되는 것을 방지하기 위해 new.target을 사용한다.
- new 연산자와 함께 생성자 함수로 호출되면 new.target은 함수 자신을 가리킨다.
- new 연산자 없이 일반함수로서 호출된 함수 내부의 new.target은 undefined이다.

```jsx
// 생성자 함수
function Circle(radius){
	if(!new.target){
		return new Circle(radius);
	}
		this.radius = radius;
		this.getDiameter = function(){
			return 2 * this.radius;
	}
};

// 생성자 함수 없이 호출해도 new.target을 통해 생성자 함수로서 호출된다.
const circle = Circle(5);
console.log(circle.getDiameter());

```