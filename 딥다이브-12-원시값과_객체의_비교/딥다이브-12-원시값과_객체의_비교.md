# [JavaScript]  원시 값과 객체의 비교

<aside>
💻 자바스크립트에서의 데이터타입은 원시 타입(primitive type)과 객체 타입(object type)으로 구분됨

- **원시 타입의 값, 즉 원시 값은 변경 불가능한 값이다(immutable value)**
- 반면 **객체(참조)타입의 값은 변경 가능한 값(mutable value)**

원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장됨
반면에 객체를 변수에 할당하는 변수(확보된 메모리 공간)에는 참조 값이 저장됨

원시 값을 갖는 변수를 다른 변수에 할당하면 원시 값이 복사되어 전달됨 → 값에 의한 전달
반면 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달됨 → 참조에 의한 전달

</aside>

## 원시값

---

### 변경 불가능한 값

- **원시 타입(primitive type)**의 값, 즉 원시 값은 변경이 불가능한 값임
    
    → 즉 한번 생성된 원시 값은 읽기 전용값으로서 변경할 수 없음
    
- 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이고,
값은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과를 말함
    
    → 즉 변경 불가능하다는 것은 변수가 아니라 값을 말하는 것!!
    
    ( “원시 값은 변경 불가능하다"는 말은 원시 값 자체를 말하는 거지 변수 값을 변경할 수 없다는 말이 아니라는 뜻 )
    
- 변수는 언제든지 ‘재할당'을 통해 변수 값을 변경(엄밀히 말하면 교체)할 수 있음
    
    (상수 또한 재할당이 금지된 변수일 뿐임)
    

> 원시 값은 변경 불가능한 값이기 때문에, 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후,
변수가 참조하던 메모리 공간의 주소를 변경함
> 
> 
> ⇒ 값의 이러한 특성을 **불변성**이라고 함!
> 

### 문자열과 불변성

- 숫자열은 1도, 1000000도 동일한 8바이트가 필요하다면, 문자열은 한 글자당 2바이트가 필요하다는 특징이 있음

```jsx
var str = 'Hello'
str = 'world'
```

- 여기서 변수 str 에 새로운 문자열을 할당하면 ‘Hello’ 라는 값 자체가 변경되는 것이 아니라,
새로운 메모리에 ‘world’ 를 할당하고 식별자 str 은 이 메모리를 가리키게 됨
- 즉, ‘Hello’ 와 ‘world’ 는 모두 메모리에 존재함
- 문자열은 유사배열 객체이면서 이터러블이므로, 배열과 유사하게 각 문자에 접근할 수 있음
    
    > **유사 배열 객체란?**
    > 
    > 
    > ---
    > 
    > 유사 배열 객체란, 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 `length` 프로퍼티를 갖는 객체를 말함
    > 
    > ```jsx
    > var str = 'string'
    > 
    > console.log(str[0])  // s
    > 
    > console.log(str.length) // 6
    > console.log(str.toUpperCase())  // STRING
    > ```
    > 
    > 원시값을 객체처럼 사용하면 원시값을 감싸는 래퍼 객체로 자동 변환됨 ( DeepDive 21.3절 “원시 값과 래퍼 객체"에서 )
    > 
- 만일 `str[0] = 'S'` 처럼 재할당한다고 해도 문자열 또한 원시값으로서 읽기전용이기 때문에 
새로운 문자열을 메모리에 할당하고 식별자가 가리키는 곳이 바뀌는 것임

### 값에 의한 전달

```jsx
var score = 80
var copy = score

console.log(score) // 80
console.log(copy) // 80

score = 100

console.log(score) // 100
console.log(copy)  // ???
```

- 여기서 최종적으로 copy 는 80 이 나옴
- 이처럼 변수에 원시 값을 갖는 변수를 할당하면 변수(copy)에는 할당되는 변수(score)의 원시값이 복사되어 전달됨
    
    ⇒ **값에 의한 전달**
    
- 이 때 score 와 copy 는 숫자값 80 을 갖는다는 점에서 동일하지만, **둘 변수의 값 80은 각각 다른 메모리 공간에 저장된 별개의 값임**

<aside>
💻 다시 한번 강조하면, **변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문에,
변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하는 것이다**

</aside>

## 객체

---

- 객체는 프로퍼티가 추가, 수정, 삭제될 수 있기 때문에 확보해야 할 메모리 공간의 크기를 사전에 정해둘 수 없음
- 따라서 원시값과는 다른 방식으로 동작하도록 설계됨

### 변경 가능한 값

- **객체(참조) 타입의 값**, 즉 객체는 변경 가능한 값임
- 원시값의 경우 값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시 값에 접근할 수 있음
    
    → 즉 원시값을 할당한 변수는 원시값 자체를 값으로 가짐
    
- 반면 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조값**에 접근하게 됨
    
    참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체임
    

<aside>
💻 원시값은 변경 불가능한 값이므로 원시값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없음

**반면 객체는 변경 가능한 값임**

**따라서 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있음**

⇒ **즉 재할당 없이 프로퍼티를 동적으로 추가, 갱신, 삭제할 수도 있음**

</aside>

- 객체는 성능상의 이유로 또 메모리를 효율적으로 사용하기 위해서 변경 가능한 값으로 설계되었음
    
    ⇒ 때문에 여러개의 식별자가 하나의 객체를 공유할 수 있음
    

### 참조에 의한 전달

```jsx
var person = {
	name: 'KMin'
}

// 참조 값을 복사(얕은 복사)
var copy = person
```

- 객체를 가리키는 변수(person)를 다른 변수(copy)에 할당하면 **원본의 참조값이 복사되어 전달됨**
    
    ⇒ **참조에 의한 전달**
    
- 즉 person 과 copy 는 동일한 객체를 가리키는, **두 개의 식별자가 하나의 객체를 공유하게 됨**
    
    ⇒ 따라서 person 이나 copy 둘 중 하나를 변경하면 새로운 객체를 할당하는 것이 아니라 서로 영향을 주고 받게됨
    
    ```jsx
    var person = {
    	name: 'KMin'
    }
    
    // 참조값을 복사(얕은 복사). copy 와 person 은 동일한 참조값을 가짐
    var copy = person
    
    // copy 와 person 은 동일한 객체를 참조함
    console.log(copy === person) // true
    
    copy.name = 'Choi'
    person.address = 'Seoul'
    
    console.log(person) // { name: 'Choi', address: 'Seoul' }
    console.log(copy)   // { name: 'Choi', address: 'Seoul' }
    ```
    

> 결국 “값에 의한 전달"과 “참조에 의한 전달"은 식별자가 기억하는 **메모리 공간에 저장되어 있는 값을 복사해서 전달**된다는 면에서 동일함
> 
> 
> ( 다만 식별자가 기억하는 메모리 공간이 원시값이냐 참조값이냐의 차이만 있을 뿐임 )
> 

```jsx
var person1 = {
	name = 'KMin'
}

var person2 = {
	name = 'KMin'
}

console.log(person1 === person2) // false
console.log(person1.name === person2.name) // true
```

- 여기서 person1 과 person2 는 가리키는 객체 내용이 같지만 다른 메모리에 저장된, 다른 참조값을 가지는 다른 객체임
    
    ⇒ 즉 person1 변수와 person2 변수의 참조값은 전혀 다른 값이기 때문에 `false`
    
- 반면 프로퍼티 값을 참조하는 [person1.name](http://person1.name) 과 [person2.name](http://person2.name) 은 값으로 평가될 수 있는 표현식임
    
    ⇒ 두 표현식 모두 원시값 ‘KMin’ 으로 평가될 수 있기 때문에 `true`
    

### 심화

```jsx
var person1 = {
    name: 'KMin',
    parents: {
        father: 'Choi',
        mother: 'Nam'
    }
}

var person2 = {
    name: 'KMin',
    parents: {
        father: 'Choi',
        mother: 'Nam'
    }
}

console.log(person1 === person2) // false
console.log(person1.name === person2.name) // true
console.log(person1.parents === person2.parents) // false
console.log(person1.parents.father === person2.parents.father) // true
```