<h3 style = "color:lightgreen">연산자(Operator)</h3>

---

1. **연산자**는 하나 이상의 표현식을 **대상**으로 한다.
2. **연산자** 산술, 할당, 비교, 논리, 타입, 지수연산 등을 수행해 하나의 값을 만든다.
3. **피연산자**는 **값으로 평가될 수 있는 표현식**이어야한다.
4. **피연산자와 연산자의 조합**으로 이뤄진 **연산자 표현식**도 값으로 평가될 수 있는 표현식이다.

###### 4번이 이해가 어려울 수 있는데 쉽게 생각하면, 하나 이상의 답을 도출해내는 <span style= 'color:red'> 계산식을 값으로 평가할 수</span> 있다는 것이다.

```js
function sum(x, y) {
  return x + y;
}
sum(3, 4);
```

###### x + y는 피연산자 x,y와 연산자 +의 조합으로 하나의 표현식이 되었고, 이것도 곧 값이라고 할 수 있다.

---

<h4 style = "color:lightsalmon">연산자(Operator)의 종류</h4>

---

#### 단항 산술연산자

<table>
  <tr>
    <td colspan=2>단항 산술 연산자는 1개의 피연산자를 연산하여 숫자값을 만든다</td>
  </tr>
    <tr>
      <td colspan=4><b>전위 증가/감소 연산자</b> - 먼저 피연산자의 값을 증가/감소시킨 후 다른 연산 실행한다.</td>
  </tr>
  <tr>
    <td>++i</td><td>먼저 값i가 증가된다.</td><td>--i</td><td> 먼저 값 i가 감소된다.</td>
  </tr>
  <tr><td colspan=4></td></tr>
      <tr>
        <td colspan=4><b>후위 증가/감소 연산자</b> - 먼저 다른 연산을 수행한 뒤, 피연산자의 값을  증가/감소시킨다. </td>
  </tr>
  <tr>
  <td>i++</td><td>다른 연산 수행 후 i 값을 증가시킨다.</td><td>i--</td><td>다른 연산 수행 후 i 값을 감소시킨다.</td>
  </tr>
  </table>

---

#### 전위/후위 단항 산술 연산자를 이해하기 위해서는 다음 예제를 이해해야 한다.

```js
let x = 5,
  result;

result = x++;
console.log(result, x); // output ?

result = ++x;
console.log(result, x); // output ?

result = x--;
console.log(result, x); // output ?

result = --x;
console.log(result, x); // output ?
```

##### 단항 산술 연산자에는 ++,-- 뿐만 아니라 -,+ 도 있다.

##### + 단항 산술 연산자는 부수효과는 없지만, 타입을 숫자 타입으로 변환하여 나타내준다.

##### 중요한점은 변수의 값을 바꾸는 것이 아닌 새로운 값을 생성해 반환한다.

```js
let x = '1';
console.log(+x); // output 1

let x = true;
console.log(+x); // output 1

let x = false;
console.log(+x); // output 0
```

##### - 단항 산술 연산자도 부수효과는 없고 피연산자의 부호를 반전하고, 숫자 타입으로 변환하여 나타내준다.

##### 중요한점은 변수의 값을 바꾸는 것이 아닌 새로운 값을 생성해 반환한다.

```js
let x = '-10'
console.log(-(x)); // output 10

1 + true = 2
```

---

#### 암묵적 타입 변환, 타입 강제 변환

##### 위 예제에서 주목할 것은, 개발자의 의도와는 상관 없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다는 것이다. 1 + true를 연산하면 자바스크립트 엔진은 암묵적으로 불리언 타입의 값인 true를 숫자 타입인 1로 타입 강제 변환 후 연산을 수행한다.

---

<h4 style = "color:lightsalmon">연쇄할당</h4>

```js
let a, b, c;

a = b = c = 0;

console.log(a, b, c); // output : 0 0 0
```

##### 할당연산자(=)는 값으로 평가되지 않을 것처럼 보이지만, 할당문 또한 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가한다. 따라서 위의 예제와 같이 할당문을 다른 변수에 할당할 수도 있다.

##### 위의 연쇄 할당은 오른쪽에서 왼쪽으로 할당하는 할당연산자의 특징을 통해 동일 값을 할당한 것이다.

> 서두에서 서술한 **피연산자와 연산자의 조합**으로 이뤄진 **연산자 표현식**도 값으로 평가될 수 있는 표현식을 기억하자.

---

<h4 style = "color:lightsalmon">비교연산자</h4>

동등 비교 연산자 ( == )는 예측하기 어려운 결과를 만들어내므로 사용을 지양하고 대신 일치 비교 연산자 ( === )를 사용한다.
일치 비교 연산자는 타입과 값을 모두 비교하는데, 주의할 점은 NaN이다.

```js
NaN === NaN; // false
Number.isNaN(1 + undefined); // true
Number.isNaN(10); // false
```

##### NaN은 자신과 일치하지 않는 유일한 값이다.따라서 숫자가 NaN인지 확인하려면 Number.isNaN을 사용한다.

##### 또한 자바스크립트에서는 양의 0과 음의 0이 있는데, 비교하면 true를 반환한다.

```js
0 === -0; // true
(0 ==
  -0 - // true
    0) ===
  +0; // true
Object.is(-0, +0); // false
```

---

<h4 style = "color:lightsalmon">삼항연산자와 if ...else문의 차이</h4>

> 삼항 조건 연산자의 첫 번째 피연산자는 조건식이므로 삼항 조건 연산자 표현식은 조건문이다. 하지만 삼항 조건 연산자 표현식은 if ...else 문과 중요한 차이가 있는데, 삼항 조건 연산자 표현식은 값처럼 사용할 수 있지만, if ...else문은 표현식이 아니기 때문에 값처럼 사용할 수 없다.

```js
let x = 10;
let result = if(x % 2) //{ condition statement }
// output : SyntaxError : Unexpected token if

let y = 10;
let result = y % 2 ? '홀수' : '짝수' ;
console.log(result) // output : 짝수
```

###### 조건에 따라 값을 결정해야 한다면. if ...else문보다 삼항 조건 연산자 표현식을 사용하는 편이 유리하다. ( 그래서 JSX에 if ...else문이 들어가는 것을 지양하는구나!)

---

<h4 style = "color:lightsalmon">논리연산자</h4>

논리연산자는 우항과 좌항의 피연산자를 논리 연산한다.
**부정 논리 연산자**의 경우 **우항의 피연산자**를 논리 연산한다.

<table>
  <tr>
    <td>논리연산자</td><td colspan=2>의미</td>
  </tr>
    <tr>
    <td> ||</td><td>논리합(OR)</td><td>평가된 값이 boolean값이 아닐 수도 있다.<br />2개의 피 연산자 중 어느 한쪽으로 평가된다.</td>
  </tr>
    <tr>
      <td>&&</td><td>논리곱(AND)</td><td>평가된 값이 boolean값이 아닐 수도 있다.<br />2개의 피 연산자 중 어느 한쪽으로 평가된다.</td>
  </tr>
    <tr>
      <td>!</td><td>부정(NOT)</td><td>논리부정연산자는 항상 boolean값을 반환한다.<br/>피연산자가 불리언 값이 아니라면 암묵적 타입 변환을 실시한다.</td>
  </tr>
</table>

#### 드모르간의 법칙

- 논리 연산자로 구성된 복잡한 표현식은 가독성이 좋지 않다.
- 이러한 경우 드 모르간의 법칙을 활용하면 복잡한 표현식을 가독성 좋은 표현식으로 변환할 수 있다.

```js
!(x || y) === (!x && !y);
!(x && y) === (!x || !y);
```

###### !는 부정연산자다. 모든걸 부정(반대)하는 연산자로 생각한다면 조금 더 쉽게 생각할 수 있겠다. &&(논리곱)의 반대는 ||(논리합) x , y 도 부정하여 !x ,!y, &&는 ||로, ||은 &&으로.

---

<h4 style = "color:lightsalmon">쉼표연산자</h4>

```js
let x, y, z;
(x = 1), (y = 2), (z = 3); // 3이 출력된다. 그렇다고 x,y의 값이 3인 것은 아니다.
```
