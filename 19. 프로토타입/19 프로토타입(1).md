# 19. 프로토타입(2)

생성일: 2022년 3월 11일 오전 7:52

## 19. 10 instanceof 연산자

- 이항연산자로서, 좌변에 객체를 가리키는 식별자 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다.
- 우변의 생성자함수의 prototype에 바인딩 된 객체가 좌변의 객체의 프로토타입 체인상 존재하면 true로 평가되고, 그렇지 않으면 false로 평가된다.

```jsx
객체 instanceof 생성자함수
```

```jsx
// 생성자 함수
function Person(name){
	this.name = name;
}
const me = new Person('Lee');

console.log(me instatnceof Person);  // true
console.log(me instatnceof Object);  // true
```

## 19. 11 직접 상속

### 19. 11. 1 Object.create에 의한 직접 상속

- Object.create의 첫번째 매개변수에는 프로토타입으로 지정할 객체를 전달한다.
- 두번재 매개변수에는 생성할 객체의 프로퍼티 키와 프로퍼티 디스크립터 객체로 이루어진 객체를 전달한다. 두번째 인수는 옵션이다
- new 연산자 없이 객체를 생성 할 수 있다
- 프로토타입을 지정하면서 객체를 생성할 수 있다
- 객체 리터럴ㄹ에 의해 생성된 객체도 상속 받을 수 있다

```jsx
// 프로토타입이 null인 객체를 생성한다.
// obj -> null
let obj = Object.create(null);
console.log(Object.getPrototypeOf(obj) === null); // true
console.log(obj.toString());  // TypeError (Object를 상속받지 못한다.)

obj = Object.create(Object.prototype);
console.log(Object.getPrototypeOf(obj) === Object.prototype);  // true

obj = Object.create(Object.prototype, {
	x: {value: 1, writable: true, enumerable: true, configurable: true}
});
// 위 코드는 아래와 동일하다
// obj = {};
// obj.x = 1;
console.log(obj.x);  // 1
console.log(Object.getPrototypeOf(obj) === Object.prototype);  // true

const myProto = {x:10};
obj = Object.create(myProto);
console.log(obj.x);  // 10
console.log(Object.getPrototypeOf(obj) === myProto);  // true

// 생성자 함수
function Person(name){
	this.name = name;
}

obj = Object.create(Person.prototype);
obj.name = 'Lee';
console.log(obj.name);  // Lee
console.log(Object.getPrototypeOf(obj) === Person.prototype);  // true
```

- 프로토타입의 종점에 위치하는 객체는 Object.prototype의 빌트인 메서드를 사용할 수 없다.

```jsx
const obj = Object.create(null);
obj.a = 1;

console.log(Object.getPropertyOf(obj) === null);  // true
console.log(obj.hasOwnProperty('a'));  // TypeError
```

### 19. 11. 2 객체 리터럴 내부에서  __*proto*__ 에 의한 직접 상속

```jsx
const myProto = : {x : 10};

// 객체 리터럴에 의해 객체를 생성하며 프로토타입을 지정해서 직접 상속 받을 수 있다.
const obj = {
	y: 20,
	__proto__ : myProto
};

console.log(obj.x, obj.y);  // 10 20
console.log(Object.getPrototypeOf(obj) === myProto);  // true
```

## 19. 12 정적 프로퍼티 / 메서드

- 정적 프로퍼티/메서드란 생성자 함수로 인스턴스를 생성하지 않아도 참조 / 호출 할 수 있는 프로퍼티/메서드를 말한다.
- 정적 프로퍼티/메서드는 인스턴스의 프로토타입 체인에 속한 객체의 프로퍼티/메서드가 아니기때문에 인스턴스로 접근할 수 없다.

```jsx
// 생성자 함수
function Person(name){
	this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHello = function(){
	console.log(`Hi! My name is ${this.name}`);
};

// 정적 프로퍼티
Person.stataicProp = 'static prop';

// 정적 메서드
Person.staticMethod = function(){
	console.log('staticMethod');
};

const me = new Person('Lee');

// 생성자 함수에 추가한 정적 프로퍼티 / 메서드는 생성자 함수로 참조 / 호출한다.
Person.staticMethod();  // staticMethod

// 정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로 참조 / 호출 할 수 없다.
me.staticMethod();  // TypeError

```

![Untitled](19%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%90%202a0ee/Untitled.png)

## 19. 13 프로퍼티 존재 확인

### 19. 13. 1 in 연산자

- in 연산자는 객체 내에 특정 프로퍼티가 존재하는지 여부를 확인한다.
- in 연산자는 대상 객체가 상속받는 모든 프로토타입의 프로퍼티를 확인한다.
- Reflect.has 메서드는 in 연산자와 동일하게 동작한다.

```jsx
const Person = {
	name: 'Lee',
	address: 'Seoul'
};

console.log('name' in person);  // true
console.log('address' in person);  // true
console.log('age' in person);  // false

// in 연산자는 대상 객체가 상속받는 모든 프로토타입의 프로퍼티를 확인한다.
console.log('toString' in person);  // true
```

### 19. 13. 2 Object.prototype.hasOwnProperty 메서드

- 해당 객체에 특정 프로퍼티가 존재하는 지 확인한다
- 하지만 객체 고유의 프로퍼티 키인 경우에만 true를 반환하고 상속 받은 프로토타입의 프로퍼티 키인 경우 false를 반환한다.

```jsx
console.log(person.hasOwnProperty('name'));  // true
console.log(persoin.hasOwnProperty('age'));  // false
```

## 19. 14 프로퍼티 열거

### 19. 14. 1 for...in문

- 객체의 프로퍼티 개수만큼 순회
- 해당 객체 프로퍼티 뿐만 아니라 상속받은 프로토타입의 프로퍼티도 열거한다.
- for in문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 true인 프로퍼티를 순회하며 열거한다.
- for...in문은 프로퍼티키가 심벌인 프로퍼티는 열거하지 않는다.

### 19. 14. 2 Object.keys/values/entries 메서드

- Object.keys 메서드는 객체 자신의 열거가능한 프로퍼티 키를 배열로 반환한다.
- Object.values 메서드는 객체 자신의 열거 가능한 프로퍼티 값을 배열로 반환한다.
- Object.entries 메서드는 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환한다.