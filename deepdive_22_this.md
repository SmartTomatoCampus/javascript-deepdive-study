# 발표문 - 22장 this

# 초생님

1. this는 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 자기참조 변수이다.
2. this 바인딩은 함수호출방식에 따라 동적으로 결정된다.(일반함수 호출, 메서드 호출, 생성자함수 호출)
3. 기본적으로 this에는 전역객체가 바인딩된다. 하지만 메서드 내에서 정의한 중첩함수도 일반함수로 호출되면 this에는 전역객체가 바인딩된다.
4. 메서드 호출로 함수 호출시에는 해당 메서드를 호출한 객체에 바인딩된다.
5. call/bind 메서드 호출 시 첫번째 인수로 전달한 객체를 호출한 함수의 this에 바인딩한다.

# 명성님

### 디스바인딩이 함수호출에 따라 변경되는 방식

1. 함수는 호출되는 방식이 4가지가 있습니다.
2. 일반함수, 메서드, 생성자함수를 통한 호출, 메서드를 통한 간접 호출
3. 이 호출되는 방식에 따라 this는 가리키는 객체가 달라지게 됩니다.
4. this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 참조변수 입니다.
5. 객체 내부의 메서드는 함수 객체를 가리키고 있을 뿐이지, 객체에 포함된 것이 아니라 독립적으로 존재하는 별도의 객체다.
6. 메서드는 다른 객체의 프로퍼티에 할당하는 것도 가능하다.
7. 일반 변수에 할당하여 일반 함수로도 호출될 수도 있다.

```jsx
function seekOfCigarettePrice(HPF,VAT){
  return this.price + this.consumptiontax + HPF + VAT;
}

const thisOriginal = { price: 800,consumptiontax: 1600 };
const thisPlus = { price : 800, consumptiontax:1600 };

console.log(seekOfCigarettePrice.apply(thisOriginal,[1100,500])); // 4000
console.log(seekOfCigarettePrice.call(thisPlus,1100,600)); // 4100
```

# 꽁치님

1. this 는 자신이 생성한 객체나 생성할 인스턴스의 가리키는 자기 참조 변수이고, 때문에 아직 생성되지도 않은 인스턴스의 메서드나 프로퍼티를 참조할 수 있다!!
2. 이전에 패캠 강의에서 this 는 자신을 호출한 녀석이 this 라고 했는데 이제 이해가 간다
    1. 객체 리터럴 내부 메서드의 this 는 객체가 부르는 애이므로 this 는 바로 메서드가 속한 객체
    2. 생성자 함수에서 this 는 생성되고 난 후 인스턴스가 써먹을 this 이므로 인스턴스를 가리키고
    3. 일반 함수는 전역에서 호출되므로(보통은?), this 는 window 이다.
3. 객체 내부 중첩함수에서 this 를 바인딩하는 방법
    1. 원하는 객체를 가리키는 this 를 변수 that 에 할당
    2. Function.prototype.apply/bind/call 메서드를 써서 바인딩
    3. 화살표함수를 사용

# 너두님

### 알게된것

- strict mode에서 undefined를 가리킨다는것
- 함수 내부의 함수는 this가 전역객체를 가리킨다는것
- 왜 클래스에서 bind를 적극 활용했는지 알게됨

# 뽀또님

- this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 객체를 생성하지 않는 일반 함수에서 this는 의미가 없다.
- Function.prototype.apply/call/bind
    - apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달한다.
    - call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다.
    - bind 메서드는 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다.
