# 09. 타입 변환과 단출 평가 - 22.02.25

---

## 용어

🖊️명시적 타입 변환( 타입 캐스팅 ) : 개발자가 의도적으로 값의 타입을 변환하는 것

🖊️암묵적 타입 변환( 타입 강제 변환 ) : 자바스크립트 엔진에 의해 값의 타입이 변환

🖊️원시값 : 변경 불가능 한 값 ( immutable value)

🖊️단축 평가 : 표현식을 평가하는 도중 결과가 확정된 경우 나머지 평가 과정 생략하는 것

## 타입 변환이란?

자바스크립트의 모든 값은 타입이 있는데 개발자의 의도에 따라 다른 타입으로 변환 할 수 있음

기존의 원시값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것

⇒ 기본의 원시값을 직접 변경하는 ㄱ ㅓㅅ이 아님!

### 명시적타입변환

개발자가 의도적으로 타입 변환

```jsx
var x = 10;
//
var str = x.toString();
console.log(typeoof str, str); //string 10
//숫자를 문자열로 캐스팅한거지만! 값이 변경된건 아님
```

### 암묵적타입변환

개발자와의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진이 타입을 자동으로 변환 시키는 것

⇒ 표현식을 에러 없이 평가하기 위해 피연산자 값을 타입변환 후 새로운 값 만들어 한 번 쓰고 버림 

```jsx
var x = 10;

//문자열 연결 연산자는 x값을 바탕으로 새로운 문자열 생성
var str = x + '';
console.log(typeof str, str);

console.log(typeof x, x);
```

<aside>
📌 어떤 타입 변환만 써야한다! 이런 것은 아니다. 
동료들이 자신의 코드를 이해할 수 있도록 작성하자

</aside>

## 암묵적 타입 변환

### 문자열 타입으로 변환

자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 피연산자 중 문자열 타입이 아닌 것은 문자열 타입으로 암묵적 타입 변환함

```jsx
(Symbole()) // TypeError => Symbol은 캐스팅 안댐?
({}) + ''  //[Object Object]
Math + '' // [Object Math]
[] + '' //""
Array + '' //function Array(){[native code]}
```

**템플릿 리터럴**의 표현식 삽입은 표현식의 평가 결과를 **문자열 타입으로 암묵적 타입 변환**

```jsx
`1 + 1 = ${1 + 1} ` // "1+1 = 2" 
```

### 숫자타입으로 변환

**산술 연산자**의 모든 피연산자는 숫자 타입이어야 한다

자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자중 숫자 타입이 아닌 것을 암묵적 타입 변환한다

이 때 숫자타입으로 변환할 수 없는 것은 NaN을 리턴

```jsx
1 - '1' // 0
1/'one' //NaN
```

**비교연산자**도 마찬가지로 모든 피연산자는 숫자 타입이여야 한다

```jsx
'1' > 0 //true
```

**+단항 연산자**는 피연산자가 숫자 타입이 아니면 숫자 타입의 값으로 암묵적 타입변환을 한다

```jsx
+'' // 0
+'2' //2
+'string' //NaN

+true //1

+null //0

+undefined // ->NaN

+Symbol() //TypeError
```

### 불리언 타입으로 변환

자바스크립트 엔진은 조건식의 평가 결과를 **Truthy(참으로 평가 되는 값)** 또는 **Falsy( 거짓으로 평가되는 값)**으로 구분한다

제어문의 조건식과 같이 불리언 값으로 평가되야 할 문맥에서 Truthy 값은 true 로 Falsy 값은 false로 암묵적 타입 변환 된다

<aside>
📌 **falsy로 평가되는 값**
(false , undefined, null, 0, -0, NaN , ‘’빈문자열)

**이외의 값**은 모두 true로 평가되는 **Truthy 값**이다

</aside>

## 명시적 타입 변환

개발자의 의도에 따라 명시적으로 타입을 변경하는 것

생성자 함수 (String , Number, Boolean) 을 new 연산자 없이 호출

빌트인 메서드 사용

암묵적 타입 변환 

을 이용하여 타입 변환을 한다 

### 문자열 타입으로 변환

> **String 생성자 함수**를 new 연산자 없이 호출
Object.prototype**.toString** 메서드 사용
**문자열 연결 연산자** 사용
> 

```jsx
1. String new 없이 호출
	String(1); //"1"
	String(NaN); //NaN
	String(true); //true

2. Object.prototype.toString 메서드 사용
(1).toString() ; //"1"
(NaN).toString(); //NaN

3. 문자열 연결 연산자 이용
1 + '' ; // "1"
NaN + '' ; //NaN
```

### 숫자 타입으로 변환

> **Number 생성자 함수**를 new 없이 호출
**parseInt parseFloat 함수**를 사용 ( 문자열만 숫자 타입으로 변환 가능)
**+** 단항 산술 연산자 이용
***** 산술 연산자 이용
> 

```jsx
1. Number 생성자 함수
Number('0'); //0
Number(true); // 1

2. parseInt / parseFloat 함수 사용
	 문자열 => 숫자
parseInt('0') //0
parseFlaot('10.12') //10.12

3. +단항 산술 연산자
+'0' // 0
+'10.53' //10.53

4. *단항 산술 연산자
'0' * 1 // 0
'-1' * 1 ; //-1
true * 1 // 1
false * 1 //0
```

### 불리언 타입으로 변환

> Boolean 생성자 함수를 new 연산자 없이 호출
! 부정 논리 연산주 두번 사용
> 

```jsx
1. Boolean 생성자 함수
==문자열 -> 불리언
Boolean('false'); //true
Boolean('') // false

==숫자 -> 불리언
Boolean(0) // fasle;
Boolean(NaN) //false
Boolean(Infinity) //true

2. !부정 논리 연산자 두번
!!'x' //true
!!'false' //true
!!'' //false

!!0 //false
!!NaN //true

!!null //false

!!undefinee // flase

!!{} //true
!![] //true
```

## 단축평가

표현식 평가 도중에 결과가 확정된 경우 나머지 평가 과정 생략

### 논리 연산자 이용 단축 평가

논리  연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환

**논리곱 연산자 ( &&)** 

피연산자 모두 true로 평가 될 때 논리 연산의 결과를 결정하는 **두 번째 피연산자 반환**

좌항에서 우항으로 평가가 진행

```jsx
'Cat' && 'Dog' //Dog
둘다 Truthy한 값이므로 true => 두번째 피연산자인 'Dog' 리턴
```

**논리합 연산자 ( || )**

두 개의 피 연산자 중 하나만 true 로 되어도 결과를 반환

논리 연산의 첫번째 피연산자를 반환한다 

```jsx
'Cat' || 'Dog' //Cat
둘다 Truthy한 값이므로 true => 첫번째 피연산자인 'Cat' 리턴
```

| 단축 평가 표현식 | 평가 결과 |
| --- | --- |
| true ||  anything | true |
| false ||  anything | anyting |
| true &&  anything | anything |
| false &&  anything | false |

### if문 대체 가능

**어떤 값이 Truthy 값일 때** **논리곱 연산자**로 대체

```jsx
var done = true;
var message = '';

//done이 true일때 메세지에 '완료' 할당
if( done) message = '완료';
를 바꾸면 

message = done&&'완료';
```

**어떤 값이 Falsy 값일 때 논리합 연산자**로 대체

```jsx
var done = true;
var message = '';

//done이 fasle일때 메세지에 '완료' 할당
if( !done) message = '미완료';
를 바꾸면 

message = done || '미완료';
```

### 객체를 가리키기를 기대하는  변수가 null또는 undefined인지 확인

객체를 가리키기 기대하는 변수의 값이 객체가 아니라 null or undefined 인 경우 TypeError 발생

```jsx
var elem = null;
var value = elem.value ; //TypeError
```

단축 평가를 사용하면 에러가 안 난다

```jsx
var elem = null;
var value = elem && elem.value ; //null
```

> 2022-02-25 TIL
1. 템플릿 리터럴 표현식 삽입도 문자열 암묵적 타입 변환된다 
` 1 + 1 = ${1+1}` ⇒ 1+1=2라는 문자열로 타입 변환
2. Truthy한 값과 Falsy한 값
    조건식의 결과는 Truthy, Falsy한 값으로 타입 변환이 된다.
    Falsy 한 값에는 false , undefinde, null, 0, NaN, ‘’가 있다
    위의 Falsy한 값 이외에는 Truthy한 값이다 
3. 단축합 연산자는 결과를 타입 변환하지 않고 그대로 반환한다
    논리곱은 논리 연산 결과를 결정하는 두번째를, 논리합은 논리 연산 결과를 결정하는 첫번째를 리턴한다
>