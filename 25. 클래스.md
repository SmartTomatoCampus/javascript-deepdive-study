# 25. 클래스 - 22.03.21

---

## 용어

---

---

## 클래스는 뭘..까...?

자바스크립트는 프로토타입기반 객체지향 언어다.  프로토타입 기반 객체지향 언어는 클래스가 필요없는 객체지향 프로그래밍 언어다.

ES5 에서는 클래스 없이도 다음과 같이 생성자 함수와 프로토타입을 통해 객체지향 언어의 상속을 구현할 수 있다. 

```jsx
var person = ( function() {
		function Person (name) {
			this.name = name;
		}
	Person.prototype.sayHi = function () {
		console.log(this.name + '님 hi');
	};
	return Person();	
)());

var me = new Person('lee');
me.sayHi(); //lee님 hi
```

하지만 이런 프로토타입 기반은 개발자에게 혼란을 가져왔다. 

프로그래머가 더욱 빠르게 학습할 수 있도록 클래스 기반 객체지향 프로그래밍 언어와 **흡사한 객체 생성매커니즘**을 제시한다.

새롭게 클래스 기반 객체지향 모델을 제공하는 것이 아닌,  클래스는 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있는 문법적 설탕을 제시한다.

<aside>
💡 클래스는 생성자 함수와 매우 유사하게 동작하지만 다음과 같은 차이가 있다.

| 구분 | 클래스 | 생성자 함수 |
| --- | --- | --- |
| new 연산자 | new 연산자 없이 호출하면 에러 발생 | new 연산자 없이 호출하면 일반 함수로서 호출됨 |
| 상속지원 | extends와 super 키워드 제공 | extends와 super 키워드 제공X |
| 호이스팅 | 클래스는 호이스팅이 발생하지 않는 것 처럼 동작 | 함수 선언문에는 함수 호이스팅
함수 표현식에는 변수 호이스팅 |
| strict mode | 암묵적으로 strict mode로 지정되며 해제할 수 없다 | 암묵적으로 strict mode가 지정되지 않는다 |
| 어트리뷰트 | 클래스의 constructor 
프로토타임 메서드 , 정적 메서드는 모두 [[Enumerable]] 이 false 이다.  |  |
</aside>

생성자 함수와 클래스는 프로토타입 기반의 객체지향이라느 점에서 유사하지만 클래스는 생성자 함수 기반의 객체 생성 방식보다 견고하고 명료하다.

**따라서 클래스를 새로운 객체 생성 매커니즘이라고 보는 거이 좀 더 합당하다.**

## 클래스 정의

클래스는 class 키워드를 사용하여 정의하며 클래스 이름은 파스칼 케이스를 따르는 것이 일반적이다.

```jsx
class Person{}
```

함수와 마찬가지로 표현식으로 클래스를 정의할 수도 있다. 

함수와 마찬가지로 이름을 가질수도, 안 가질 수도 있다.

```jsx
const Person = class{};
const Person = class Myclass{};
```

클래스를 표현식으로 정의할 수 있다는 것은 클래스가 값으로 사용될 수 있는 일급 객체임을 의미한다.

<aside>
💡 **클래스는 일급 객체**로서 다음과 같은 특징을 갖는다
1. 무명의 리터럴로 생성 가능 (런타임에 생성 가능)
2. 변수나 자료구조에 저장 가능
3. 함수 매개변수에 전달 가능
4. 함수 반환 값으로 사용 가능

</aside>

클래스에는 0개 이상의 메서드만 정의할 수 있으며, 생성자, 프로토타입 메서드, 정적 메서드로 구현이 가능하다

```jsx
class Person {
//생성자
	constructor(name) {
	//인스턴스 생성 및 초기화
		this.name = name; //name 프로퍼티는 public 이다
	}
	sayHi() {
		console.log(${this.name});
	}
	sayHello() {
		console.log('Hello!');
	}
}
const me = new Person('lee');

console.log(me.name);

me.sayHi(); //lee
Person.sayHello(); //Hello!
```

클래스와 생성자 함수의 정의 방식을 비교해보면 다음과 같다.

![Untitled](https://github.com/sTIL-us/javascript-deepdive-study/blob/e3cf78ab1481e0f51de9d25be54b3b3e53de0818/25.%20%ED%81%B4%EB%9E%98%EC%8A%A4/Untitled.png)

클래스와 생성자 함수의 정의 방식은 거의 유사하다. 

## 클래스 호이스팅

클래스는 함수로 평가된다.

```jsx
class Person {}
console.log(typeof Person); //function
```

클래스 선언문으로 정의한 클래스는 함수 선언문과 같이런타임 이전에 평가되어 함수 객체를 생성한다.

클래스가 평가되어 생성된 함수 객체는  생성자 함수인 constructor 함수 정의가 평가되어 함수 객체를 생성할 시점에 프로토타입도 생성된다. 프로토 타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재하기 때문이다.

**단, 클래스는 클래스 정의 이전에 참조할 수 없다.**

```jsx
console.log(Person); //referenceError

class Person {}
```

클래스는 호이스팅이 발생하지 않는 것 처럼 보인다.

```jsx
const Person = '';
{
 console.log(Person); //referenceError
 class Person {}
}
```

클래스 선언문은 let, const 키워드로 선언한 변수처럼 호이스팅된다. 클래스 선언문 이전에 일시적 사각지대에 빠지기 때문에 호이스팅이 없는 것 처럼 보인다.

<aside>
💡 모든 선언문은 런타임 이전에 먼저 실행되기 때문에
var, let, const, function, class 키워드 식별자는 호이스팅된다.

</aside>

## 인스턴스 생성

클래스는 new 연산자와 함께 호출되어 인스턴스를 생성한다.

```jsx
class Person{}

const me = new Person();
console.log(me); //Person{}
```

클래스는 반드시 new 연산자와 함께 호출되어야 한다.

```jsx
class Person{}

const me =  Person();
//TypeError

```

클래스는 식별자를 사용해 인스턴스를 생성하지 않고 기명 클래스 표현식의 클래스 이름을 사용해 인스턴스를 생성하면 에러가 난다.

```jsx
const Person  = class MyClass{};
//식별자로 인스턴스를 생성해야 한다.
const me = new Person();

console.log(MyClass);
//기명 클래스 포현식의 클래스 이름으로 생성하면 에러남
cont yout = new MyClass(); //ReferenceError
```

## 메서드

클래스에서는 생성자, 프로토타입 메서드, 정적 메서드를 정의할 수 있다.

### constructor

인스턴스를 생성하고 초기화하기 위한 특수한 메서드이며 이름을 변경할 수 없다.

```jsx
class Person {
	constructor(name) {
		this.name = name;
	}
}
```

클래스도 평가됨과 동시에 함수 객체가 되어 함수 객체 고유의 프로퍼티를 모두 가지고 있다. 함수와 동일하게 프로토타입과 연결되어 있고 자신의 스코프를 구성한다.

모든 함수가 객체가 가지고 있는 prototype프로퍼티가 가리키는 constructor 프로퍼티는 클래스 자신을 가리키고 있다. 이는 클래스가 인스턴스를 생성하는 생성자 함수라는 것을 의미한다. 

**즉 new 연산자와 함께 클래스 호출하면 클래스는 인스턴스를 생성한다.**

```jsx
class Person {
	constructor(name) {
		this.name = name;
	}
}

const me = new Person('lee');
console.log(me);
```

콘솔에 인스턴스를 찍어보면 name 프로퍼티가 인스턴스의 프로퍼티로 추가된 것을 볼 수 있다.

![Untitled](https://github.com/sTIL-us/javascript-deepdive-study/blob/e3cf78ab1481e0f51de9d25be54b3b3e53de0818/25.%20%ED%81%B4%EB%9E%98%EC%8A%A4/Untitled%201.png)

생성자 함수와 마찬가지로 consturtor 내부에서 this에 추가한 프로퍼티는 인스턴스 프로퍼티가 된다.  

constuctor 내부의 this는 생성자 함수와 마찬가지로 인스턴스를 가리킨다. 

```jsx
class Person {
//생성자
	constructor(name) {
//인스턴스 밑 초기화
		this.name = name;
	}
}

function Person(name) {
	//인스턴스 생성 및 초기화
	this.name = name;
}
```

그런데 우리는 클래스가 생성한 인스턴스나 함수 객체에서 consturctor 메서드가 보이지 않는 것을 알 수 있다. 

<aside>
💡 **constructor는 메서드로 해석되는 것이 아니라 클래스로 평가되어 생성한 함수 객체 코드의 일부가 된다.** 
클래스의 constructor와 프로퍼티의 constructor는 같은게 아니다. 프로토타입 constructor는 모든 프로토타입이 가지고 있고, 생성자 함수를 가리키는 것을 상기시켜보자

</aside>

```jsx
const me = new Person(
	constructor(){
		this.name="Lee"
	}
)
```

이렇게 선언을 해야하는데 우리는 constructor() 이거 없이 쓰는 걸 의미함 `class Person{ constructor(  ){  }}` 가 하나의 틀이 되나봄

**constructor와 생성자 함수의 차이점**

1.  constructor는 클래스 내에 최대 한 개만 존재할 수 있다. 
2. constructor는 생략 가능
3. constructor를 생략하면 빈 constructor가 암묵적으로 정의된다.
4. 인스턴스를 생성할 때 클래스 외부에서 인스턴스 프로퍼티 초기값을 전달하려면 constructor 매개변수를 선언하고 인스턴스를 생성할 때 초기값을 전달한다.
5. 별도의 반환문을 가지면 안된다. this를 자동으로 반환하기 때문.
    
     다른 거 반환하면 return 문에 명시된 객체가 반환되는데 원시값 반환하면 무시됨
    

### 프로토타입 메서드

생성자 함수를 사용하여 인스턴스를 생성하는 경우 프로토타입 메서드를 생성하기 위해서는 프로토타입에 메서드를 추가해야한다. 

```jsx
function Person(name) {
	//인스턴스 생성 및 초기화
	this.name = name;
}
Person.prototype.sayHi = function () {
	console.log(${this.name});
};

const me = new Person('lee');
me.sayHi();
```

클래스 몸체에 정의한 메서드는 그냥 기본적으로 프로토타입 메서드가 된다.

```jsx
class Person {
//생성자
	constructor(name) {
	//인스턴스 생성 및 초기화
		this.name = name; //name 프로퍼티는 public 이다
	}
	sayHi() {
		console.log(${this.name});
	}

}
const me = new Person('lee');

console.log(me.name);
me.sayHi(); //lee

```

```jsx
1. me 객체의 프로토타입은 Person.prototype 인가?
Object.getPrototypeOf(me) === PErson.prototype; //true

2. Person.prototype의 프로토타입은 Object.prototype 인가?
Object.getPrototypeOg(Person.prototype) === Object.prototype; //true

3. me 객체의 constructor는 Person 클래스인가?
me.constructor === Person ; //true
```

Person 클래스는 프로토타입 체인을 생성한다.

![Untitled](https://github.com/sTIL-us/javascript-deepdive-study/blob/e3cf78ab1481e0f51de9d25be54b3b3e53de0818/25.%20%ED%81%B4%EB%9E%98%EC%8A%A4/Untitled%202.png)

**클래스 몸체에서 정의한 메서드는 인스턴스의 프로토타입에 존재하는 프로토타입 메서드**가 된다. 인스턴스는 프로토타입 메서드를 상속받아 사용하는 것이다.

결국 클래스는 생성자함수와 같이 인스턴스를 생성하는 생성자 함수이다. 

### 정적 메서드

정적 메서드는 인스턴스를 생성하지 않아도 호출할 수 있는 메서드를 말한다.

생성자 함수의 경우 정적 메서드를 생성하기 위해 명시적으로 생성자 함수에 머스드를 추가해야한다.

```jsx
function Person(name) {
	//인스턴스 생성 및 초기화
	this.name = name;
}
Person.sayHi = function () {
	console.log(${this.name});
};

Person.sayHi(); //Hi
```

근데 클래스에서는 static 키워드만 붙이면 정적 메서드가 된다. 

```jsx
class Person {
//생성자
	constructor(name) {
	//인스턴스 생성 및 초기화
		this.name = name; //name 프로퍼티는 public 이다
	}
	static sayHi() {
		console.log(${this.name});
	}
}

```

![Untitled](https://github.com/sTIL-us/javascript-deepdive-study/blob/e3cf78ab1481e0f51de9d25be54b3b3e53de0818/25.%20%ED%81%B4%EB%9E%98%EC%8A%A4/Untitled%2013.png)

정적 메서드는 클래스에 바인딩된 메서드가 된다. 클래스는 함수 객체로 평가되므로 자신의 프로퍼티 , 메서드를 소유할 수 있다. 클래스는 클래스 정의되는 시점에 함수 객체가 되므로 인스턴스와 달리 별다른 생성 과정이 필요 없다. 프로포타입 메서드 처럼 그냥 클래스로 호출하면 된다.

**정적 메서드는 클래스 정의 이후 인스턴스를 생성하지 않아도 호출할 수 있다.**

정적 메서드는 인스턴스로 호출할 수 없다. 정적 메서드는 프로토타입 체인상에 존재하지 않기 때문이다. 

### 정적 메서드와 프로토타입 메서드의 차이

1. 정적 메서드와 프로토타입 메서드는 자신이 속해 있는 프로토타입 체인이 다르다
2. 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다
3. 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다. 

```jsx
class Square {
	static area(width, height) {
		return width * height;
 }
}
console.log(Square.area(10,10)); //100
```

정적 메서드 area는 인스턴스 프로퍼티를 참조하지 않는다. 

인스턴스 프로퍼티를 참조해야한다면 프로토타입 메서드를 사용해야한다. 

```jsx
class Square {
	consructor(width, height){
	this.width = width;
	this.height = height;
	}
	area() {
		return this.width * this.height;
 }
}

const square = new Square(10, 10);
console.log(square.area());
```

클래스 또는 생성자 함수를 하나의 네임스페이스로 사용하여 정적 메서드를 모아 놓으면 이름 충돌 가능서을 줄여주고 관련 함수들을 구조할 수 있는 효과가 있다.

정적 메서드는 애플리케이션 전역에서 사용할 유틸리티 함수를 전역 함수를 정의하지 않고 메서드를 구조화할 때 유용하다. 

### 클래스에서 정의한 메서드의 특징

1. function 키워드를 생략한 메서드 축약 표현 사용
2. 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마 필요 없음
3. 암묵적으로 strict mode가 실행된다.
4. for...in Object.keys 같은 메서드로 열거 할수 없다.
5. 내부 메서드 [[Constructor]]를 갖지 않는 non-constructor이므로 new 연산자와 함께 호출할 수 없다. 

> **2022-03-21 TIL**
1.   클래스는 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있는 방법중 하나임
2. 클래스 선언문으로 정의한 클래스는 런타임 이전에 평가되어 함수 객체를 생성한다.
3. 호이스팅은 let, const 같이 되서 안되는 것 처럼 보임
4. 클래스 constructor메서드는 메서드가 아닌 클래스의 코드 일부가 됨
5. 클래스에 그냥 정의한 메서드는 자동으로 프로토타입 기반 메서드가 되어 인스턴스가 상속받아서 쓴다. 
6. 메서드 앞에 static을 붙이면 클래스에 바인딩된 메서드가 되어  인스턴스에서 접근이 불가하고 클래스를 통해서만 접근 할 수 있다.
> 

## 클래스의 인스턴스 생성 과정

new 연산자와 함께 클래스를 호출하면 생성자 함수와 마찬가지로 클래스 내부 메서브 [[Consturct]]가 호출된다. 

### 인스턴스 생성과 this바인딩

new  연산자와 함께 클래스를 호출하면 constructor 내부 코드가 실행되기에 앞서 빈 객체의 인스턴스를 생성한다.

이때 인스턴스의 프로토타입으로 클래스 프로토타입의 프로퍼티가 가리키는 객체로 지정된다.

그리고 인스턴스는 this에 바인딩된다. 따라서 constructor 내부의 this는 클래스가 생성한 인스턴스를 가리킨다.

### 인스턴스 초기화

constructor의 내부 코드가 실행되어 this에 바인딩 되어 있는 인스턴스를 초기화한다.

this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고 constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티 값을 초기화한다.

### 인스턴스 반환

클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환

```jsx
class Person{
	//생성자
	consturctor(name) {
		//1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.
		console.log(this); //Person{}
		console.log(Object.getPrototypeOf(this) == Person.prototype); //true
		//2. this에 바인딩되어 있는 인스턴스를 초기화한다
		this.name = name;
		//3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환
	}
}
```

## 프로퍼티

### 인스턴스 프로퍼티

인스턴스 프로퍼티는 constructor 내부에서 정의해야 한다.

```jsx
class Person{
	//생성자
	consturctor(name) {
		this.name = name;
	}
}

const me = new Person('lee');
console.log(me); //Person { name : 'lee'}
```

consturctor 내부 코드가 실행되기 이전에 consturctor 내부의 this에는 이미 클래스가 암묵적으로 생성한 인스터인인 빈 객체가 바인딩되어 있다.

생성자 함수에서 생성자 함수가 생성할 인스턴스의 프로퍼티를 정의하는 것과 마찬가지로

consturctor 내부에서 this에 인스턴스 프로퍼티를 추가한다.

⇒ 클래스가 암묵적으로 빈 객체인 인스턴스에 프로퍼티를 추가하여 인스턴스를 초기화한다.

```jsx
class Person{
	//생성자
	consturctor(name) {
		this.name = name;
	}
}

const me = new Person('lee');
console.log(me.name); //Person {'lee'}
```

다른 객체지향 언어처럼 접근 제한자를 지원하지 않는다. 인스턴스 프로퍼티는 언제나 public하다.

### 접근자 프로퍼티

접근자 프로퍼티는 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽어내거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티이다.

```jsx
class Person {
	firstName : 'soyeon',
	lastName L 'kim',

	get fullName() {
		return `${this.firstName} ${this.laastName}`);
	}
	set fullName(name){
		[this.firstName, this.lastName] = name.split(' ');
	}
};

console.log(`${this.firstName} ${this.laastName}`);

person.fullName = 'Haha Lee';
console.log(person);

console.log(person.fullName);
console.log(object.getOwnPropertyDescriptor(person, 'fullName'));
```

접근자 프로퍼티는 클래스에서도 사용할 수 있다. 

getter 와 setter 이름은 인스턴스 프로퍼티처럼 사용된다. getter는 호출하는 것이 아니라 프로퍼티 처럼 참조하는 형식으로 사용하며 참조 시에 내부적으로 getter가 호출된다.

setter도 호출하는 것이 아니라 그냥 할당하면 알아서 setter 호출된다.

getter 는 반드시 무언가를 반환해야하고 setter는 반드시 매개변수가 있어야한다. 

단, setter는 단 하나의 값만 할당받기 때문에 하나의 매개변수만을 선언할 수 있다.

클래스의 메서드는 기본적으로 프로토타입 메서드가 된다. 

**따라서 클래스 접근자 프로퍼티 또한 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티**

### 클래스 필드 정의 제안

클래스 필드란? 클래스가 생성할 인스턴스의 프로퍼티를 가리킨다.

자바스크립트의 클래스 몸체에는 메서드만 선언할 수 있다.

근데 자바스크립트에서도 인스턴스 프로퍼티를 마치 클래스 기반 객체지향 언어의 클래스 필드처럼 정의할 수 있게 제안되어 있다. (2021.01 기준)

최신 브라우저와 최신 Node,js에서는 다음 예제와 같이 클래스 필드를 클래스 몸체에 정의할 수 있다.

```jsx
class Person {
name = 'lee';
}
const me = new Person();
console.log(me); //person{name : 'lee'}
```

**this 바인딩 X**

클래스 몸체에서 클래스 필드를 정의하는 경우 this에 클래스 필드를 바인딩해서는 안된다. this는 클래스의 consturctor와 메서드 내에서만 유효하기 때문이다.

클래스 필드를 참조하는 경우 this를 통해서 참조해야한다. 

**초기값을 할당하지 않으면 undefined**

클래스 필드에 초기값을 할당하지 않으면 undefined를 갖는다.

```jsx
class Person {
name;
}
const me = new Person();
console.log(me); //Person { name : undefined}
```

**클래스 필드 초기화는 constructor 안에서**

인스턴스를 생성할 때 외부의 초기값으로 클래스 필드를 초기화해야할 필요가 있다면 constructor에서 클래스 필드를 초기화 해야한다. 

```jsx
class Person {
	name;
		consturctor(name) {
		//클래스 필드 초기화
		this.name = name;
	}
}
const me = new Person();
console.log(me); //Person { name : 'lee'}
```

위의 코드에서 보이다 싶이 인스턴스를 생성할 때 클래스 필드를 초기화할 필요가 있다면 굳이 클래스 필드에서 정의할 필요가 없다. 

**필드를 통해 메서드를 정의할 수 있다**

함수는 일급 객체이므로 함수를 클래스 필드에 할당할수 있다. 클래스 필드를 통해 메서드 정의할 수 있다.

클래스 필드에 함수를 할당하는 경우 인스턴스 메서드가 된다.

<aside>
💡 **모든 클래스 필드는 인스턴스 프로퍼티가 되기 때문**

</aside>

그래서 클래스 필드에 화살표 함수를 할당하여 화살표 함수 내부의 this가 인스턴스를 가리키게 하는 경우도 있다. 하지만 이 경우 인스턴스를 여러개 생성하기 된다면 메모리 손해를 본다.

### private 필드 정의 제안

자바스크립트는 캡슐화를 완전하게 지원하지 않는다. 

클래스 필드 정의 제안을 사용하더라고 클래스 필드는 기본적으로 public이라 외부에 노출된다.

그래서 최신 브라우저와 node.js에서는 private 필드 선두에 #을 붙여 표현해준다.

```jsx
class Person{
	#name : '';
	consturcotr(name) {
		this.#name = name;
	}
}
const me = new Person('lee');
private 필드 #name은 클래스 외부에서 참조X
console.log(me.#name); //syntaxError 
```

<aside>
💡 **public vs private**

| 접근 가능성 |  public | private |
| --- | --- | --- |
| 클래스 내부 | O | O |
| 자식 클래스 내부 | O | X |
| 클래스 인스턴스를 통한 접근 | O | X |
</aside>

**접근자 프로퍼티를 통해 간접적으로 접근이 가능하다**

```jsx
class Person{
	#name : '';
	consturcotr(name) {
		this.#name = name;
	}
	get name() {
		return this.#name.trim();
	}
}
const me = new Person('lee');
console.log(me.name); //lee
```

## static 필드 정의 제안

Static class features가 새로 제안되어 static public / static private 필드는 최신 브라우저와 최신 Node.js에 이미 구현되어 있다.

```jsx
class MyMath { 
	static PI =3.14;
	static #num = 10;
	static increment() {
		return ++MyMath.#num;
	}
}
console.log(MyMath,PI);
console.log(MyMayh.increment());
```

> **2022-03-22 TIL** 
1. 인스턴스 생성 과정
new  연산자와 함께 클래스를 호출하면 constructor 내부 코드가 실행되기에 앞서 빈 객체의 인스턴스를 생성한다. 
인스턴스는 this에 바인딩 되기 때문에 constructor 내부의 this는 클래스가 생성한 인스턴스를 가리킨다. 
constructor의 내부 코드가 인스턴스를 초기화하여 인스턴스에 프로퍼티를 추가하고 파라미터값으로 프로퍼티를 초기화 한다. 
2.  프로퍼티는 인스턴트 프로퍼티가 있고 접근자 프로퍼티, 필드가 있다. 
3. 인스턴트 프로퍼티는 constructor 메서드 안에 정의한 프로퍼티이다.
4. 접근자 프로퍼티는 getter/ setter를 얘기함
5. 필드는 클래스 몸체에 선언된 프로퍼티이다. 
6. 근데 외부에서 값을 받아서 프로퍼티를 초기화 하다면 필드는 굳이 쓸 필요 없다.
7. private 같이 외부에서 접근 못하게 하려면 #을붙이면 된다 이때 클래스 외부에서는 접근이 불가하며 접근자 프로퍼티로 간접적으로 접근 가능하다.
> 

## 상속에 의한 클래스 확장

### 클래스 상속과 생성자 함수 상속

상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것이다.

여기서 생성자 함수와 차이가 있다. 클래스는 기존 클래스를 확장할 수 있는 문법인 `extends`가 제공된다. 하지만 생성자 함수는 기본 문법이 제공되지 않는다. 

### 상속의 예

예를 들어 동물을 추상화한 Animal 클래스와 새와 사자를 추상화한 Bird, Lion 클래스를 각각 정의한다고 하자. 새와 사자는 동물에 속하므로 동물의 속성을 갖지만, 본인 자신만의 고유한 속성을 갖기도 한다.

```jsx
class Animal {
	constructor(age, weight) {
		this.age = age;
		this.weight = weight;
	}
	eat() { return 'eat' };
	move() { return 'move'; }
}

class bird extends Animal {
fly() {retrurn 'fly';}
}

const bird = new Bird(1, 5);

console.log(bird.eat()); //eat
console.log(bird.move()); //move
console.log(bird.fly()); //fly
```

위의 코드와 같이 동물의 특성은 Animal 클래스에서 정의하고 Bird Lion 클래스는 상속을 통해 Animal 클래스의 속성을 받으면서 자신만의 고유한 속성을 추가하여 확장한다.

![Untitled](https://github.com/sTIL-us/javascript-deepdive-study/blob/e3cf78ab1481e0f51de9d25be54b3b3e53de0818/25.%20%ED%81%B4%EB%9E%98%EC%8A%A4/Untitled%204.png)

상속에 의한 확장된 클래스 Bird를 통해 생성된 인스턴스의 프로토타입 체인은 다음과 같다.

![Untitled](https://github.com/sTIL-us/javascript-deepdive-study/blob/e3cf78ab1481e0f51de9d25be54b3b3e53de0818/25.%20%ED%81%B4%EB%9E%98%EC%8A%A4/Untitled%205.png)

### extends 키워드

상속을 통해 클래스를 확장하면 extends 키워드를 사용하여 상속받을 클래스를 정의한다.

```jsx
class Base { }

class Derived extends Base{}
```

- 수퍼클래스 : 서브클래스에게 상속된 클래스를 수퍼 클래스라고 부른다. 혹은 베이스 클래스, 부모 클래스 라고 부르기도 한다.
- 서브 클래스 : 상속을 통해 확장된 클래스. 파생 클랫, 자식 클래스라고도 부른다.

<aside>
💡 **extends 키워드 역할**
수퍼 클래스와 서브클래스 간의 상속 관계를 설정

</aside>

![Untitled](https://github.com/sTIL-us/javascript-deepdive-study/blob/e3cf78ab1481e0f51de9d25be54b3b3e53de0818/25.%20%ED%81%B4%EB%9E%98%EC%8A%A4/Untitled%206.png)

수퍼 클래스와 서브 클래스는 인스턴스의 프로토타입 체인 뿐만 아니라 클래스 간의 프로토타입 체인도 생성한다. 이를 통해 프로토타입 메서드, 정적 메서드 모두 상속이 가능하다. 

### 동적 상속

extends 키워드는 클래스 뿐만 아니라 생성자 함수를 상속받아 클래스를 확장할 수 있다.

```jsx
function Base(a) {
 this.a = a;
}

class Derived extends Base {}

const derived = new Derived(1);
console.log(derieved); //Derived { a: 1}
```

extends 키워드 다음에는 클래스 뿐만 아니라 [[Constructor]] 내부 메서드를 갖는 표현식을 사용할 수 있다. 

이를 통해 동적으로 상속받을 대상을 결정한다.

```jsx
function Base1() {}

class Base2 {}

let condition = true;

class Derived extends (condition? Base1 : Base2) {}

const derived = new Derived();
console.log(derieved); //Derived {}
```

### 서브 클래스의 constructor

서브 클래스에서 construtor를 생략하면 클래스에 다음과 같은 constructor 가 암묵적으로 정의된다. 

```jsx
constructor( ...args) {
	super(...args);
}
//super() 로 부모 클래스의 constructor를 호출하여 인스턴스를 생성한다. 
```

그렇다면 부모와 자식 클래스 모두 constructor를 생략했을 땐 어떨까?

```jsx
class Base {}

class Derived extends Base {}
```

위 예제의 클래스에는 다음과 같이 암묵적으로 constructor가 정의된다. 

```jsx
class Base {
	constructor() {}
}
class Derived extends Base {
	constructor(...args) { super(...args); }
}
const derived = new Derieved();
console.log(derived);
```

위 예제와 같이 수퍼클래스와 서브 클래스 모두 constructor를 생략하면 빈 객체가 생성된다.

프러퍼티를 소유하는 인스턴스를 생성하려면 constructor 내부에서 인스턴스에 프로퍼티를 추가해야 한다. 

### super 키워드

super 키워드 함수처럼 호출할 수도 있고 this와 같이 식별자처럼 참조할 수 있는 특수한 키워드다. super 는 다음과 같이 동작한다.

- super 호출하면 수퍼클래스의 constructor를 호출한다.
- super 참조하면 수퍼클래스의 메서드를 호출할 수 있다.

**super 호출**

super를 호출하면 수퍼클래스의 constructor를 호출한다.

수퍼클래스와 같은 constructor 프로퍼티를 갖는다면 서브클래스 consturctor는 생략가능하지만 수퍼클래스에서 추가한 프로퍼티와 서브 클래스에서 추가한 프로퍼티를 갖는 인스턴스를 생성한다면 생략불가능하다.

<aside>
💡 **super 호출할 때 주의할 사항은 다음과 같다**

1. 서브 클래스에서 constructor를 생략하지 않는 경우 서브 클래스의 constructor에서는 반드시 super를 호출해야한다.
2. 서브 클래스의 consturctor에서 super 호출하기 전에는 this를 참조할 수 없다.
3. super는 반드시 서브 클래스의 constructor에서만 호출한다.

</aside>

**super 참조**

메서드 내에서 super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다. 

1. 서브 클래스의 프로포타입 메서드 내에서 `super.` 하면 수퍼 클래스의 포로토타입 메서드를 가리킨다. 
2. 서브클래스 정적 메서드 내에서 `super.`메서드는 수퍼클래스의 정적 메서드를 가르킨다.

## 상속 클래스의 인스턴스 생성 과정

```jsx
class Rectangle {
	constructor(width , height) {
		this.width = width;
		this.height = height;
	}
	getArea() {
		return this.width * this.hegith;
	}
	toString() {
		return `width  = ${this.width}, height = ${this.height}`;
	}
}

class ColorRectangle extends Rectangle {
	constructor(width, height, color){
	sup
```

![Untitled](https://github.com/sTIL-us/javascript-deepdive-study/blob/e3cf78ab1481e0f51de9d25be54b3b3e53de0818/25.%20%ED%81%B4%EB%9E%98%EC%8A%A4/Untitled%207.png)

**서브클래스의 super 호출**

자바스크립트 엔진으 수퍼클래스와 서브 클래스를 구분하기 위해 base derived를 값으로 갖는 [[ConstructorKind]] 를 갖는다. 

수퍼클래스는 ‘base’로 설정되지만, 다른 클래스를 상속받는 서브 클래스는 ‘derived’로 설정되어 호출했을 때 동작이 구분된다.

<aside>
💡 **서브클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에서 인스턴스 생성을 위임한다.**
이것이 서브클래스 constructor에서 super를 호출해야 하는 이유다.

</aside>

서브클래스가 new 와 함께 호출되면 서브클래스 constructor 내부의 super 키워드가 함수처럼 호출되어 수퍼클래스의 constructor가 호출된다.

만약 서브클래스의 constructor 내부에 super 호출이 없으면 에러가 발생한다.

**수퍼클래스의 인스턴스 생성과 this 바인딩**

수퍼클래스의 consturctor 내부의 this는 생성된 인스턴스를 가리킨다. 

이때 인스턴스는 수퍼클래스가 생성한 것이다.  하지만 new 연산자와 함께 호출한  클래스는 서브클래스 이므로 new.target을 출력하면 서브클래스가 나온다.

> **2022.03.23  - TIL** 
1. 수퍼 클래스와 서브 클래스는 인스턴스의 프로토타입 체인 뿐만 아니라 클래스 간의 프로토타입 체인도 생성한다. 이를 통해 프로토타입 메서드, 정적 메서드 모두 상속이 가능하다. 
2. 서브클래스의 constructor에서 super 호출하기 전까진 this를 참조할 수 없다.
3. super는 반드시 서브 클래스의 constructor에서 호출한다.
4. 서브 클래스 메서드에서 super 참조하면 부모의 프로토타입 메서드나 정적 메서드에 참조 가능
5. 상속 클래스 인스턴스 생성 과정
- 수퍼와 서브를 구분하기 위해 base  (부모) derived (자식) 설정되어 구분됨
- 서브 클래스가 new 연산자와 호출되면 빈 인스턴스 생성 this 바인딩
- 서브 클래스 construtor에서 super 키워드가 호출됨
- 그러면 부모의 construtor가 호출되서 수퍼 클래스가 평가됨
- 그래서 this에 바인딩된 객체 초기화함
- super 종료되면 서브 클래스 constructor로 돌아옴
-  그러면 서브클래스는 super가 반환한 인스턴스를 this에 반환해서 그대로 사용함
⇒ 이래서 super 호출전에 this 호출하지 못하는 거임
- 그래서 서브 인스턴스 초기화 되고 반환함
>
