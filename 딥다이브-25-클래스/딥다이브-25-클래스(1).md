# [JavaScript] 클래스 (1)

# 클래스는 프로토타입의 문법적 설탕인가?

---

자바스크립트는 프로토타입 기반 객체지향 언어이며, 클래스가 필요 없는 객체지향 프로그래밍 언어다.
ES5 에서는 클래스 없이도 생성자 함수와 프로토타입을 통해 객체지향 언어의 상속을 구현할 수 있다.

```jsx
// ES5 생성자 함수
var Person = (function(){
	// 생성자 함수
	function Person(name) {
		this.name = name
	}

	// 프로토타입 메서드
	Person.prototype.sayHi = function() {
		console.log('Hi! My name is ' + this.name)
	}

	// 생성자 함수 반환
	return Person
}())

// 인스턴스 생성
var me = new Person('KMin')
me.sayHi() // Hi! My name is KMin
```

ES6 에서 도입된 클래스는 자바나 C#과 같은 클래스 기반 객체지향 프로그래밍 언어와 매우 흡사한 새로운 객체 생성 매커니즘을 제시한다.
그러나 사실 클래스는 함수이며, 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕이라고 볼 수 있다.

그렇다고 클래스와 생성자 함수가 둘다 프로토타입 기반의 인스턴스를 생성하지만 정확히 동일하게 동작하는 것을 의미하진 않는다.

<aside>
💻 **클래스와 생성자 함수의 차이점**

---

1. 클래스를 `new` 연산자 없이 호출하면 에러가 발생한다.
그러나 생성자 함수는 `new` 연산자 없이 호출하면 일반함수로서 호출된다.
2. 클래스는 상속을 지원하는 `extends` 와 `super` 키워드를 제공한다.
하지만 생성자 함수는 X
3. 클래스는 ‘호이스팅이 발생하지 않는 것처럼 동작'한다.
하지만 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다.
4. 클래스 내의 모든 코드에는 암묵적으로 strict mode 가 지정되며 해제도 불가능하다.
하지만 생성자 함수는 암묵적으로 strict mode 가 지정되지 않는다.
5. 클래스의 `constructor` , 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 `[[Enumberable]]` 의 값이 false 다.
다시 말해, 열거되지 않는다.
</aside>

대체적으로 클래스가 생성자 함수 기반의 객체 생성 방식보다 견고하고 명료하고, `extends` 와 `super` 키워드는 상속 관계 구현을 더욱 간결하고 명확하게 하기 때문에,
클래스를 프로토타입 기반 객체 생성 패턴의 단순한 문법적 설탕이라고 보기보다는 **새로운 객체 생성 매커니즘**으로 보는 것이 보다 합당하다.

# 클래스 정의

---

클래스는 `class` 키워드를 사용하여 정의한다.
클래스 이름은 생성자 함수와 마찬가지로 파스칼 케이스를 사용하는 것이 일반적이다.

```jsx
class Person {}
```

일반 함수와 마찬가지로 표현식으로 클래스를 정의할 수도 있다.(일반적이진 않음)

```jsx
// 익명 클래스 표현식
const Person = class {}

// 기명 클래스 표현식
const Person = class MyClass {}
```

클래스를 표현식으로 정의할 수 있다는 것은 **클래스가 값으로 사용할 수 있는 일급 객체**라는 것을 의미한다.
따라서 다음과 같은 특징을 가진다.

1. 무명의 리터럴로 생성할 수 있다. (즉, 런타임에 생성이 가능하다)
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
3. 함수의 매개변수에게 전달할 수 있다.
4. 함수의 반환값으로 사용할 수 있다.

왜냐하면 자세히 말하면 클래스는 함수다

### 클래스 몸체에서 정의할 수 있는 메서드는 세가지가 있다.

- `constructor(생성자)`
- `프로토타입 메서드`
- `정적 메서드`

```jsx
// 클래스 선언문
class Person {
	// 생성자
	constructor(name) {
		// 인스턴스 생성 및 초기화
		this.name = name // name 프로퍼티는 public 하다.
	}

	// 프로토타입 메서드
	sayHi() {
		console.log(`Hi! My name is ${this.name}`)
	}

	// 정적 메서드
	static sayHello() {
		console.log('Hello!')
	}
}

// 인스턴스 생성
const me = new Person('KMin')

// 인스턴스의 프로퍼티 참조
console.log(me.name) // KMin
// 프로토타입 메서드 호출
me.sayHi() // Hi! My name is KMin
// 정적 메서드 호출
Person.sayHello() // Hello!
```

# 클래스 호이스팅

---

클래스는 함수로 평가된다.

```jsx
class Person {}

console.log(typeof Person) // function
```

클래스 선언문으로 정의한 클래스는 함수 선언문과 같이 소스코드 평가과정, 즉 런타임 이전에 먼저 평가되어 함수 객체를 생성한다.

→ 이 때 클래스가 평가되어 생성된 함수 객체는 생성자 함수로서 호출할 수 있는 함수, 즉 `constructor` 다
→ 생성자 함수로서 호출할 수 있는 함수는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.
( 프로토타입과 생성자 함수는 쌍으로 존재하기 때문 )

**단, 클래스는 클래스 정의 이전에 참조할 수 없다.**

```jsx
console.log(Person) // ReferenceError

class Person {}
```

**클래스 선언문은 마치 호이스팅이 발생하지 않는 것처럼 보인다. 하지만 그렇지 않다.**

```jsx
const Person = ''

{
	// 호이스팅이 발생하지 않는다면 ''이 출력되어야 한다.
	console.log(Person) // ReferenceError

	class Person {}
}
```

호이스팅이 발생하지 않는다면 위에서 정의한 Person 변수의 값 ‘ ’ 가 와야 하지만, 호이스팅이 실제로는 발생하고 있기 때문에
ReferenceError 가 발생하는 모습이다.

마찬가지로 var, let, const, function, function*, class 키워드를 사용하여 선언된 모든 식별자는 호이스팅된다.
모든 선언문은 런타임 이전에 먼저 실행되기 때문이다.

# 인스턴스 생성

---

클래스는 생성자 함수이며 `new` 연산자와 함께 호출되어 인스턴스를 생성한다.

```jsx
class Person {}

// 인스턴스 생성
const me = new Person()
console.log(me) // Person {}
```

함수는 `new` 연산자를 붙이냐 아니냐에 따라 인스턴스 생성 여부가 달라지지만,
클래스는 인스턴스 생성이 유일한 목적이므로 반드시 `new` 연산자와 함께 호출해야 한다!!

```jsx
class Person {}

const me = Person() // TypeError: 클래스를 new 없이 호출하면 에러 발생
```

클래스를 표현식으로 정의된 클래스의 경우 클래스를 가리키는 식별자(Person)를 사용해 인스턴스를 생성하지 않고 기명 클래스 표현식의 클래스 이름을 사용해 인스턴스를 생성하면 에러가 발생한다.

```jsx
const Person = class MyClass {}

const me = new Person() // OK

console.log(MyClass) // ReferenceError: 클래스 이름 MyClass 는 함수와 동일하게 클래스 몸체 내부에서만 유효하므로, Person 식별자를 사용해야 한다.
const you = new MyClass() // ReferenceError: new Person() 으로 호출해야 한다.
```

# 메서드

---

클래스 몸체에는 0개 이상의 메서드만 선언할 수 있다.

클래스 몸체에서 정의할 수 있는 메서드는 `constructor`, 프로토타입 메서드, 정적 메서드 세가지가 있다.

## 1) constructor

`constructor` 는 인스턴스를 생성하고 초기화하기 위한 특수한 메서드다. `constructor` 는 이름을 변경할 수 없다.

```jsx
class Person {
	// 생성자
	constructor(name) {
		// 인스턴스 생성 및 초기화
		this.name = name
	}
}
```

클래스는 오직 인스턴스를 생성하기 위한 생성자 함수다.

때문에 class Person 의 프로토타입을 까보면 거기서 `constructor` 는 또 자기 자신, 즉 클래스는 생성자 함수이며
`new` 연산자와 함께 클래스를 호출하면 클래스는 인스턴스를 생성한다.

`constructor` 는 메서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다.
다시 말해 클래스 정의가 평가되면 `constructor` 의 기술된 동작을 하는 함수 객체가 생성된다.

<aside>
💻 **클래스의 constructor 메서드와 프로토타입의 constructor 프로퍼티**

---

클래스의 constructor 메서드와 프로토타입의 constructor 프로퍼티는 이름이 같지만 직접적인 관련이 없다.

프로토타입의 constructor 프로퍼티는 모든 포로토타입이 가지고 있는 프로퍼티이며, 생성자 함수를 가리킨다.

</aside>

### `constructor` 는 생성자 함수와 유사하지만 몇가지 차이가 있다.

1. `constructor` 는 클래스 내에 최대 한 개만 존재할 수 있다.
    
    ```jsx
    class Person {
    	constructor() {}
    	constructor() {}
    }
    // SyntaxError
    ```
    
2. `constructor` 는 생략할 수 있다.
    
    ```jsx
    class Person {}
    ```
    
    `constructor` 를 생략하면 클래스에 다음과 같이 빈 `constructor` 가 암묵적으로 정의된다.
    `constructor` 를 생략한 클래스는 빈 `constructor` 에 의해 빈 객체를 생성한다.
    
    ```jsx
    class Person {
    	constructor() {} // constructor 는 생략하면 아래와 같이 빈 constructor 가 암묵적으로 정외된다.
    }
    
    // 빈 객체가 생성된다.
    const me = new Person()
    console.log(me) // Person {}
    ```
    
3. 프로퍼티가 추가되어 초기화된 인스턴스를 생성하려면 `constructor` 내부에서 `this` 에 인스턴스 프로퍼티를 추가한다.
    
    ```jsx
    class Person {
    	consructor() {
    		// 고정값으로 인스턴스 초기화
    		this.name = 'KMin'
    		this.address = 'Seoul'
    	}
    }
    
    // 인스턴스 프로퍼티가 추가된다.
    const me = new Person()
    console.log(me) // Person {name: 'KMin', address: 'Seoul'}
    ```
    
4. 인스턴스를 생성할 때 클래스 외부에서 인스턴스 프로퍼티의 초기값을 전달하려면 `constructor` 에 매개변수를 선언하고 인스턴스를 생성할 때 초기값을 전달한다.
    
    ```jsx
    class Person {
    	consturctor(name, address) {
    		this.name = name
    		this.address = address
    	}
    }
    
    // 인수로 초기값을 전달한다. 초기값은 constructor 에 전달된다.
    const me = new Person('KMin', 'Seoul')
    console.log(me) // Person {name: 'KMin', address: 'Seoul'}
    ```
    

`constructor` 는 별도의 반환문을 갖지 않아야 한다.

`new` 연산자와 함께 클래스가 호출되면 생성자 함수와 동일하게 암묵적으로 `this` , 즉 인스턴스를 반환하기 때문이다.

만약 리턴문에 객체를 반환하면 인스턴스를 초기화하더라도 해당 객체가 반환된다.

```jsx
class Person {
	constructor(name) {
		this.name = name
		return {} // 명시적으로 객체를 반환하면 암묵적인 this 반환이 무시된다.
	}
}

const me = new Person('KMin')
console.log(me) // {} constructor 에서 명시적으로 반환한 빈 객체가 반환된다.
```

하지만 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 `this` (인스턴스)가 반환된다.

```jsx
class Person {
	constructor (name) {
		this.name = name
		return 100 // 명시적으로 원시값을 반환하면 원시값 반환이 무시되고 암묵적으로 this 가 반환된다.
	}
}

const me = new Person('KMin')
console.log(me) // Person {name: 'KMin'}
```

## 2) 프로토타입 메서드

클래스 몸체에서 정의한 메서드는 생성자 함수에 의한 객체 생성 방식과는 다르게 클래스의 `prototype` 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 된다.

```jsx
class Person {
	constructor(name) {
		this.name = name
	}

	// 프로토타입 메서드
	sayHi() {
		console.log(`Hi! My name is ${this.name}`)
	}
}

const me = new Person('KMin')
me.sayHi() // Hi! My name is KMin
```

**생성자 함수와 마찬가지로 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 된다.**

클래스 몸체에서 정의한 메서드는 인스턴스의 프로토타입에 존재하는 프로토타입 메서드가 된다.

때문에 인스턴스는 이 프로토타입 메서드를 상속받아 사용할 수 있다.

( 결국 클래스는 생성자 함수와 같이 인스턴스를 생성하는 생성자 함수라고 볼 수 있고, 다시 말해 클래스는 생성자 함수와 마찬가지로 프로토타입 기반의 객체 생성 메커니즘이다. )

## 3) 정적 메서드

정적(static) 메서드란, 인스턴스를 생성하지 않아도 호출할 수 있는, 생성자 함수 본인이 가진 메서드를 말한다.

클래스에서는 메서드에 `static` 키워드를 붙이면 정적 메서드(클래스 메서드)가 된다.

```jsx
class Person {
	constructor(name) {
		this.name = name
	}

	// 정적 메서드
	static sayHi() {
		console.log('Hi!')
	}
}
```

정적 메서드는 클래스에 바인딩된 메서드가 된다.

클래스는 함수 객체로 평가되므로 자신의 프로퍼티/메서드를 소유할 수 있다.
그렇기 때문에 인스턴스를 생성하지 않고도 정적 메서드를 호출할 수 있다.

```jsx
// 정적 메서드는 클래스로 호출한다.
// 정적 메서드는 인스턴스 없이도 호출할 수 있다.
Person.sayHi() // Hi!
```

## 4) 정적 메서드와 프로토타입 메서드의 차이

1. 정적 메서드와 프로토타입 메서드는 자신이 속해 있는 프로토타입 체인이 다르다.
2. 정적 메서드는 클래스로 호출하고, 프로토타입 메서드는 인스턴스로 호출한다.
3. 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만, 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.

### 정적 메서드 호출 예시

```jsx
class Square {
	static area(width, height) {
		return width * height
	}
}

console.log( Square.area(10, 10) ) // 100
```

정적 메서드는 인스턴스 프로퍼티를 참조하지 않는다.
인스턴스 프로퍼티를 참조해야 한다면 프로토타입 메서드를 사용해야 한다.

### 프로토타입 메서드 호출 예시

```jsx
class Square {
	constructor(width, height) {
		this.width = width
		this.height = height
	}

	area() {
		return this.width * this.height
	}
}

const square = new Square(10, 10)
console.log( square.area() ) // 100
```

## 5) 클래스에서 정의한 메서드의 특징

1. function 키워드를 생략한 메서드 축약 표현을 사용한다
2. 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요 없다.
3. 암묵적으로 strict mode 로 실행된다.
4. `for...in 문` 이나 `Object.keys` 메서드 등으로 열거할 수 없다.
즉 프로퍼티의 열거 가능 여부를 나타내는 `[[Enumerable]]` 프로퍼티 어트리뷰트 값이 false 다.
5. 내부 메서드 `[[Construct]]` 를 갖지 않는 non-constructor 다. 따라서 `new` 연산자와 함께 호출할 수 없다.

> **오늘 알게된 것 TIL (2022.03.21 월)**
> 
> 
> ---
> 
> 1. 클래스는 내부에서 constructor 생성자와, 프로토타입 메서드, static 키워드를 붙이는 정적 메서드 등 3가지의 메서드가 있다.
> 2. 클래스는 엄밀히 말해 함수이기 때문에 일급 객체이기도 하며, 런타임 이전에 먼저 평가되어 함수 객체를 생성한다는 것을 알았다.
> 3. 클래스가 생성한 인스턴스 또한 프로토타입 체인의 일원이 된다는 것을 알았다.