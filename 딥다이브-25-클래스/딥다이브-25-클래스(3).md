# [JavaScript] 클래스 (3)

# 상속에 의한 클래스 확장

---

## 1. 클래스 상속과 생성자 함수 상속

상속에 의한 클래스 확장은 프로토타입 기반 상속의 개념과는 다르다
프로토타입 기반 상속은 프로토타입 체인을 통해 다른 객체의 자산을 상속받는 개념이지만,
**상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장(extends)하여 정의하는 것이다.**

클래스는 상속을 통해 다른 클래스를 확장할 수 있는 문법인 `extends` 키워드가 기본적으로 제공된다.

자바스크립트는 클래스 기반 언어가 아니므로 생성자 함수를 사용하여 클래스를 흉내내는 의사 클래스 상속(pseudo classical inheritance) 패턴을 사용하여 클래스의 상속을 흉내내기도 했다.
그러나 현재 의사 클래스 상속 패턴은 더는 필요하지 않다. *이런게 있다 정도만 알자

- 의사 클래스 상속(pseudo classical inheritance) 패턴
    
    ```jsx
    var Animal = (function () {
    	function Aminal(age, weight) {
    		this.age = age
    		this.weight = weight
    	}
    
    	Animal.prototype.eat = function () {
    		return 'eat'
    	}
    	Animal.prototype.move = function () {
    		return 'move'
    	}
    
    	return Animal
    }())
    
    // Animal 생성자 함수를 상속하여 확장한 Bird 생성자 함수
    var Bird = (function () {
    	function Bird() {
    		// Animal 생성자 함수에게 this 와 인수를 전달하면서 호출
    		Animal.apply(this, arguments)
    	}
    
    	// Brid.prototype 을 Animal.prototype 을 프로토타입을 갖는 객체로 교체
    	Bird.prototype = Object.create(Animal.prototype)
    	// Bird.prototype.constructor 을 Animal 에서 Bird 로 교체
    	Bird.prototype.constructor = Bird
    
    	Bird.prototype=fly = function() {
    		return 'fly'
    	}
    
    	return Bird
    }())
    
    var bird = new Bird(1, 5)
    
    consoel.log(bird) // Bird {age: 1, weight: 5}
    console.log(bird.eat()) // eat 
    console.log(bird.move()) // move
    console.log(bird.fly()) // fly
    ```
    

## 2. extends 키워드

상속을 통해 클래스를 확장하려면 `extends` 키워드를 사용하여 상속받을 클래스를 정의한다.

```jsx
// 수퍼(베이스/부모)클래스
class Base {}

// 서브(파생/자식)클래스
class Derived extends Base {}
```

상속을 통해 확장된 클래스를 서브클래스(subclass), 서브클래스에게 상속된 클래스를 수퍼클래스(superclass)라 부른다.
서브클래스는 파생클래스(derived class) 또는 자식 클래스(child class),
수퍼클래스는 베이스클래스(base class) 또는 부모 클래스(parent class)라고 부르기도 한다.

`extends` 키워드의 역할은 수퍼클래스와 서브클래스 간의 상속관계를 설정하는 것으로,
클래스도 프로토타입을 통해 상속관계를 구현한다.

수퍼클래스와 서브클래스는 인스턴스의 프로토타입 체인뿐 아니라 클래스 간의 프로토타입 체인도 생성한다.
이를 통해 프로토타입 메서드, 정적 메서드 모두 상속이 가능하다.

## 3. 동적 상속

`extends` 키워드는 클래스뿐만 아니라 생성자 함수를 상속받아 확장할 수도 있다.
단, `extends` 앞에는 반드시 클래스가 와야한다.

```jsx
// 생성자 함수
function Base(a) {
	this.a = a
}

// 생성자 함수를 상속받는 서브클래스
class Derived extends Base {}

const derived = new Derived(1)
console.log(derived) // Derived {a: 1}
```

`extends` 키워드 다음에는 클래스 뿐만이 아니라 `[[Construct]]` 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다.
이를 통해 동적으로 상속받을 대상을 결정할 수 있다.

```jsx
function Base1() {}

class Base2 {}

let condition = true

// 조건에 따라 동적으로 상속 대상을 결정하는 서브클래스
class Derived extends (condition ? Base1 : Base2) {}

const derived = new Derived()
console.log(derived) // Derived {}

console.log(derived instanceof Base1) // true
console.log(derived instanceof Base2) // false
```

## 4. 서브클래스의 constructor

클래스에서 constructor 를 생략하면 다음과 같이 비어있는 constructor 가 암묵적으로 정의된다.

```jsx
constructor() {}
```

서브클래스에서 constructor 를 생략하면 클래스에 다음과 같은 constructor 가 암묵적으로 정의된다.
`args` 는 `new` 연산자와 함께 클래스를 호출할 때 전달한 인수의 리스트다.

```jsx
constructor(...args) {
	super(...args)
}
```

`super()` 는 수퍼클래스의 constructor(super-constructor)를 호출하여 인스턴스를 생성한다.

다음처럼 수퍼클래스와 서브클래스 모두 constructor 를 생략하면 그 아래와 같다.

```jsx
// 수퍼클래스
class Base {}

// 서브클래스
class Derived extends Base {}
```

위 예제으 ㅣ클래스에는 다음과 같이 암묵적으로 constructor 가 정의된다.

```jsx
// 수퍼클래스
class Base {
	constructor() {}
}

// 서브클래스
class Derived extends Base {
	constructor(...args) {
		super(...args)
	}
}
```

위와 같이 수퍼/서브클래스를 정의하면 모두 consturctor 가 생략됐기 때문에 빈 객체가 생성된다.
프로퍼티를 소유하는 인스턴스를 생성하려면 constructor 내부에서 인스턴스에 프로퍼티를 추가해야 한다.

## 5. super 키워드

`super` 키워드는 함수처럼 호출할 수도 있고 this 와 같이 식별자처럼 참조할 수 있는 특수한 키워드다.
`super`는 다음과 같이 동작한다.

- super 를 호출하면 수퍼클래스의 constructor(super-constructor)를 호출한다
- super 를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.

### 1) super 호출

**super 를 호출하면 수퍼클래스의 constructor(super-constructor)를 호출한다.**

- 다음 예제와 같이 수퍼클래스의 constructor 내부에서 추가한 프로퍼티를 그대로 갖는 인스턴스를 생성한다면 서브클래스의 constructor 를 생략할 수 있다.
- **이때 `new` 연산자와 함께 서브클래스를 호출하면서 전달한 인수는 모두 서브클래스에 암묵적으로 정의된 constructor 의 super 호출을 통해 수퍼클래스의 constructor 에 전달된다.**
    
    ```jsx
    // 수퍼클래스
    class Base {
    	constructor(a, b) {
    		this.a = a
    		this.b = b
    	}
    }
    
    // 서브클래스
    class Derived extends Base {
    	// 다음과 같이 암묵적으로 constructor 가 정의된다.
    	// constructor(...args) { super(...args) }
    }
    
    const derived = new Derived(1, 2)
    console.log(derived) // Derived {a: 1, b: 2}
    ```
    

- 다음 예제와 같이 수퍼클래스에서 추가한 프로퍼티와 서브클래스에서 추가한 프로퍼티를 갖는 인스턴스를 생성한다면 서브클래스의 constructor 를 생략할 수 없다.
- 이때 `new` 연산자와 함께 서브클래스를 호출하면서 전달한 인수 중에서 수퍼클래스의 constructor 에 전달할 필요가 있는 인수는 constructor 에서 호출하는 super 를 통해 전달한다.
    
    ```jsx
    // 수퍼클래스
    class Base {
    	constructor(a, b) { // 4)
    		this.a = a
    		this.b = b
    	}
    }
    
    // 서브클래스
    class Derived extends Base {
    	constructor(a, b, c) { // 2)
    		super(a, b) // 3)
    		this.c = c
    	}
    }
    
    const derived = new Derived(1, 2, 3) // 1)
    console.log(derived) // Derived {a: 1, b: 2, c: 3}
    ```
    
    1) `new` 연산자와 함께 Derived 클래스를 호출하면서
    2) 전달한 인수 1, 2, 3은 Derived 클래스의 constructor 에 전달되고,
    3) super 호출을 통해
    4) Base 클래스의 constructor 에 일부가 전달된다.
    
    ⇒ 이처럼 인스턴스 초기화를 위해 전달한 인수는 수퍼클래스와 서브클래스에 배분되고 상속 관계의 두 클래스는 서로 협력하여 인스턴스를 생성한다.
    

> `**super` 를 호출할 때의 주의사항🍅**
> 
> 
> ---
> 
> - **1) 서브클래스에서 constructor 를 생략하지 않는 경우 서브클래스의 constructor 에서는 반드시 `super` 를 호출해야 한다.**
>     
>     ```jsx
>     class Base {}
>     
>     class Derived extends Base {
>     	constructor() {
>     		// ReferenceError: 서브클래스에서 constructor 를 생략하지 않으면 super 를 꼭 호출!!
>     		// 설령 수퍼클래스가 빈 객체였다고 하더라도!
>     	}
>     }
>     ```
>     
> - **2) 서브클래스의 constructor 에서 super 를 호출하기 전에는 this 를 참조할 수 없다.**
>     
>     ```jsx
>     class Base {}
>     
>     class Derived extends Base {
>     	constructor() {
>     		this.a = 1 // ReferenceError!!
>     		super()
>     	}
>     }
>     ```
>     
> - **3) super 는 반드시 서브클래스의 constructor 에서만 호출한다.**
>     
>     ```jsx
>     class Base {
>     	constructor() {
>     		super() // SyntaxError!!! 수퍼클래스에서 super 호출 X
>     	}
>     }
>     
>     function Foo() {
>     	super() // SyntaxError!!! 생성자함수에서 super 호출 X
>     }
>     ```
>     

### 2) super 참조

**메서드 내에서 super 를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.**

1. 서브클래스의 프로토타입 메서드 내에서 super.sayHi 는 수퍼클래스의 프로토타입 메서드 sayHi 를 가리킨다.
    
    ```jsx
    // 수퍼 클래스
    class Base {
    	constructor(name) {
    		this.name = name
    	}
    
    	sayHi() {
    		return `Hi! ${this.name}`
    	}
    }
    
    // 서브 클래스
    class Derived extends Base {
    	sayHi() {
    		// super.sayHi 는 수퍼클래스의 프로토타입 메서드를 가리킨다.
    		return `${super.sayHi()}. How are you doing?`
    	}
    }
    
    const derived = new Derived('KMin')
    console.log(derived.sayHi()) // Hi! KMin. How are you doing?
    ```
    
    super 참조를 통해 수퍼클래스의 메서드를 참조하려면 super 가 수퍼클래스의 메서드가 바인딩된 객체, 즉 수퍼클래스의 prototype 프로퍼티에 바인딩된 프로토타입을 참조할 수 있어야 한다.
    
    **결론적으로 super 는 자신을 참조하고 있는 메서드가 바인딩되어 있는 객체의 프로토타입(Base.prototype)을 가리킨다.
    따라서 super.sayHi 는 Base.prototype.sayHi 를 가리킨다.**
    
2. 서브클래스의 정적 메서드 내에서 super.sayHi 는 수퍼클래스의 정적 메서드 sayHi 를 가리킨다.
    
    ```jsx
    // 수퍼클래스
    class Base {
    	static sayHi() {
    		return 'Hi!'
    	}
    }
    
    // 서브클래스
    class Derived extends Base {
    	static sayHi() {
    		// super.sayHi 는 수퍼클래스의 정적 메서드를 가리킨다.
    		return `${super.sayHi()} how are you doing?`
    	}
    }
    
    console.log(Derived.sayHi()) // Hi! how are you doing?
    ```
    

## 6. 상속 클래스의 인스턴스 생성 과정

### 1) 서브클래스의 super 호출

자바스크립트 엔진은 클래스를 평가할 때 수퍼클래스와 서브클래스를 구분하기 위해 내부슬롯 [[ContructorKind]] 를 갖는다.

- 수퍼 클래스 (또는 생성자함수) 는 [[ContructorKind]] 의 값이 `"base"` 로 설정되고,
- 서브클래스는 내부슬롯 [[ContructorKind]] 의 값이 `"derived"` 로 설정된다.

⇒ 이를 통해 수퍼/서브클래스는 `new` 연산자와 함께 호출되었을 때의 동작이 구분된다.

- 수퍼클래스는 new 로 호출될 때 암묵적으로 빈 객체, 즉 인스턴스를 생성하고 this 를 바인딩한다.
- **반면 서브클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임한다.
이것이 바로 constructor 에서 super 를 호출해야 하는 이유다.**

### 2) 수퍼클래스의 인스턴스 생성과 this 바인딩

수퍼클래스의 consturctor 내부의 코드가 실행되기 이전에 암묵적으로 빈객체를 생성하고, 
이 빈 객체가 바로 인스턴스이며,
바로 이 빈 객체(인스턴스)에 this 를 바인딩한다.

이때 인스턴스는 수퍼클래스가 생성했지만 `new` 로 호출한 것은 ‘서브클래스'임이 중요하다
즉 new 연산자로 호출된 함수를 가리키는 `[new.target](http://new.target)` 이 서브클래스를 가리키기 때문에,
**인스턴스는 new.target 이 가리키는 서크르래스가 생성한 것으로 처리된다.**

⇒ 따라서 생성된 인스턴스의 프로토타입은 수퍼클래스.prototype 이 아니라, 서브클래스.prototype 이 되는 것이다.

### 3) 수퍼클래스의 인스턴스 초기화

수퍼클래스의 constructor 가 실행되어 this 에 바인딩되어 있는 인스턴스를 초기화한다.
즉 this 에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고 constructor 가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티를 초기화한다.

### 4) 서브클래스의 constructor 로의 복귀와 this 바인딩

super 의 호출이 종료되고 제어 흐름이 서브클래스 constructor 로 돌아온다.

**이때 super 가 반환한 인스턴스가 this 에 바인딩된다.
서브클래스는 별도의 인스턴스를 생성하지 않고 super 가 반환한 인스턴스를 this 에 바인딩하여 그대로 사용한다.**

**⇒ 이처럼 super 가 호출되지 않으면 인스턴스가 생성되지 않으며, this 바인딩도 할 수 없다. 서브클래스의 constructor 에서 super 를 호출하기 전에는 this 를 참조할 수 없는 이유도 이 때문이다.**

### 5) 서브클래스의 인스턴스 초기화

super 호출 이후, 서브클래스의 constructor 에 기술되어 있는 인스턴스 초기화가 실행된다.
즉 this 에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고 constructor 가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티를 초기화한다.

### 6) 인스턴스 반환

클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this 가 암묵적으로 반환된다.

<aside>
💻 **super 호출 예시**

---

1. 서울시 종로구로 이사온 ‘꽁치 (27)’는 새로 주민등록을 하러 종로구청에 필요한 서류를 구비해 방문했다.
2. 종로구청에서는 꽁치를 종로구민으로 등록하기 이전에 서울시민으로 등록해야 하므로, 꽁치가 들고온 서류 중 서울시민으로 등록하기 위해 필요한 서류를 간추려 서울시청으로 보냈다.
3. 서울시청에서는 종로구청에서 올려보낸 서류를 가지고 꽁치를 서울시민으로 등록해서 완성된 서류를 가지고 종로구청으로 다시 내려보냈다.
4. 서울시민으로 등록된 꽁치의 남은 서류(종로구민으로 등록하기 위한 서류)를 가지고 종로구청에서는 꽁치를 종로구민으로 등록했다.
5. 이 과정에서 처음 꽁치는 서울시청에서 먼저 서울시민으로 등록하는 과정을 거쳤다.
하지만 결과적으로 꽁치의 서울시민 등록 요청을 보낸 것은 종로구청이기 때문에 꽁치는 결과적으로 종로구민이 되었다.
( 종로구청의 인스턴스가 됐다! )
그렇게 완성된 꽁치는 이제 비로소 완전한 종로구민이 되었다!
</aside>

## 7. 표준 빌트인 생성자 함수 확장

동적 상속에서 살펴보았듯이 `extends` 키워드 다음에는 클래스 뿐만이 아니라 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다.
따라서 생성자 함수 뿐만 아니라 String, Number, Array 같은 표준 빌트인 객체도 `extends` 키워드를 사용하여 확장할 수 있다.

```jsx
// Array 생성자 함수를 상속받아 확장한 MyArray
class MyArray extends Array {
	// 중복된 배열 요소를 제거하고 반환한다.
	uniq() {
		return this.filter((v, i, self) => self.indexOf(v) === i)
	}

	// 모든 배열 요소의 평균을 	구한다
	average() {
		return this.reduce((pre, cur) => pre + cur, 0) / this.length
	}
}
```

이때 주의할 것은 Array.prototype 의 메서드 중에서 map, filter 와 같이 새로운 배열을 반환하는 메서드가 MyArray 클래스의 인스턴스를 반환한다는 것이다.

> **새로 알게된 것 TIL (2022.03.23 수)**
> 
> 
> ---
> 
> 1. `extends` 키워드를 통해서 클래스는 생성자 함수와 다르게, 실질적으로 상위 클래스를 상속받아 ‘확장'하는 개념으로서 생성자함수와 차이를 갖지만, 상속을 받을 때는 생성자 함수와 클래스 모두 상속받을 수 있다.
> ( 추측컨대 기존의 코드와의 호환을 고려해 ES6 에서도 var 키워드를 유지시킨 자바스크립트의 정책상 기존의 코드에서 생성자 함수를 쓰던 것을 그대로 상속받아서 클래스를 도입할 수 있게 하려고 한 의도가 아닐까 싶다 )
> 2. 서브클래스에서 constructor 를 생략하면 암묵적으로 constructor(...args) { super(...args) } 를 호출하여 수퍼클래스의 constructor 를 그대로, 수퍼클래스를 new 로 호출할 때 적은 인수도 그대로 같이 입력받는다는 것을 알았다.
> 그래서 아무런 확장 없이 고대로 extends 로 수퍼클래스를 상속하면 그 서브클래스는 겉껍데기는 같은 객체가 생성된다.
> (하지만 엄밀히 말해서 [[ConstructorKind]] 내부슬롯에서 다른 값을 가질 것이다 ex. “base”, “derived” )
> 3. 서브클래스에서 super 키워드는 결국, 수퍼클래스의 기능(인스턴스 프로퍼티)를 확장해서 자신의 인스턴스 프로퍼티를 확장했지만, `new` 연산자로 서브클래스의 인스턴스를 호출할 때 부모로부터 전달받은 인스턴스 프로퍼티를 초기화하기 위해 전달되는 인수의 경우는 다시 수퍼클래스로 올려보내 처리해서 자신의 인스턴스 프로퍼티로 생성하는 과정을 가진다.