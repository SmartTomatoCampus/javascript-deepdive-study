# 발표문 - Symbol, **[iterable](https://ko.javascript.info/iterable)**

# 루피님

1. Symbol은 다른 값과 중복되지 않는 유일무이한 값이다.
2. Symbol은 암묵적으로 래퍼 객체를 생성한다.
3. 심벌값은 암묵적으로 문자열이나 숫자 타입으로 변환되지 않는다.
4. 심벌 값을 프로퍼티 키로 사용하려면 프로퍼티 키로 사용할 심벌 값에 대괄호를 사용해야 한다.
    - 심벌을 쓰는 여러가지 이유들이 있겠지만 뭔가 와닿았던 하나의 예시
    -> object 타입의 변수가 있다고 했을 때 프로퍼티 키의 값을 건드리지 않기 위해서 사용함
    -> 프로퍼티 키를 기존과 같이 string일 경우에는 값이 변경되지만 Symbol로 사용할 경우에는 값이 덮어씌여지지 않고 보존됨
5. 심벌 값을 프로퍼티 키로 사용하여 생성한 프로퍼티는 for ... in 문이나 Object.keys, Object.getOwnPropertyNames 메서드로 사용 할 수 없다
-> 외부에 노출할 필요가 없는 프로퍼티를 부분적으로 은닉 할 수 있다.(Object.getOwnPropertySymbols 메서드를 사용하면 프로퍼티 찾을 수 있음)
6. 심벌은 중복되지 않는 상수 값을 생성하고 기존 코드에 영향으로 주지 않으며 새로운 프로퍼티를 추가하기 위해 도입되었다.
7. 이터러블은 for...of 를 사용 할 수 있고 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용 할 수 있다.
8. 이터레이터의 next 메서드는 순회 결과를 나타내는 이터레이터 리절트 객체를 반환한다.

# 애한님

심벌은 중복되지 않는 상수 값을 생성하는 것은 물론 기존에 작성된 코드에 영향을 주지 않고 새로운 프로퍼티를 추가하기 위해, 즉 하위 호환성을 보장하기 위해 도입되었다.

# 꽁치님

1. Symbol() 함수는 유일무이한 절대값을 만들고, 인수로 삽입한 문자열은 디버깅 용도로만 사용되지만, 이렇게만 선언하면 전역 심벌 레지스트리에서 해당 키로 찾을 수 없기 때문에 새로 심벌값을 생성한다면 Symbol.for() 가 유용한 것 같다.
2. 순회 가능한 자료구조를 갖는 객체를 '이터러블'이라고 하는 것 같다. 배열과 문자열은 사실은 각 요소 또는 문자열에 정수로 된 문자열 프로퍼티 키를 갖는 객체이기 때문에 순회가 가능하기 때문에 이터러블이라고 하는 것 같다.
3. 이터러블이 갖고 있는 이터레이터의 `next`메서드를 통해서 이터러블이 순회 가능(반복)할 수 있다는 것을 알았다. 그래서 배열이 반복문을 사용할 수 있는 것이었다.
4. Array.from() 메서드는 유사 배열 객체나 이터러블을 배열로 변환해주는데, 인자로 받은 유사 배열 객체나 이터러블로부터 배열이 생성되기 때문에 메서드 이름이 Array.from() 이다!!!!
5. 유사 배열 객체는 정수로된 프로퍼티 키를 가지고 length 프로퍼티를 갖지만 Symbol.iterator() 를 갖지 않아서 이터러블이 아니다. 반면 배열은 정수로된 프로퍼티 키를 가지고 length 프로퍼티를 갖고 Symbol.iterator() 도 프로토타입으로 가지기 때문에 이터러블이다.
    - 그치만 이 둘은 둘다 본질적으로 객체다. 정수를 프로퍼티 키로 갖는 객체다. 때문에 array[0] 처럼 인덱스로 접근하는 것 같지만 사실은 객채에서 프로퍼티값에 대괄호표기법으로 접근하는 것과 같다.
    - 그럼 객체도 객체고, 배열도 객체면 이 둘을 구분하는 본질적인 차이는 무엇일까
    - 배열은 이터레이션 프로토콜을 준수한 '이터러블'이란 점에서 일반 객체와 본질적인 차이를 갖는 것이다.
6. 그때 일반 객체를 배열로 만드는 그 '이터레이터'는 바로 Symbol.iterator 고, 얘를 직접 사용해서도 이터러블을 생성할 수 있다.
    - Symbol.iterator 가 뭔데 자바스크립트 엔진이 배열로 인식할 수 있는 이터러블을 만든다는 걸까
    - 그게 33장 7절 가장 마지막 Well-known Symbol 로 자바스크립트가 기본 제공하는 심벌이기 때문이고, 심벌은 절대 중복되지 않는 유일무이한 값이기 때문에 Symbol.iterator 는 어디서 꺼내먹든 바로 그 이터러블을 생성하는 이터레이터가 되는 것이다!!

# 초생님

## Symbol

1. Symbol 이란 다른 값과 중복되지 않는 유일한 값의 타입이고 외부에 노출되지 않는다.
2. 리터럴로 선언할 수 없고 Symbol 함수를 호출해서 생성한다.
3. 암묵적 타입 변환되지 않지만 불리언 타입으로는 예외다
4. 심벌과 상수의 차이는 상수는 값이 변경, 중복될 가능성이 있지만 심벌은 그렇지 않음
5. 근데 이걸 뭐에다 쓰냐 표준 빌트인 객체를 확장할 때 씀
6. 개발자가 선언할 때는 없던 메서드여서 잘만 사용하다가 갑자기 똑같은 이름의 메서드가 추가되는 업데이트가 있다면 충돌이 발생하니까 심벌값으로 중복을 없애는 것

## 이터러블

1. ES6 이전에 순회 가능한 데이터 컬렉션은 통일된 규약없이 각자 나름의 구조를 가지고 다양한 방법으로 순회했다.
2. 이터레이션 프로토콜은 순회 가능한 데이터 컬렉션을 만들기 위한 약속이다.
3. 그래서 규약에 이터러블 프로토콜 / 이터레이션 프로토콜 이 있고 이 규약들을 지켜서 나오게 이터러블 / 이터레이션이다.

# 너두님

### 알게된것

- 심벌이란 값이 있다는것
- 래퍼객체를 생성하지만 그렇다고 new는 쓰지않는 내꺼같은 내꺼아닌것 같은 객체
- 동적이지만 중복되지 않는 프로퍼티키
- 심볼의 구체적인 사용방법

### 알게된것

- 이터러블과 이터레이터의 표준규약
- 이터러블과 관련된 다양한 상황
- 유사배열객체를 완전 오해하고 있었다
- 스프레드와 구조분해는 이터러블해야 되는것인지 처음알았다
- 지연평가에 대해서 알게되었다.

### 모르겠는것

```jsx
{
    [Symbol.iterator]() { return this; },
    // next 메서드는 이터레이터 리절트 객체를 반환
    next() {
      [pre, cur] = [cur, pre + cur];
      return { value: cur, done: cur >= max };
    }
  };
};
에 대해서 설명해주실수 있으신분
```

# 뽀또님

## Symbol

### Symbol ?

심벌 값은 Symbol 함수를 호출하여 생성한다. **다른 값과 절대 중복되지 않는 유일무이한 값이다.**

### 심벌과 프로퍼티 은닉

심벌 값을 프로퍼티 키로 사용하여 생성한 프로퍼티는 for ... in 문이나 Object.keys , Object.getOwnPropertyNames 메서드로 찾을 수 없다. 

그러나 Object.getOwnpropertySymbols 메서드를 사용하면 심벌 값을 프로퍼티 키로 사용하여 생성한 프로퍼티를 찾을 수 있다.

### Symbol.for / Symbol.keyFor

Symbol.for 메서드는 인수로 전달받은 문자열을 키로 사용하여 키와 심벌 값의 쌍들이 저장되어 있는 전역 심벌 레지스트리에서 해당 키와 일치하는 심벌 값을 검색한다.

Symbol.keyFor 메서드를 사용하면 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출할 수 있다.

## 이터러블

### **이터러블 프로토콜 / 이터레이터 프로토콜**

이터러블을 [for...of], [전개 연산자], [비구조화] ..등, 이터러블이나 이터레이터 프로토콜을 따르는 연산자들과 함께 동작하도록 하는 약속된 규약을 의미한다. 그래서 이터러블이란 이터러블 규약을 따르는 객체인 셈이다.

### **이터러블**

이터레이터를 리턴하는 [Symbol.iterator]() 메서드를 가진 객체

배열의 경우 Array.prototype 의 Symbol.iterator 를 상속받기 때문에 이터러블이다. 문자열도 마찬가지

### **이터레이터**

{value : 값 , done : true/false} 형태의 이터레이터 객체를 리턴하는 next() 메서드를 가진 객체. next 메서드로 순환 할 수 있는 객체다.

## 유사배열 과 이터러블

**이터러블(iterable)** : 위에서 설명한 바와 같이 메서드 Symbol.iterator가 구현된 객체.

**유사 배열(array-like)** : 인덱스와 length 프로퍼티가 있어서 배열처럼 보이는 객체.

- 이터러블과 유사 배열은 배열이 아니기 때문에 push, pop 등의 메서드를 지원하지 않는다.
- 이터러블과 유사 배열을 배열처럼 다루고 싶을 때 이런 특징은 불편함을 초래하게 된다.

### Map과 Set 자료형도 이터러블이다.

맵과 셋은 엄밀히 **독리된 자료형이지 객체나 배열이 아니다.**

그럼에도 불구하고 **for..of문과 동작하는 이유는 인덱스로 접근하는게 아닌 이터러블 프로토콜을 따르고 있기 떄문**이다.

또한 자체적으로 자체 **내장 forEach()메서드를 지원**하기도 한다.

**map.keys() :** value에 key 만 있는 이터레이터를 반환. **(순회 가능)**

**map.values() : ****values에 map의 valuse만 있는 이터레이터 반환

**map.entries() :** key 와 value가 있는 이터레이터를 반환
