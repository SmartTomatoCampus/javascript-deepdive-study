# [JavaScript] 26장 ES6 함수의 추가 기능

# 26.1 함수의 구분

---

자바스크립트의 기존의 함수는 일반함수, `new` 를 붙여 생성자함수로, 객체에 바인딩되어 메서드로도 호출할 수도 있었다.
그러나 이는 언뜻 보면 편리해보이지만, 성능적인 면에서 손해다.

모든 함수가 `new` 만 붙이면 생성자 함수가 될 수 있고,
그말은 모든 함수가 callable 이면서 constructor 인 것이다.

```jsx
// 프로퍼티 f 에 바인딩된 함수는 callable 이며 constructor 이다.
var obj = {
	x: 10,
	f: function () { return this.x }
}

// 프로퍼티 f에 바인딩된 함수를 메서드로서 호출
console.log(obj.f()) // 10

// 프로퍼티 f에 바인딩된 함수를 일반 함수로서 호출
var bar = obj.f
console.log(bar()) // undefined

// 프로퍼티 f에 바인딩된 함수를 생성자 함수로서 호출
console.log(new obj.f()) // f {}
```

이런 경우가 흔치는 않겠지만, 문법상 가능하다는 것 자체가 문제가 있다.
또한 성능면에서도 문제가 있다.
객체에 바인딩된 함수가 constructor 라는 것은 객체에 바인딩된 함수가 prototype 프로퍼티를 가지며, 프로토타입 객체도 생성한다는 것을 의미하기 때문이다.
즉 불필요한 프로토타입 객체를 생성한다.

이러한 문제를 해결하기 위해 ES6 에서는 함수를 사용 목적에 따라 세 가지 종류로 명확히 구분했다.

| ES6 함수의 구분 | constructor | prototype | super | arguments |
| --- | --- | --- | --- | --- |
| 일반 함수(Normal) | O | O | X | O |
| 메서드 (Method) | X | X | O | O |
| 화살표 함수 (Arrow) | X | X | X | X |

# 26.2 메서드

---

**ES6 사양에서 메서드는  메서드 축약 표현으로 정의된 함수만을 의미한다**

```jsx
const obj = {
	x: 1,
	// foo 는 메서드다
	foo() { return this.x }
	// bar에 바인딩된 함수는 메서드가 아닌 일반 함수다.
	bar: function() { return this.x }
}

console.log(obj.foo()) // 1
console.log(obj.bar()) // 1
```

**⇒ ES6 사양에서 정의한 메서드는 인스턴스를 생성할 수 없는 non-constructor 다.**

- 따라서 ES6 메서드는 생성자 함수로서 호출할 수 없다!!!!
- ES6 메서드는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.
- ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 `[[HomeObject]]` 를 갖는다.
super 참조는 내부 슬롯 `[[HomeObject]]` 를 사용하여 수퍼클래스의 메서드를 참조하므로, 내부슬롯 `[[HomeObject]]` 를 갖는 **ES6 메서드는 `super` 키워드를 사용할 수 있다.**
    
    ```jsx
    const base = {
    	name: 'KMin',
    	sayHi() {
    		return `Hi! ${this.name}`
    	}
    }
    
    const derived = {
    	__proto__: base,
    	sayHi() {
    		return `${super.sayHi()}, how are you doing?`
    	}
    }
    
    console.log(derived.sayHi()) // Hi! KMin, how are you doing?
    ```
    
    ES6 메서드가 아닌 함수는 `super` 키워드를 사용할 수 없다.
    ES6 메서드가 아닌 함수는 내부슬롯 `[[HomeObject]]` 를 갖지 않기 때문이다.
    

# 26.3 화살표함수

---

화살표함수는 `function` 키워드 대신 화살표( ⇒ ) 를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의할 수 있다.

## 26.3.1 화살표 함수 정의

### 함수 정의

화살표 함수는 함수 선언문으로 정의할 수 없고 함수 표현식으로 정의해야 한다.

```jsx
const multiply = (x, y) => x * y
```

### 매개변수 선언

- 매개변수가 한개인 경우 소괄호를 생략할 수 있고
- 매개변수가 2개 이상이면 소괄호 안에 매개변수를 선언하며,
- 매개변수가 없으면 소괄호를 생략할 수 없다.

```jsx
const arrow = () => { ... }
const arrow = x => { ... }
const arrow = (x, y) => { ... }
```

### 함수 몸체 정의

- 함수 몸체가 하나의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 {} 를 생략할 수 있다.
- 함수 몸체가 여러 개의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 {} 를 생략할 수 없다.
- 객테 리터럴을 반환하는 경우는 객체 리터럴을 소괄호로 감싸주어야 한다.
- 화살표 함수도 즉시실행 함수로 사용할 수 있다.
    
    ```jsx
    const person = (name => ({
    	sayHi() { return `Hi? My name is ${name}` }
    }))('KMin')
    
    console.log(person.sayHi()) // Hi? My name is KMin
    ```
    

## 26.3.2 화살표 함수와 일반 함수의 차이

1. **화살표 함수는 인스턴스를 생성할 수 없는 non-constructor 다.**
    1. 화살표 함수는 인스턴스를 생성할 수 없으므로 `prototype` 프로퍼티가 없고 프로토타입도 생성하지 않는다.
2. **중복된 매개변수 이름을 선언할 수 없다.**
3. **화살표 함수는 함수 자체의 this, arguments, super, [new.target](http://new.target) 바인딩을 갖지 않는다.**
    1. 따라서 화살표 함수 내부에서 this, arguments, super, [new.target](http://new.target) 을 참조하면 스코프 체인을 통해 상위 스코프의 this, arguments, super, new.target 을 참조한다.
    2. 만약 화살표함수가 중첩되어 있다면 그 위에위에 스코프 체인상에서 가장 가까운 상위 함수 중 화살표 함수가 아닌 함수의 this, arguments, super, [new.target](http://new.target) 을 참조한다.

## 26.3.3 this

화살표 함수가 일반 함수와 가장 구별되는 것은 `this` 다.

기존의 `this` 바인딩은 함수의 호출방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다. 
이로인해 의도치않은 문제들이 발생하고 이 때문에 ES6 에서는 “콜백 함수 내부의 this 문제"를 해결했다.

```jsx
class Prefixer {
	constructor(prefix) {
		this.prefix = prefix
	}

	add(arr) {
		return arr.map(item => this.prefix + item)
	}
}

const prefixer = new Prefixer('-webkit-')
console.log(prefixer.add(['transition', 'user-select']))
// ['-webkit-transition', '-webkit-user-select']
```

**화살표 함수는 함수 자체의 `this` 바인딩을 갖지 않는다.
따라서 화살표 함수 내부에서 `this` 를 참조하면 사우이 스코프의 `this` 를 그대로 참조한다.**

**⇒ 이를 lexical this 라 한다.**

( 이는 마치 렉시컬 스코프와 같이 화살표 함수의 `this` 가 함수가 정의된 위치에 의해 결정된다는 것을 의미한다. )

- 만약 화살표 함수가 전역 함수라면 화살표 함수의 `this` 는 전역 객체를 가리킨다.
전역 함수의 상위 스코프는 전역이고 전역에서 `this` 는 전역 객체를 가리키기 때문이다.
    
    ```jsx
    // 전역 함수 foo 의 상위 스코프는 전역이므로 화살표 함수 foo 의 this 는 전역 객체를 가리킨다.
    const foo = () => console.log(this)
    foo() // window
    ```
    
    ```jsx
    // increase 프로퍼티에 할당한 화살표 함수의 상위 스코프는 전역이다.
    // 따라서 increase 프로퍼티에 할당한 화살표 함수의 this 는 전역 객체를 가리킨다.
    const counter = {
    	num: 1,
    	increase: () => ++this.num
    }
    
    console.log(counter.increase()) // NaN
    ```
    
- 화살표 함수는 함수 자체의 `this` 바인딩을 갖지 않기 때문에, [Function.prototype.call/apply/bind](http://Function.prototype.call/apply/bind) 메서드를 사용해도 화살표 함수 내부의 `this` 를 교체할 수 없다.
    
    ```jsx
    window.x = 1
    
    const normal = function() { return this.x }
    const arrow = () => this.x
    
    console.log(normal.call({ x: 10 })) // 10
    console.log(arrow.call({ x: 10 })) // 1 
    ```
    
    > 화살표 함수는 함수 자체의 `this` 바인딩을 갖지 않으므로 `this` 를 교체할 수 없고 언제나 상위 스코프의 `this` 바인딩을 참조한다.
    > 

- 메서드를 화살표 함수로 정의하는 것은 피해야 한다.
    
    ```jsx
    // Bad
    const person = {
    	name: 'KMin',
    	sayHi: () => console.log(`Hi! ${this.name}`)
    }
    
    /**
    	sayHi 프로퍼티에 할당된 화살표 함수 내부의 this 는 상위 스코프의 전역인 this 가 가리키는 전역객체를 가리키므로,
    	이 예제를 브라우저에서 실행하면 this.name 은 window.name 과 같고 이는 undefined 다.
    */
    person.sayHi() // Hi!
    ```
    
    위 예제의 경우 sayHi 프로퍼티에 할당한 화살표 함수 내부의 `this` 는 메서드를 호출한 객체인 person 이 아니라 전역 객체  window 를 가리키기 때문에, 화살표 함수로 메서드를 정의하는 것은 바람직하지 않다.
    메서드를 정의할 때는 ES6 메서드 축약 표현으로 정의한 ES6 메서드를 사용하는 것이 좋다.
    
    ```jsx
    // Good
    const person = {
    	name: 'KMin',
    	sayHi() {
    		console.log(`Hi ${this.name}`)
    	}
    }
    
    person.sayHi() // Hi KMin
    ```
    

- 클래스 필드 정의 제안을 사용하여 클래스 필드에 화살표 함수를 할당할 수도 있다.
    
    ```jsx
    // Bad
    class Person {
    	// 클래스 필드 정의 제안
    	name = 'KMin'
    	sayHi = () => console.log(`Hi ${this.name}`)
    }
    
    const person = new Person()
    person.sayHi() // Hi KMin
    ```
    
    이때 sayHi 클래스 필드에 할당한 화살표 함수 냉부에서 `this` 를 참조하면 상위 스코프의 `this` 바인딩을 참조하므로, sayHi 클래스 필드에 할당한 화살표 함수의 상위 스코프는 인스턴스 프로퍼티다.
    
    따라서 다음과 같은 의미가 된다.
    
    ```jsx
    class Person {
    	constructor() {
    		this.name = 'KMin'
    		// 클래스가 생성한 인스턴스(this)의 sayHi 프로퍼티에 화살표 함수를 할당한다.
    		// 따라서 sayHi 프로퍼티는 인스턴스 프로퍼티다.
    		this.sayHi = () => console.log(`Hi ${this.name}`)
    	}
    }
    ```
    
    sayHi 클래스 필드에 할당한 화살표 함수의 상위 스코프는 사실 ‘클래스 외부'다.
    그러나 `this` 는 클래스 외부의 `this` 를 참조하지 않고 클래스가 생성할 인스턴스를 참조하게 된다.
    따라서 sayHi 클래스필드에 할당한 화살표함수 내부의 `this` 는 constructor 내부의 `this` 바인딩과 같은 셈이다.
    
    따라서 클래스에서 메서드를 정의할 때도 역시 ES6 메서드를 사용하는 것이 좋다.
    
    ```jsx
    // Good
    class Person {
    	// 클래스 필드 정의
    	name = 'KMin'
    	sayHi () {
    		console.log(`Hi ${this.name}`)
    	}
    }
    
    const person = new Person()
    person.sayHi() // Hi KMin
    ```
    

## 26.3.4 super

화살표 함수는 함수 자체의 super 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 super 를 참조하면 `this` 와 마찬가지로 상위 스코프의 super 를 참조한다.

```jsx
const Base = {
	constructor(name) {
		this.name = name
	}
	sayHi() {
		return `Hi! ${this.name}`
	}
}

class Derived extends Base {
	// 화살표 함수의 super 는 상위 스코프인 constructor 의 super 를 가리킨다.
	sayHi = () => `${super.sayHi()} how are you doing?`
}

const derived = new Derived('KMin')
console.log(derived.sayHi()) // Hi! Kmin how are you doing?
```

super 는 내부 슬롯 [[HomeObject]] 를 갖는 ES6 메서드 내에서만 사용할 수 있는 키워드다.
sayHi 클래스 필드에 할당한 화살표함수는 ES6 메서드는 아니지만, 함수 자체의 super 바인딩을 갖지 않으므로, 상위 스코프인 constructor 의 super 바인딩을 참조했다.

## 26.3.5 arguments

화살표 함수는 함수 자체의 arguments 바인딩을 갖지 않으므로, `this` 와 마찬가지로 상위 스코프의 arguments 를 참조한다.

```jsx
(function() {
	// 화살표 함수 foo 의 arguments 는 상위 스코프인 즉시 실행 함수의 arguments 를 가리킨다.
	const foo = () => console.log(arguments) // [Arguments] { '0': 1, '1': 2 }
	foo(3, 4)
}(1, 2))

// 화살표 함수 foo 의 arguments 는 상위 스코프인 전역의 arguments 를 가리킨다.
// 하지만 전역에는 arguments 객체가 존재하지 않는다.
const foo = () => console.log(arguments)
foo(1, 2) // ReferenceError: arguments is not defined
```

화살표 함수는 상위 스코프의 arguments 객체를 참조할 수는 있지만, 화살표 함수 자신에게 전달된 인수 목록을 확인할 수 없고 상위 함수에게 전달된 인수 목록을 참조하므로 그다지 유용하지 않다.

따라서 화살표 함수로 가변 인자 함수를 구현해야 할 때는 반드시 `Rest 파라미터` 를 사용해야 한다.

# 26.4 Rest 파라미터

---

## 26.4.1 기본 문법

Rest 파라미터(나머지 매개변수)는 매개변수 이름 앞에 세개의 점 `...` 을 붙여서 정의한 매개변수를 말한다.

**Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다**

```jsx
function foo(...rest) {
	// 매개변수 rest 는 인수들의 목록을 배열로 전달받는 Rest 파라미터다.
	console.log(rest) // [1, 2, 3, 4, 5]
}

foo(1, 2, 3, 4, 5)
```

일반 매개변수와 Rest 파라미터는 함께 사용할 수 있다.

이때 함수에 전달된 인수들은 매개변수와 Rest 파라미터에 순차적으로 할당된다.

```jsx
function foo(param, ...rest) {
	console.log(param) // 1
	console.log(rest) // [2, 3, 4, 5]
}

foo(1, 2, 3, 4, 5)
```

- 또한 Rest 파라미터는 항상 매개변수의 마지막에 써야 한다.
ex) function (...rest, param1, param2) 처럼은 못쓴다.
- Rest 파라미터는 단하나만 선언할 수 있다.
- Rest 파라미터는 함수 정의시 선언한 매개변수 개수를 나타내는 함수 객체의 `length` 프로퍼티에 영향을 주지 않는다.
    
    ```jsx
    function foo(...rest) {}
    console.log(foo.length) // 0
    
    function bar(x, ...rest) {}
    console.log(bar.length) // 1
    
    function baz(x, y, ...rest) {}
    console.log(baz.length) // 2
    ```
    

## 26.4.2 Rest 파라미터와 arguments 객체

ES5 에서는 함수를 정의할 때 매개변수의 개수를 확정할 수 없는 가변 인자 함수의 경우 `arguments` 객체를 활용했지만,
arguments 객체는 유사 배열 객체이기 때문에 [Function.prototype.call](http://Function.prototype.call) 이나 Function.prototype.apply 메서드를 사용해 배열로 변환해서 사용하는 번거로움이 있었다.

ES6 에서 Rest 파라미터를 사용하면 가변 인자 함수의 인수 목록을 배열로 직접 전달받을 수 있어 편하다.

화살표 함수에서는 자체의 arguments 객체를 가지지 않기 때문에 가변 인자 함수를 구현할 때는 반드시 Rest 파라미터를 사용해야 한다!

# 26.5 매개변수 기본값

---

함수를 호출할 때 매개변수의 개수만큼 인수를 전달하지 않으면 undefined 가 되기 때문에 의도치 않은 에러가 발생할 수 있다.

따라서 매개변수에 인수가 전달되지 않을 것을 고려해 매개변수에 기본값을 할당할 수 있다.

```jsx
function sum(x = 0, y = 0) {
	return x + y
}

console.log(sum(1, 2)) // 3
console.log(sum(1)) // 1
```

> **오늘 알게된 것 TIL (2022.03.24)**
> 
> 
> ---
> 
> 1. ES5 까지는 함수의 구분이 없었지만 이로 인해 불필요한 프로토타입을 생성하는 등 성능상의 문제가 있었기 때문에 ES6 부터 함수들을 구분해놓았다는 것을 알았다.
> 2. 일반 함수는 함수를 호출하는 방식, 즉 누가 호출하냐에 따라서 (일반함수, 메서드, 생성자함수) `this` 가 달라졌지만, 화살표함수는 함수 자체의 `this` 바인딩을 갖지 않기 때문에 상위 스코프의 `this` 를 따라간다.
> 3. Rest 파라미터를 쓰면 가변인자들을 바로 배열로 받을 수 있기 때문에 arguments 객체를 사용하는 것보다 편하고, 또한 화살표함수에서는 arguments 를 직접 갖지 않기 때문에 Rest 파라미터가 유용할 수 있다는 것을 알았다.