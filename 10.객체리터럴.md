# 10. 객체 리터럴 - 22.02.27

---

## 용어

🖊️**프로퍼티(data)** : 객체의 상태를 나타내는 값

🖊️**메서드(behavior)** : 프로퍼티를 참고하고 조작할 수 있는 동작

🖊️**인스턴스** : 클래스에 의해 생성되어 메모리에 저장된 실체

---

---

## 객체란?

객체란 원시값을 제외한 나머지 값(함수, 배열, 정규 표현식 등) 

객체 타입은 다양한 타입의 값을 하나의 단위로 구성한 자료구조

| 원시 타입 | 객체 타입 |
| --- | --- |
| 단 하나의 값 | 다양한 타입의 값 |
| 변경 불가 | 변경 가능 |

객체는 프로퍼티와 메서드로 구성된 집합체이다

<aside>
❓ **객체와  함수
자바스크립트에서는 함수도 객체이다**

</aside>

## 객체 리터럴에 의한 객체 생성

자바스크립트는 프로토타입 기반 객체지향 언어로서 다양한 객체 생성 방법을 지원한다

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스

**⇒ 보통 객체 리터럴을 사용**

### 객체 리터럴

객체를 생성하기 위한 표기법

객체 리터럴을 사용하며 객체를 생성함과 동시에 프로퍼티를 만들 수 있고,
객체를 생성한 이후에도 프로터피를 동적으로 추가할 수 있음
변수 할당되는 시점에 자바스립트 엔진은 객체 리터럴을 해석해서 객체를 생성함

```jsx
var person ={
	name : 'lee',
	sayHello : function () {
		consoel.log('hello, ${this.name}');
	}
}; **//객체 리터럴의 닫는 중괄호 뒤에는 세미콜론을 붙임**

console.log(typeof person); //object
console.log(person); //{name : "lee", sayHello : f}
```

## 프로퍼티

객체의 데이터 아이템

- **프로퍼티 키** : 빈 문자열을 포함하는 모든 문자열 또는 심벌 값
- **프로퍼티 값** : 자바스크립트에서 사용할 수 있는 모든 값

```jsx
var person ={
	//name 은 프로퍼티 키, 'lee'는 프로퍼티 값
	name : 'lee', **//프로터피를 나열할 때는 쉼표로 구분**
}; 
```

### 프로퍼티 키

프로퍼키 값에 접근할 수 있는 이름으로, 식별자 역할을 함

식별자 네이밍 규칙에 따라 문자열 사용하는 것이 일반적이다($ , _ 가능)

🔴 식별자 네이밍에 따르지 않는 이름에는 반드시 **따옴표를 사용**해야 함

```jsx
var person ={
	firstName : 'name', 
	'last-name' : 'lee'
}; 
console.log(person); {firstName : "name" , last-name : "lee"}
```

🔴 프로퍼티 키를 **동적으로 생성** 할 수 있다

```jsx
var obj = {};
var key = 'hello';

**//대괄호 [...]를 사용**
obj[key] = 'world!';

console.log(obj); //{hello : world!}
```

🔴 프토퍼티 키를 **빈 문자열**로도 생성 가능 ⇒ 권장하진 않음(별 의미가 없음)

```jsx
var foo ={
	'' : ''
};
console.log(foo); {"" : ""}
```

🔴 프로퍼티 키에 문자열이나 심벌 값 외의 값을 사용하면 문자열로 암묵적 타입 변환

```jsx
var foo ={
	0 : 0,
	1 : 1,
	2 : 2
};
**//따옴표는 안 붙는데 문자열로 변환됨**
console.log(foo); {0 : 0, 1 : 1, 2 : 2}
```

🔴 예악어 써도 에러 발생 안함 ⇒ 근데 쓰지 마라

🔴 중복 선언 시 나중에 선언한 프로퍼티가 할당 됨

```jsx
var person ={
	firstName : 'name', 
	firstName : 'first', 
}; 
console.log(person); //{firstName : "first"}
```

### 프로퍼티 접근

<aside>
👉 **마침표 표기법** : 마침표 프로퍼티 접근 연산자
**대괄호 표기법** : 대괄호 프로퍼티 접근 연산

</aside>

대괄호 표기법은 [’프로퍼티 키’] 롤 ‘’따옴표를 쓴다
⇒ 안쓰면 존재하지 않는 프로퍼티로 인식하고 undefined 반환 함

```jsx
var person ={
	name : 'name', 

}; 
console.log(person.name); //마침표
console.log(person['name']); //대괄호
```

### 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신

```jsx
var person ={
	name : 'name', 
}; 
person.name = 'lee';
```

### 프로터피 동적 생성

```jsx
var person ={
	name : 'name', 
}; 
person.age = 20;
console.log(person); //{name: "lee", age : 20}
```

### 프로퍼티 삭제

delete 연산자로 객체의 프로퍼티를 삭제한다

존재하지 않는 프로퍼티 삭제해도 에러없이 무시됨

```jsx
var person ={
	name : 'name', 
	age : 20
}; 
delete person.age; //age 프로퍼티 삭제
```

## 메서드

데이터를 가지고 뭔가 일을 할 수 있게 됨

자바스크립트의 함수는 객체

프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라고 부름

```jsx
var person ={
	name : 'lee',
	sayHello : function () { <- 메서드
		consoel.log('hello, ${this.name}'); // this는 person임
	}
}; 
console.log(typeof person); //object
console.log(person); //{name : "lee", sayHello : f}
```

## 추가된 객체 리터럴의 확장 기능

### 프로퍼티 축약 표현

프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키 이름이 동일하면
**프로퍼티 키를 생략 가능**

```jsx
var x = 1, y = 1;
var obj = {
	x : x,
	y : y
};
====를
const obj = {x, y};
로 간단하게 
```

### 계산된 프로퍼티 이름

타입 변환될 수 있는 값으로 평가되는 표현식을 사용해 **프로퍼티 키를 동적으로 생성**

```jsx
var prefix = 'prop';
var i = 0;

var obj = {};

obj[prefix + '-' + ++i] = i; //prop-1 : 1

======
var obj = {
	[`${prefix}-${++i}]: i,
	...
};

```

### 메서드 축약 표현

function 키워드를 생략한 표현 사용 

```jsx
var person ={
	name : 'lee',
	sayHello() { 
		consoel.log('hello, ${this.name}');
	}
}; 
person.sayHello();
```

> **2020-02-27 TIL**
1. 지금까지 객체 선언할 때 쓴건 객체 리터럴임
****2. 객체는 프로터피와 메서드의 집합
3. 식별자 네이밍에 따르지 않는 프로퍼티키는 따옴표로 선언 가능
4. 프로퍼티 키도 문자열과 symbol만 되는데 이외의 타입일 경우 문자열로 타입변환
5. 프로퍼티 삭제할 때 delete object.props
>