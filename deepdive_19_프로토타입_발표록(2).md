# 발표문 - 19장 프로토타입 (2)


# 꽁치님

아예 이해할수 없기에 간략한 내용만 설명한다.


- 생성자 함수, 객체 리터럴 등으로 객체를 생성하면 `**[[Prototype]]**` 내부 슬롯에 프로퍼티가 할당된다.
- `**new 생성자**` 함수로 할당하면 해당 생성자 함수의 `**prototype`** 을 프로토타입으로 가진다.
- 프로토타입 체인은 거슬러 거슬러 올라가서 자신의 조상까지 프로토타입을 물려받는 것을 말한다.
- 프로토타입의 최상위 종점은 결국 `**Object.prototype**` 이다.
- `**프로토타입**`프로퍼티와 인스턴스 프로퍼티가 있다면 인스턴스 프로퍼티가 당근 우선 적용되고, `**프로토타입**`프로퍼티를 변경, 삭제하려면 직접 그 프로퍼티에 접근해서 변경, 삭제 해야 한다.
- `**프로토타입**`을 동적으로 임의로 다른 객체로 변경할 수 있다.

# 명성님

1. 추상 연산이라는 존재를 알게 되었습니다.
    1. 일종의 함수같은 것이나 자바스크립트 엔진의 실행환경이다.
    2. 내부 동작의 구현 알고리즘을 표현한 것이다.
2. 전역객체가 브라우저환경에서는 window인 것과 서버환경에서는 global로 다르다는 것을 알게 되었습니다. 
3. Object라는 빌트인 생성자 함수의 prototype을 대대손손 객체들에게 물려준다는 것을 알게 되었습니다.

# 뽀또님

- 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.
    - 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입은 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재하기 때문이다.

```jsx
**애한님의 부가적인 설명**
생성자 함수는 모두 하나의 프로퍼티를 가집니다. 
이 프로퍼티는 프로토타입 이므로 프로토타입과 
생성자함수는 항상 쌍으로 존재한다.
생성자 함수든 리터럴객체를 선언해서든 해서 함수객체를 선언하게되면. 
함수객체의 생성과 동시에 프로토타입이 같이 생성됩니다.
때문에 함수객체가 존재하면 프로토타입이 같이 있을수 밖에 없다
```

- 빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성된다.
- 전역 객체는 클라이언드 사이드 환경에서는 `**window**` , 서버사이드 환경에서는 `**global**` 객체를 의마한다.
- 객체 리터럴과 `**Object**` 생성자 함수에 의한 객체 생성 방식의 차이는 프로퍼티를 추가하는 방식에 있다.
    - **객체 리터럴** : 객리 리터럴 내부에 프로퍼티 추가
    - **Object 생성자 함수** : 빈 객체를 생성한 이후 프로퍼티 추가

### 프로토타입 체인 ?

- 자바스크립트는 객체의 프로퍼티에 접근하려고 할때 해당 객체에 저근하려는 프로퍼티가 없다면 내부 슬롯의 참조를 따라 자신의 부모역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라 한다.

### 프로퍼티 섀도잉 ?

- 상속 관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 섀도잉 이라고 한다.

### 오버라이딩

- 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식이다.

### 오버로딩

- 함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메서드를 구현하고 매개변수에 의해 메서드를 구별하여 호출하는 방식이다.

### 프로토타입의 교체

- `**__proto__**`접근자 프로퍼티 또는 **`Object.setPrototypeOf`** 메서드를 통해 프로토타입을 교체할 수 있다.

```jsx
Object.setPrototypeOf(me , parent)
```

# 너두님

## 프로토타입의 생성시점

### 알게된것

- 프로토타입과, 생성자 함수는 동시에 생성되며 항상 두개가 공존한다.
빌트인 함수는 생성자 함수이다.
- 호이스팅 시점에  프로토타입이 생성된다.

### 모르겠는것

- 교과서에 그림 화살표 방향은 가리키는 것인지 포함되어 있음을 의미하는 것인지 모르겠음
- 객체 생성 방식과 프로토타입의 결정

### 알게된점

- 객체는 추상연산 : `**OrdinaryObjectCreate**`에 의해 생성된다

### 모르겠는점

- 화살표 뜻을 정확하게 모르겠다(몇개는 이해함)

## 프로토타입 체인

### 알게된점

- 프로토타입 체인의 과정
- call

## 오버라이딩과 프로퍼티 섀도잉

### 알게된점

### 섀도잉

- 프로토타입에 대한 이해가 증가

### 모르겠는점

- 오버라이딩은 상속과 비슷한가
- 오버로딩은 new와 비슷한가

```jsx
1. 오버로딩(overloading)

오버로딩은 같은 메소드라도 매개변수만
다르면 얼마든지 정의하고 사용할 수 있다.

특징:
1) 메소드 이름이 같아야 한다.
2) 리턴형이 같아도 되고 달라도 된다.
3) 파라미터 개수가 달라야 한다 .
4) 파라미터 개수가 같을 경우, 데이터타입이 달라야 한다.
* 리턴타입은 시그니처에 포함되지 않기 때문에 주의. 컴파일 에러 발생.

```

```jsx
오버라이딩(overriding)

- 상속 관계에 있는 클래스 간에 같은 이름의 메소드를 정의하는 기술이다.
- 만약 자식클래스가 부모클래스에서
	선언된 것과 같은 메소드를 가질 때, 메소드 오버라이딩이라고 한다.
```

**자스는 없으니까 패스 ! 개념만 알자**

![Untitled 1](https://user-images.githubusercontent.com/34502254/157694600-4f11dc03-50b8-40a0-a2d7-0d793c92beb9.png)


# 애한님

- 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다
- 프로토타입 체인은 자바스크립트가 객체 지향 프로그래밍의 상속을 구현하는 메커니즘이다.
- 스코프체인과 프로토타입 체인은 서로 협력하여 식별자와 프로퍼티를 검색하는데 사용된다.

```jsx
**스코프체인**
자바스크립트 엔진은 식별자를 찾을 때 자신이 속한 스코프에서 찾고
그 스코프에 식별자가 없으면 상위 스코프에서 다시 찾아 나간다.
이 현상을 스코프 체인이라 하며,
스코프가 중첩되어 있는 모든 상황에서 발생한다.

var x = 1;

function foo() {
	console.log(x) ; // 지금 x는 없지만 상위 스코프 전역에서 x를 찾는다.
}

console.log(x); //1
foo(); // 1
```

![Untitled 2](https://user-images.githubusercontent.com/34502254/157694649-540a9b51-41c9-402e-bb74-f164eb1879f3.png)


### 렉시컬 스코프

- **렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정된다.**
    - 자바스크립트는 렉시컬 스코프를 따르므로 함수를 선언한 시점에 상위 스코프가 결정된다. 함수를 어디에서 호출하였는지는 스코프 결정에 아무런 의미를 주지 않는다.

```jsx
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

# 초생님

- 프로토 타입도 객체이므로 프로토 타입 자신도 프로토 타입을 가짐
- 프로토타입에 프로토타입에 포로토타입에 포로토타입에 프로토타입에 프로토타입에 프로토타입에 프로토타입에 프로토타입에 프로토타입에
- 사용자 정의 생성자 함수는 런타임 이전에 실행되어 함수 객체가 되는데 프로토 타입도 이때 생성됨 그래서 프로토타입이 사용자 정의 생성자 함수의 프로토타입 프로퍼티에 바인딩이 된다.
- 빌트인은 전역 객체가 생성되는 시점에 생성됨 그래서 객체가 생성되기 전에 생성자 함수랑 프로토타입이 이미 객체화 되어서 있고, 객체를 생성하면 내부 슬롯에 프로토타입이 할당되어 상속 받는 거다.

### 내부슬롯 접근 방법

**`Object.getOwnPropertyDescriptor`**

모든 객체 [[Prototype]] 내부 슬롯 직접 접근 불가능, __proto__로 접근 가능
