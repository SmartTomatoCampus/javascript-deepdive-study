# [JavaScript] 함수(2)

## 참조에 의한 전달과 외부 상태의 변경

---

<aside>
💻 11장 “원시 값과 객체의 비교"에서 보았듯, 원시값은 ‘값에 의한 전달', 객체는 ‘참조에 의한 전달' 방식으로 동작한다

함수를 호출하면서 매개변수에 ‘값'을 전달하는 방식을 ‘값에 의한 호출’, ‘참조에 의한 호출'로 구별해서 부르기도 하나
동작 방식은 값에 의한 전달, 참조에 의한 전달과 동일하다

</aside>

```jsx
// 매개변수 Primitive 는 원시 값을 전달받고, 매개변수 obj 는 객체를 전달받는다
function changeVal(primitive, obj) {
	primitive += 100
	obj.name = 'KMin'
}

// 외부 상태
var num = 100
var person = { name: 'Choi' }

console.log(num)    // 100
console.log(person) // { name: 'Choi' }

// 원시 값은 값 자체가 복사되어 전달되고 객체는 참조 값이 복사되어 전달된다
changeVal(num, person)

// 원시 값은 원본이 훼손되지 않는다
console.log(num)

// 객체는 원본이 훼손된다.
console.log(person) // { name: 'KMin' }
```

> `changeVal` 함수는 매개변수를 통해 전달받은 원시값과 객체값 인수를 함수 몸체에서 변경한다
> 
> 
> 엄밀히 말해 원시값을 전달받은 primitive 의 경우, 원시값은 ‘직접 변경이 불가'하므로 재할당을 통해 할당된 원시값을 새로운 원시값으로 교체했고,
> 
> 객체값 인수를 받은 obj 의 경우, 객체는 변경 가능한 값이므로 직접 변경할 수 있기 때문에 재할당 없이 직접 할당된 객체를 변경했다.
> 
> ---
> 
> 1. **즉 원시 타입 인수는 값 자체가 복사되어 매개변수에 전달되므로 값을 변경해도 원본은 훼손되지 않는다.**
> 2. **반면 객체 타입 인수는 참조 값이 복사되어 매개변수에 전달되므로, 참조 값을 통해 객체를 변경하면 원본이 훼손된다.**

<aside>
💻 이에 대한 해결 방법 중 하나는 객체를 **불변 객체(immutable object)**로 만들어 사용하는 것

---

깊은 복사를 통해서 새로운 객체를 생성하고 재할당을 통해 교체함으로써 부수 효과를 없앨 수 있다.

외부상태를 변경하지도, 외부상태에 의존하지도 않는 함수를 ‘순수 함수'라고 하며,
순수 함수를 통해 부수효과를 최대한 억제하여 프로그래미의 안정성을 높이려는 패러다임을, **함수형 프로그래밍**이라고 한다.

</aside>

## 다양한 함수의 형태

---

### 즉시 실행 함수

- 즉시 실행 함수는 단 한번만 호출되며 다시 호출할 수 없다

```jsx
// 익명 즉시 실행 함수
(function () {
	var a = 3
	var b = 5
	return a * b
}())
```

- 즉시 실행 함수는 익명 함수를 사용하는 것이 일반적이다
- 그룹연산자 `()` 내의 기명함수는 함수 선언문이 아닌 함수 리터럴로 평가되고,
함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자이므로 즉시 실행함수를 다시 호출할 수 없다
    
    ```jsx
    // 기명 즉시 실행 함수
    (function foo() {
    	var a = 3
    	var b = 5
    	return a * b
    }())
    
    foo()  // ReferenceError: foo is not defined
    ```
    

- 즉시 실행함수는 반드시 그룹 연산자 `()` 로 감싸야 하며, 그렇지 않으면 에러가 발생한다
    
    ```jsx
    function() {
    	...
    }()    // SyntaxError: Function Statement require a function name
    ```
    
    → 이는 함수 정의가 함수 선언문의 형식에 맞지 않기 때문이며, 함수 선언문은 함수 이름을 생략할 수 없다
    
    ```jsx
    function foo() {
    	...
    }() // SyntaxError: Undexpected token ')'
    ```
    
    → 위의 코드 또한 자바스크립트 엔진이 암묵적으로 수행하는 세미콜론 자동삽입 기능에 의해서 에러가 난다
    
    → `function foo() {};();` 처럼 함수 코드 블록의 닫는 중괄호 뒤에 `;` 이 암묵적으로 추가되기 때문
    

```jsx
console.log( typeof (function f(){}) ) // function
console.log( typeof (function (){}) )  // function
```

- 즉 그룹연산자로 함수를 묶은 이유는, 먼저 함수 리터럴을 평가해 함수 객체를 생성하기 위함이다.

```jsx
// 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있다
var res = (function () {
	var a = 3
	var b = 5
	return a * b
}())

// 즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있다
res = (function (a, b) {
	return a * b
}(3, 5))
```

### 재귀 함수

- 함수가 자기 자신을 호출하는 것을 **재귀 호출(recursive call)**이라고 한다
- **재귀 함수(recursive function)**는 자기 자신을 호출하는 함수를 말한다

- 재귀 함수는 반복되는 처리를 위해 사용한다
    
    ```jsx
    // 재귀 함수 X
    function countdown(n) {
    	for (var i = n; i >= 0; i--) console.log(i)
    }
    
    countdown(10)
    ```
    
    위처럼 선언할 수도 있고, 반복문 없이도 호출이 가능하다
    
    ```jsx
    // 재귀 함수 O
    function countdown(n) {
    	if (n < 0) return
    	console.log(n)
    	countdown(n - 1)
    }
    
    countdown(10)
    ```
    
    ⇒ 이처럼 재귀 함수를 사용하면 반복되는 처리를 반복문 없이 구현할 수 있다.
    
    ```jsx
    // 팩토리얼(계승)은 1부터 자신까지의 모든 양의 정수의 곱이다
    // n! = 1 * 2 * ... * (n-1) * n
    function factorial(n) {
    	// 탈출 조건: n이 1 이하일 떄 재귀 호출을 멈춘다
    	if (n <= 1) return 1
    	// 재귀 호출
    	return n * factorial(n-1)
    }
    
    console.log(fatorial(0)) // 0! = 1
    console.log(fatorial(1)) // 1! = 1
    console.log(fatorial(2)) // 2! = 2 * 1 = 2
    console.log(fatorial(3)) // 3! = 3 * 2 * 1 = 6
    console.log(fatorial(4)) // 4! = 4 * 3 * 2 * 1 = 24
    console.log(fatorial(5)) // 5! = 5 * 4 * 3 * 2 * 1 = 120
    ```
    
- 재귀 함수는 자신을 무한 호출하기 때문에 탈출 조건을 반드시 만들어야 한다

### 중첩 함수

- 함수 내부에 정의된 함수를 **중첩 함수(nested function)** 또는 **내부 함수(inner function)**라 한다.
- 중첩 함수는 외부 함수 내부에서만 호출할 수 있어서, 외부 함수를 돕는 헬퍼 함수(helper function)의 역할을 한다
    
    ```jsx
    functino outer() {
    	var x = 1
    
    	function inner() {
    		var y = 2
    		console.log(x + y)
    	}
    
    	inner()
    }
    
    outer()
    ```
    

<aside>
💻 ES6 부터 함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능하다!

ES6 부터 함수 내부 뿐만 아니라 if 문이나 for 문 등의 코드 블록 내에서도 정의할 수 있지만,
호이스팅으로 인한 혼란이 발생할 수 있으므로 if 문이나 for 문 등의 코드블록에서 함수 선언문을 통해 정의하는 것은 바람직하지 않다!!

</aside>

### 콜백 함수

```jsx
// n 만큼 어떤 일을 반복한다
function repeat1(n) {
	for (var i = 0; i < n; i++) console.log(i)
}

repeat1(5) // 0 1 2 3 4

// n 만큼 어떤 일을 반복한다
function repeat2(n) {
	for (var i = 0; i < n; i++) {
		if (i % 2) console.log(i)   // i 가 홀수일 떄만 출력한다
	}
}

repeat2(5) // 1 3
```

- 위의 코드처럼 함수의 일부분만 다를 때 공통 로직을 정해두고, 경우에 따라 변경되는 로직은 추상화해서 함수 외부에서 내부로 전달할 수 있다
    
    ```jsx
    // 외부에서 전달받은 f 를 n 만큼 반복 호출한다
    function repeat(n, f) {
    	for (var i = 0; i < n; i++) {
    		f(i)
    	}
    }
    
    var logAll = function (i) {
    	console.log(i)
    }
    
    var logOdds = function (i) {
    	if (i % 2) console.log(i)
    }
    
    repeat(5, logAll)   // 0 1 2 3 4
    repeat(5, logOdds)  // 1 3
    ```
    

> **이것이 콜백이다 희망편!!**
> 
> 
> ---
> 
> - 이처럼 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 **콜백 함수(callback function)**라고 한다
> - 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 **고차 함수(Higher-Order Function, HOF)**라고 한다
>     
>     ⇒ 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다
>     

### 순수 함수와 비순수 함수

- 함수형 프로그래밍에서는 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수효과가 없는 함수를 **순수 함수(pure function)**라 하고,
외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수효과가 발생하는 함수를 **비순수 함수(impure function)**라 한다
- 순수 함수의 특징
    
    ```jsx
    var count = 0
    
    functino increase(n) {
    	return ++n
    }
    
    // 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
    count = increase(count) // 1
    count = increase(count) // 2
    ```
    
    - 순수 함수는 동일한 인수 → 동일한 값을 반환
    - 함수의 외부 상태를 변경하지 않음
- 비순수 함수의 특징
    
    ```jsx
    var count = 0
    
    function increase() {
    	return ++count
    }
    
    // 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려움
    increase() // 1
    increase() // 2
    ```
    
    - 외부 상태에 따라 반환값이 달라짐
    - 외부 상태를 변경하는 부수효과 발생

<aside>
💻 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임!

- 로직 내에 존재하는 조건문 or 반복문을 제거해서 복잡성을 해결 ( 가독성 ↑ )
- 변수 사용을 억제하거나 생명주기를 최소화해서 상태 변경을 피해 오류를 최소화
</aside>