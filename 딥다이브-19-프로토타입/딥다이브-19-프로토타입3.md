# [JavaScript] 프로토타입 (3)

# instanceof 연산자

---

`instanceof` 연산자는 이항 연산자로서 좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다.

```jsx
객체 instanceof 생성자함수
```

**→ 우변의 생성자 함수의 prototype 에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true,
→ 그렇지 않은 경우는 false 로 평가된다.**

```jsx
function Person(name) {
	this.name = name
}
const me = new Person('KMin')

console.log(me instanceof Person) // true
console.log(me instanceof Object) // true
```

프로토타입을 교체할 경우

```jsx
const parent = {}

Object.setPrototypeOf(me, parent)

console.log(me instanceof Person) // false
console.log(me instanceof parent) // true
```

me 객체는 Person 생성자 함수의 인스턴스였지만 프로토타입을 parent 로 교체하자 parent 의 인스턴스가 되었다.

이번엔 parent 객체를 Person 생성자 함수의 프로토타입으로 교체한다면?

```jsx
Person.prototype = parent

console.log(me instanceof Person) // true
console.log(me instanceof parent) // true
```

⇒ 따라서 `instanceof` 연산자는 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수를 찾는 것이 아니라,
**생성자 함수의 prototype 에 바인됭된 객체가 프로토타입 체인 상에 존재하는지를 확인한다.**

# 직접 상속

---

## 1. Object.create 에 의한 직접 상속

`Object.create` 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다.
마찬가지로 추상 연산 OrdinaryObjectCreate 를 호출한다.

Object.create 의 매개변수

1. 첫번째 매개변수: 생성할 객체의 프로토타입으로 지정할 객체
2. 두번째 매개변수: 생략 가능. 생성할 객체의 프로퍼티 키와 프로퍼티 디스크립터 객체로 이뤄진 객체
(Object.defineProperties 메서드의 두번째 인수와 동일)

### ㄱ) 프로토타입이 null 인 객체를 생성한다. 생성된 객체는 프로토타입 체인의 종점에 위치한다.

```jsx
// obj → null
let obj = Object.create(null)
console.log(Object.getPrototypeOf(obj) === null) // true
// Object.prototype 을 상속받지 못한다
console.log(obj.toString()) // TypeError: obj.toString is not a function
```

### ㄴ) obj → Object.prototype → null

```jsx
// obj = {} 와 동일하다
obj = Object.create(Object.prototype)
console.log(Object.getPrototypeOf(obj) === Object.prototype) // true
```

### ㄷ) obj → Object.prototype → null

```jsx
// obj = { x: 1 } 와 동일하다
obj = Object.create(Object.prototype, {
	x: { value: 1, writable: true, enumerable: true, configurable: true }
})
// 위 코드는 아래와 동일하다
// obj = Object.create(Object.prototype)
// obj.x = 1
console.log(obj.x) // 1
console.log(Object.getPrototypeOf(obj) === Object.prototype) // true
```

### ㄹ) 임의의 객체를 직접 상속받는다.

```jsx
const myProto = { x: 10 }
// obj → MyProto → Object.prototype → null
obj = Object.create(myProto)
console.log(obj.x) // 10
console.log(Object.getPrototypeOf(obj) === myProto) // true
```

### ㅁ) 생성자 함수

```jsx
function Person(name) {
	this.name = name
}
// obj -> Person.prototype -> Object.prototype -> null
// obj -> newPerson('KMin') 과 동일하다
obj = Object.create(Person.prototype)
obj.name = 'KMin'
console.log(obj.name) // KMin
console.log(Object.getPrototypeOf(obj) === Person.prototype) // true
```

**⇒ 이처럼 `Object.create` 메서드는 첫번째 매개변수에 전달한 객체의 프로토타입 체인에 속하는 객체를 생성한다.**

**⇒ 즉, 객체를 생성하면서 직접적으로 상속을 구현한다.**

## 2. 객체 리터럴 내부에서 **proto** 에 의한 직접 상속

Object.create 메서드에 의한 직접 상속은 여러 장점이 있지만 두번째 인자로 프로퍼티를 정의하는 것이 꽤나 번거롭기 때문에
ES6 이후로 객체 리터럴 내부에서 `__proto__` 접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다.

```jsx
const myProto = { x: 10 }

// 객체 리터럴에 의해 객체를 생성하면서 프로토타입을 지정하여 직접 상속받을 수 있다.
const obj = {
	y: 20,
	// 객체를 직접 상속받는다.
	// obj → myProto → Object.prototype → null
	__proto__: myProto
}
```

# 정적 프로퍼티/메서드

---

정적(static) 프로퍼티/메서드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드를 말한다.

**생성자 함수가 소유한 프로퍼티/메서드를 정적 프로퍼티/메서드**라고 하며, **정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.**

⇒ Why? 오직 프로토타입 체인에 속한 프로퍼티/메서드를 쓸 수 있는거지,
생성자 함수가 소유한 정적 프로퍼티/메서드는 인스턴스로 접근할 수 없다.

1. 프로토타입 메서드
    
    ```jsx
    function Foo() {
    	Foo.prototype.x = function () {
    		console.log('x')
    	}
    }
    
    const foo = new Foo()
    
    foo.x() // x
    ```
    
    참조/호출 가능
    
2. 정적 메서드
    
    ```jsx
    Foo.x = function () {
    	console.log('x')
    }
    
    foo.x() // TypeError: foo.x is not a function
    
    Foo.x() // x
    ```
    
    생성자 함수가 직접 소유한 메서드는 인스턴스가 참조/호출할 수 없다
    하지만 정적 프로퍼티, 메서드는 인스턴스를 생성하지 않아도 호출할 수 없다.
    

# 프로퍼티 존재 확인

---

## 1. in 연산자

`in 연산자` 는 객채 내에 특정 프로퍼티가 존재하는지 여부를 확인한다.

```jsx
const person = {
	name: 'KMin',
	address: 'Seoul'
}

console.log('name' in person) // true
console.log('address' in person) // true
console.log('age' in person) // false
```

추가로 `in 연산자` 는 프로토타입의 프로퍼티까지 확인한다.

```jsx
console.log('toString' in person) // true
```

ES6 에 도입된 `Reflect.has` 메서드를 사용할 수도 있다.

```jsx
console.log(Reflect.has(person, 'name')) // true
```

## 2. Object.prototype.hasOwnProperty 메서드

`Object.prototype.hasOwnProperty` 메서드를 사용해도 객체에 특정 프로퍼티가 존재하는지 확인할 수 있다.

```jsx
console.log(person.hasOwnProperty('name')) // true
console.log(person.hasOwnProperty('age'))  // false
```

`Object.prototype.hasOwnProperty` 메서드는 전달받은 프로퍼티 키가 객체의 고유 프로퍼티 키인 경우에만 true 를 반환한다.

```jsx
console.log(person.hasOwnProperty('toString')) // false
```

# 프로퍼티 열거

---

## 1. for...in 문

객체의 모든 프로퍼티를 순회하며 열거하려면 `for...in문` 을 사용한다.

```jsx
const person = {
	name: 'KMin',
	address: 'Seoul'
}

for (const key in person) {
	console.log(`${key} : ${person[key]}`)
}

// name : KMin
// address : Seoul
```

> `**for...in 문` 은 in 연산자처럼 해당 객체의 프로퍼티 뿐만 아니라 상속받은 프로토타입의 프로퍼티까지 열거한다.**
> 
> 
> ```jsx
> const person = {
> 	name: 'KMin',
> 	address: 'Seoul'
> }
> 
> console.log('toString' in person) // true
> 
> for (const key in person) {
> 	console.log(`${key} : ${person[key]}`)
> }
> 
> // name : KMin
> // address : Seoul
> ```
> 
> 그런데 여기서 Object.prototype 에 있는 ‘toStrint’ 메서드가 열거되지 않는 이유는,
> toString 메서드의 프로퍼티 어트리뷰트 [[Enumerable]] 의 값이 false 이기 때문!!
> 
> ( 프로퍼티 어트리뷰트 [[Enumerable]] 은 프로퍼티의 열거 가능 여부를 나타낸다 )
> 
> **⇒ 즉 `for...in 문` 은 프로토타입 체인 상에서 [[Enumerable]] 이 true 인 모든 프로퍼티를 순회하며 열거한다!!**
> 

추가로 배열은 `for` 문이나 `for...of 문` 또는 `Array.prototype.forEach` 메서드를 사용하기를 권장한다.
사실 배열도 객체이므로 프로퍼티와 상속받은 프로퍼티가 포함될 수 있다.

```jsx
cosnt arr = [1, 2, 3]
arr.x = 10 // 배열도 객체이므로 프로퍼티를 가질 수 있다.

for (const i in arr) {
	console.log(arr[i]) // 1 2 3 10 프로퍼티 x도 출력된다
}

// arr.length 는 3이다.
for (let i = 0; i < arr.length; i++) {
	console.log(arr[i]) // 1 2 3
}

// forEach 메서드는 요소가 아닌 프로퍼티는 제외한다.
arr.forEach(v ⇒ console.log(v)) // 1 2 3

// for...of 는 변수 선언문에서 선언한 변수에 키가 아닌 값을 할당한다
for (const value of arr) {
	console.log(value) // 1 2 3
}
```

## 2. Object.keys/values/entries 메서드

객체 자신의 고유 프로퍼티만 열거하기 위해서는 `for...in문` 보다는 `Object.keys / .values / .entries` 메서드를 사용하는 것이 좋다

- `Object.keys` 메서드는 객체 자신의 열거 가능한 프로퍼티 **키**를 배열로 반환한다.
    
    ```jsx
    const person = {
    	name: 'KMin',
    	address: 'Seoul',
    	__proto__: { age: 20 }
    }
    
    console.log(Object.keys(person)) // ["name", "address"]
    ```
    
- ES8 에서 도입된 `Object.values` 메서드는 객체 자신의 열거 가능한 프로퍼티 **값**을 배열로 반환한다.
    
    ```jsx
    console.log(Object.values(person)) // ["KMin", "Seoul"]
    ```
    
- ES8 에서 도입된 `Object.entries` 메서드는 객체 자신의 열거 가능한 **키와 값의 쌍의 배열**을 배열에 담아 반환한다.
    
    ```jsx
    console.log(Object.entries(person)) // [["name", "KMin"], ["address", "Seoul"]]
    
    Object.entries(person).forEach([key, value]) => console.log(key, value))
    /*
    name KMin
    address Seoul
    */
    ```
    

> **새로 알게 된 것 TIL (2022.03.11 금)**
> 
> 
> ---
> 
> 1. instanceof 연산자는 우변이 자신의 생성자 함수인지가 아니라, 우변이 자신의 프로토타입 체인 상에 존재하는지를 찾는다.
> 2. 프로토타입 체인에 속한 프로퍼티나 메서드는 아래것들이 참조/호출할 수 있지만,
> 생성자 함수가 직접 소유한 프로퍼티나 메서드는 인스턴스가 직접 참조/호출할 수 없다!
> 3. in 연산자는 프로토타입을 포함해 객채 내에 특정 프로퍼티가 존재하는지,
> Object.prototype.hasOwnProperty 메서드는 해당 객체에만 특정 프로퍼티가 존재하는지 확인한다.
> 4. 오직 객체 자신이 소유한 열거 가능한 프로퍼티를 열거하려면,
> Object.keys, Object.values, Object.entries 를 쓰는게 좋다