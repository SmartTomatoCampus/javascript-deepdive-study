# [JavaScript] 프로토타입 (2)

# 프로토타입의 생성 시점

---

객체는 리터럴 표기법 또는 생성자 함수에 의해 생성되므로 결국 모든 객체는 생성자 함수와 연결되어 있다

<aside>
💻 `**Object.create` 메서드와 클래스에 의한 객체 생성**

---

Object.create 메서드와 클래스로 객체를 생성하는 방법도 있다. → 이들도 생성자 함수와 연결되어 있다.

</aside>

**프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.
(프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재하기 때문)**

생성자 함수는 사용자 정의 생성자 함수와 자바스크립트가 제공하는 빌트인 생성자 함수로 구분할 수 있다.

## 1. 사용자 정의 생성자 함수와 프로토타입 생성시점

내부메서드 `[[Construct]]` 를 갖는 함수 객체는 `new` 연산자와 함께 생성자 함수로서 함수를 호출할 수 있다.

**생성자 함수로서 호출할 수 있는 함수, 즉 consructor 는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.**

```jsx
// 함수 정의(constructor)가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 생성된.
console.log(Person.prototype) // {constructor: f}

// 생성자 함수
functino Person(name) {
	this.name = name
}
```

생성자 함수로 호출할 수 없는 함수, 즉 non-constructor 는 프로토타입이 생성되지 않는다.

```jsx
// 화살표 함수는 non-constructor다.
const Person = name => {
	this.name = name
}

// non-constructor 는 프로토타입이 생성되지 않는다.
console.log(Person.prototype) // undefined
```

생성된 프로토타입은 오직 constructor 프로퍼티만을 갖는 객체다.
프로토타입도 객체이고 모든 객체는 프로토타입을 가지므로 프로토타입도 자신의 프로토타입을 갖는다.

생성된 프로토타입의 프로토타입은 `Object.prototype` 이다.

## 2. 빌트인 생성자 함수와 프로토타입 생성 시점

Object, String, Number, Function, Array, RegExp, Date, Promise 등과 같은 빌트인 생성자 함수도 일반 함수와 마찬가지로
빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성된다.

모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다.
생성된 프로토타입은 빌트인 생성자 함수의 prototype 프로퍼티에 바인딩된다.

<aside>
💻 **전역 객체 (global object)**

---

전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체다.
전역 객체는 클라이언트 사이드 환경(브라우저)에서는 `window`, 서버 사이드 환경(Node.js)에서는 `global` 객체를 의미한다.

```jsx
// 전역 객체 window는 브라우저에 종속적이므로 아래 코드는 브라우저 환경에서 실행해야 한다.
// 빌트인 객체인 Object 는 전역 객체 window 의 프로퍼티다.
window.Object === Object // true
```

</aside>

이처럼 객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 객체화되어 존재한다.

**이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 `[[Prototype]]` 내부 슬롯에 할당된다.**

이로써 생성된 객체는 프로토타입을 상속받는다.

# 객체 생성 방식과 프로토타입의 결정

---

객체의 생성방식

→ 객체 리터럴, `Object` 생성자 함수, 생성자 함수, `Object.create` 메서드, 클래스(ES6)

세부적인 차이는 있으나 추상 연산 `OrdinaryObjectCreate` 에 의해 생성된다는 공통점이 있다.

추상 연산 `OrdinaryObjectCreate` 는 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달 받는다.
그리고 자신이 생성할 객체에 추가할 프로퍼티 목록을 옵션으로 전달할 수 있다.

추상 연산 `OrdinaryObjectCreate` 는 빈 객체를 생성한 후, 객체에 추가할 프로퍼티 목록이 인수로 전달된 경우,
프로퍼티를 객체에 추가한다.
그리고 인수로 전달받은 프로토타입을 자신이 생성한 객체의 `[[Prototype]]` 내부 슬롯에 할당한 다음, 생성한 객체를 반환한다.

## 1) 객체 리터럴에 의해 생성된 객체의 프로토타입

객체 리터럴을 생성할 때 추상 연산 `OrdinaryObjectCreate` 를 호출하고, 이때 전달되는 프로토타입은 `Object.prototype` 이다.

```jsx
const obj = { x: 1 }
```

객체 리터럴로 생성된 객체 obj 는 `Object.prototype` 을 프로토타입을 갖게 되며, 이로써 `Object.prototype` 을 상속받는다.

때문에 obj 리터럴객체는 constructor 프로퍼티와 hasOwnProperty 등의 메서드 등을 소유하지 않지만,
자신의 프로토타입인 Object.prototype 의 constructor 프로퍼티와 hasOwnProperty 메서르르 자신의 것인 것처럼 자유롭게 사용할 수 있다.

## 2) Object 생성자 함수에 의해 생성된 객체의 포로토타입

`Object` 생성자 함수를 인수 없이 호출하면 빈 객체가 생성된다.

`Object` 생성자 함수 또한 추상 연산 `OrdinaryObjectCreate` 가 호출된다.

→ 이때 `OrdinaryObjectCreate` 에 전달되는 프로토타입은 `Object.prototype` 이기 때문에 
`Object` 생성자 함수에 의해 생성되는 객체의 프로토타입은 Object.prototype 이다.

## 3) 생성자 함수에 의해 생성된 객체의 프로토타입

`new` 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 마찬가지로 추상 연산 `OrdinaryObjectCreate` 가 호출된다.

이때 추상연산 `OrdinaryObjectCreate` 에 전달되는 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체다.

⇒ 즉 `new` 생성자 함수로 생성한 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체다.

```jsx
function Person(name) {
	this.name = name
}

const me = new Person('KMin')
```

위 코드가 실행되면 `OrdinaryObjectCreate` 에 의해 다음과 같이 생성자 함수와 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체와 객체 사이에 연결이 이루어지고,
사용자 정의 생성자 함수 Person 과 더불어 생성된 프로토타입 Person.prototype 의 프로퍼티는 constructor 뿐이다.

```jsx
function Person(name) {
	this.name = name
}

// 프로토타입 메서드
Person.prototype.sayHello = function() {
	console.log(`Hi! My name is ${this.name}`)
}

const me = new Person('KMin')
const you = new Person('Isa')

me.sayHello()   // Hi! My name is KMin
you.sayHello()  // Hi! My name is Isa
```

프로토타입 Person.prototype 에 프로퍼티를 추가하여 하위(자식) 객체가 상속받을 수 있도록 구현한 형태

# 프로토타입 체인

---

```jsx
function Person(name) {
	this.name = name
}

// 프로토타입 메서드
Person.prototype.sayHello = function() {
	console.log(`Hi! My name is ${this.name}`)
}

const me = new Person('KMin')

// hasOwnProperty 는 Object.prototype 의 메서드다.
console.log(me.hasOwnProperty('name')) // true
```

Person 생성자 함수에 의해 생성된 me 객체는 Object.prototype 의 메서드인 hasOwnProperty 를 호출할 수 있다.

이것은 me 객체가 Person.prototype 뿐만 아니라 Object.prototype 도 상속받았다는 것을 의미한다.

me 객체의 프로토타입은 Person.prototype 이다.

> 자바스크립트는 객체의 프로퍼티(메서드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면,
`[[Prototype]]` 내부슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다.
> 
> 
> ⇒ 이를 **프로토타입 체인**이라 한다.
> 

```jsx
me.hasOwnProperty('name')
```

> 여기서 me 객체는 hasOwnProperty 메서드가 없으므로 자신의 [[Prototype]] 내부슬롯이 있는 프로토타입 Person.prototype 에 해당 메서드가 있는지 본다.
> 
> 
> Person.prototype 에 hasOwnProperty 메서드가 없으므로 다시 [[Prototype]] 내부슬롯의 프로토타입 Object.prototype 까지 이동해 샅샅히 찾아본다.
> 
> 그럼 거기에는 hasOwnProperty 메서드가 있으므로 me.hasOwnProperty 를 쓸 수 있다.
> 
> ```jsx
> Object.prototype.hasOwnProperty.call(me, 'name')
> ```
> 
> - `**call` 메서드**
>     - call 메서드는 this 로 사용할 객체를 전달하면서 함수를 호출한다.
>     - this 로 사용할 객체로 me 객체를 전달하면서 name 이란 프로퍼티가 있는지 찾아본 것

**언제나 Object.prototype 이 프로토타입 체인의 종점이 되고, `Object.prototype` 의 프로토타입, 즉 [[Prototype]] 내부슬롯의 값은 null 이다.**

Object.prototype 에서도 프로퍼티를 검색할 수 없는 경우 에러가 발생하는 것이 아니라 undefined 를 반환한다.

# 오버라이딩과 프로퍼티 섀도잉

---

```jsx
const Person = (function() {
	// 생성자 함수
	function Person(name) {
		this.name = name
	}

	// 프로토타입 메서드
	Person.prototype.sayHello = function () {
		console.log(`Hi! My name is ${this.name}`)
	}

	// 생성자 함수를 반환
	return Person
}())

const me = new Person('KMin')

// 인스턴스 메서드
me.sayHello = function() {
	console.log(`Hey! My name is ${this.name}`)
}

// 인스턴스 메서드가 호출된다.
me.sayHello() // Hey! My name is KMin
```

프로토타입이 소유한 프로퍼티(+메서드)를 프로토타입 프로퍼티, 인스턴스가 소유한 프로퍼티를 인스턴스 프로퍼티라고 부른다.

이처럼 상속 관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 섀도잉(property shadowing)이라 한다.

<aside>
💻 **오버라이딩(overriding)**

---

상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식

</aside>

<aside>
💻 **오버로딩(overloading)**

---

함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메서드를 구현하고 매개변수에 의해 메서드를 구별하여 호출하는 방식이.

자바스크립트는 오버로딩을 지원하지 않지만, arguments 객체를 사용하여 구현할 수는 있다.

</aside>

```jsx
// 인스턴스 메서드를 삭제한다.
delete me.sayHello

// 인스턴스에는 sayHello 메서드가 없으므로 프로토타입 메서드가 호출된다.
me.sayHello() // Hi! My name is KMin
```

**프로토타입 프로퍼티를 변경 또는 삭제하려면 하위 객체를 통해 프로토타입 체인으로 접근하는 것이 아니라 프로퍼티에 직접 접근해야 한다**

```jsx
// 프로토타입 메서드 변경
Person.prototype.sayHello = function() {
	console.log(`Hey! My name is ${this.name}`)
}
me.sayHello() // Hey! My name is KMin

// 프로토타입 메서드 삭제
delete Person.prototype.sayHello
me.sayHello()
```

# 프로토타입의 교체

---

프로토타입은 임의로 다른 객체로 변경할 수 있다.

⇒ 이는 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다.

## 1) 생성자 함수에 의한 프로토타입의 교체

```jsx
const Person = (function() {
	function Person(name) {
		this.name = name
	}

	// 1) 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체
	Person.prototype = {
		sayHello() {
			console.log(`Hi! My name is ${this.name}`)
		}
	}

	return Person
}())

const me = new Person('KMin')
```

1) 에서 Person.prototype 에 객체 리터럴을 할당함으로써, Person 생성자 함수가 생성할 객체의 프로토타입을 객체 리터럴로 교체함

```jsx
// 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 ㅇ녀결이 파괴된다.
console.log(me.constructor === Person) // false
// 프로토타입 체인을 따라 Object.prototype 의 constructor 프로퍼티가 검색된다.
console.log(me.constructor === Object) // true
```

## 2) 인스턴스에 의한 프로토타입의 교체

프로토타입은 생성자 함수의 prototype 프로퍼티뿐만 아니라 인스턴스의 __proto__접근자 프로퍼티 (또는 Object.getPrototypeOf 메서드)를 통해 접근할 수 있다.

따라서 인스턴스의 __proto__ 접근자 프로터니(또는 Object.setPrototypeOf 메서드)를 통해 프로토타입을 교체할 수 있다.

**생성자 함수의 prototype 프로퍼티에 다른 임의의 객체를 바인딩하는 것은 미래에 생성할 인스턴스의 프로토타입을 교체하는 것이다.** 

__proto__ 접근자 프로퍼티를 통해 프로토타입을 교체하는 것은 이미 생성되 객체의 프로토타입을 교체하는 것이다.

```jsx
function Person(name) {
	this.name = name
}

const me = new Person('KMin')

// 프로토타입으로 교체할 객체
const parent = {
	sayHello() {
		console.log(`Hi! My name is ${this.name}`)
	}
}

// 1) me 객체의 프로토타입을 parent 객체로 교체한다.
Object.setPrototyepOf(me, parent)
// 위 코드는 아래의 코드와 동일하게 동작한다.
me.__proto__ = parent

me.sayHello()
```

생성자 함수에 의한 프로토타입 교체처럼,
마찬가지로 프로토타입으로 교체한 객체에는 constructor 프로퍼티가 없으므로 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴된다.

따라서 프로토타입의 constructor 프로퍼티로 me 객체의 생성자 함수를 검색하면 Person 이 아닌 Object 가 나온다!!

```jsx
// 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴된다.
console.log(me.constructor === Person) // false
// 프로토타입 체인을 따라 Object.prototype 의 constructor 프로퍼티가 검색된다.
console.log(me.constructor === Object) // true
```

프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가하고 생성자 함수의 prototype 프로퍼티를 재설정하여,
파괴된 생성자 함수와 프로토타입 간의 연결을 되살릴 수 있다.

```jsx
function Person(name) {
	this.name = name
}

const me = new Person('KMin')

// 프로토타입으로 교체할 객체
const parent = {
	// constructor 프로퍼티와 생성자 함수 간의 연결을 설정
	constructor: Person
	sayHello() {
		console.log(`Hi! My name is ${this.name}`)
	}
}

// 생성자 함수의 prototype 프로퍼티와 프로토타입 간의 연결을 설정
Person.prototype = parent

// me 객체의 프로토타입을 parent 객체로 교체한다.
Object.setPrototype.(me, parent)
// 위 코드는 아래의 코드와 동일하게 동작한ㄷ
// me.__proto__ = parent

me.sayHello() // Hi! My name is KMin

// constructor 프로퍼티가 생성자 함수를 가리킨다.
console.log(me.constructor === Person) // true
console.log(me.constructor === Object) // false

// 생성자 함수의 prototype 프로퍼티가 교체된 프로토타입을 가리킨다.
console.log(Person.prototype === Object.getPrototypeOf(me)) // true
```

이처럼 직접 변경하는 것은 번거롭기 때문에 프로토타입은 교체하지 않는 것이 좋다.

> **새로 알게된 것 TIL (2022.03.10 목)**
> 
> 
> ---
> 
> 1. 생성자 함수, 객체 리터럴 등으로 객체를 생성하면 [[Prototype]] 내부 슬롯에 프로퍼티가 할당된다.
> 2. 객체 리터럴 또는 Object 생성자 함수로 생성하면 프로토타입은 `Object.prototype` 이고,
> `new` 생성자 함수로 할당하면 해당 생성자 함수의 prototype 을 프로토타입으로 가진다.
> 3. 프로토타입 체인은 거슬러 거슬러 올라가서 자신의 조상까지 프로토타입을 물려받는 것을 말한다.
> 4. 프로토타입의 최상위 종점은 결국 Object.prototype 이다.
> 5. 프로토타입 프로퍼티와 인스턴스 프로퍼티가 있다면 인스턴스 프로퍼티가 당근 우선 적용되고,
> 프로토타입 프로퍼티를 변경, 삭제하려면 직접 그 프로퍼티에 접근해서 변경, 삭제 해야 한다.
> 6. 프로토타입을 동적으로 임의로 다른 객체로 변경할 수 있다.