# [JavaScript] 변수

> 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다!
→ 실수로 운영체제가 사용하고 있는 값을 변경하면 시스템을 멈추게 하는 치명적인 오류가 발생할 수 있기 때문
> 

### 변수(variable)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름

- 변수는 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘으로, 값의 **위치**를 가리키는 상징적인 이름
- 변수에 값을 저장하는 것을 할당(assingment), 변수에 저장된 값을 읽어 들이는 것을 참조(reference)라고 함

### 변수 이름은 식별자(identifier)라고도 하며, 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말함

- 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별할 수 있어야 하며, 어떤 값이 저장되어 있는 메모리 주소를 기억(저장)해야 함
- 즉, 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야 함
- **식별자는 값이 아니라 메모리 주소를 기억하고 있다.**

# 변수의 종류: var, let, const

## var 변수

### var 의 특징

1. 블록 레벨 스코프를 지원하지 않음 → 함수레벨 스코프를 지원함
    
    ⇒ 이로 인해 의도치 않게 전역 변수가 선언되어 심각한 부작용 발생 가능
    

<aside>
💡 **변수의 단계**
선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림
초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined 를 할당해 초기화
( 초기화 단계를 거치지 않으면 이전 애플리케이션이 사용했던 쓰레기값garbage value가 남아있기 때문에 JS 는 초기화를 수행함 )

- var 키워드는 선언된과 동시에 암묵적으로 undefined 로 초기화됨

</aside>

1. 변수 실행이 변수 선언 이전에 발생한다. (변수 호이스팅)

```jsx
console.log(score) // undefined
var score // 변수 선언문

var score = 80; // 변수 선언과 값의 할당
```

자바스크립트에서 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅(variable hoisting)**이라고 함

변수 선언과 값의 할당은 같이 이루어진대도 실행 시점이 다름

→ **변수 선언**은 소스코드가 순차적으로 실행되는 시점인 **런타임 이전**에 먼저 실행되지만,
**값의 할당**은 소스코드가 순차적으로 실행되는 시점인 **런타임**에 실행됨

<aside>
💻 변수 선언 뿐 아니라 var, let, const, function ,function*, class 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스)는 호이스팅됨
모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문

</aside>

1. var 키워드로 선언한 변수는 값을 재할당할 수 있다. (↔  '상수'와 반대개념)
    - 엄밀히 말하면 var 변수는 선언과 동시에 undefined 로 초기화되기 때문에 변수에 처음으로 값을 할당하는 것도 재할당임

<aside>
💡 자바스크립트 같은 '매니지드 언어'는 C언어 같은 언매니지드 언어와 달리 개발자가 명시적으로 메모리를 할당하거나 해제 못하고, 언어 차원에서 담당함. 더 이상 사용하지 않는 메모리의 해제는 가비지 콜렉터가 하고 이 또한 개발자가 건드릴 수 없음.

</aside>

<aside>
💻 **가비지 콜렉터 (garbage collector)**

---

가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말함
어떤 식별자도 참조하지 않는 메모리 공간을 주기적으로 해제함으로써 메모리 누수를 방지함

</aside>

---

### var 키워드로 선언한 변수의 문제점 ↔ let (JavaScript Deep Dive 208쪽)

1. 변수 중복 선언 허용

```jsx
var x = 1;
var y = 2;

var x = 3; // 중복 선언
```

이미 선언되어 있는 변수가 있다고 하더라도 var 키워드로 변수를 중복 선언해도 에러가 발생하지 않음

1. 함수 레벨 스코프

```jsx
var x = 1;
if (true) {
	var x = 10;
}
console.log(x) // 10
```

x는 전역 변수. 이미 선언된 전역 변수 x 가 있기 때문에 x 변수는 중복 선언됨

이는 의도치 않게 변수값이 변경되는 부작용을 발생시킴

⇒ 함수 레벨 스코프는 전역 변수를 남발할 가능성을 높임. 이로 인해 의도치 않게 전역 변수가 중복 선언되는 경우가 발생함

1. 변수 호이스팅

```jsx
console.log(far) // 참조 에러
let far

console.log(foo) // undefined
var foo
console.log(foo) // undefined
foo = 1; // 할당문에서 할당 단계가 실행됨
console.log(foo) // 1
```

var 키워드와 달리 let 키워드는 변수 호이스팅이 발생하지 않아 참조 에러를 내보냄

**⇒ let 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 분리되어 진행됨**

반면에 var 키워드로 선언한 변수는 런타임 이전에 암묵적으로 "선언 단계"와 "초기화 단계"가 한번에 진행이 되기 때문에 undefined 를 할당하게 됨

(하지만 let 키워드가 변수 호이스팅이 아예 발생ㅇ하지 않는 것은 아님 JavaScript Deep Dive 213쪽 참고)

> 추가로 var 키워드로 선언한 변수는 암묵적으로 전역 객체 window 의 프로퍼티가 된다
var x = 1; 을 선언하면 window.x = 1 과 같음
그러나 let 키워드로 선언한 변수는 window 의 프로퍼티가 되지 않는다
> 

## const 변수

### const 키워드로 선언한 변수의 특징

1. const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.

```jsx
const foo = 1;
const foo; // SyntaxError
```

const 변수는 let 변수와 마찬가지로 '블록 레벨 스코프'를 가지며, 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

```jsx
{
	console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
	const foo = 1;
	console.log(foo); // 1
}
console.log(foo) // ReferenceError: foo is not defined
```

1. const 키워드로 선언한 변수는 재할당이 금지된다.
    - 상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용해야 함
    - 변경할 수 없지만 변경이 필요한 경우 선언된 부분만 수정하면 되므로 유지보수성이 대폭 향상됨
    
    ```jsx
    const TAX_RATE = 0.1;
    // 세율을 의미하는 0.1은 변경할 수 없는 상수러소 사용될 값이므로
    // 변수 이름을 대문자로 선언해 상수임을 명확히 나타냄
    
    // 세전 가격
    let preTaxPrice = 100;
    
    // 세후 가격
    let afterTaxPrice = preTaxPrice + (preTaxPrice * TAX_RATE);
    
    console.log(afterTaxPrice); // 110
    ```
    

1. const 키워드로 선언한 변수에 원시값이 아닌, 객체를 할당한 경우 내부의 값은 변경할 수 있다.
    
    const 키워드는 재할당을 금지할 뿐 "불변"을 의미하지 않음
    

```jsx
const person = {
	name: 'KMin'
}

person.name = 'Kyeongmin'

console.log(person) // {name: 'Kyeongmin'}
```

---

<aside>
💡 정리

1. 변수 선언에는 기본적으로 const 를 사용하고 let 은 재할당이 필요한 경우에 한정해서 사용한다
2. ES6 를 사용한다면 var 키워드는 사용하지 않는다.
3. 재할당이 필요한 경우에 한정해 let 키워드를 사용하고, 이 때 변수의 스코프는 최대한 좁게 만든다.

</aside>