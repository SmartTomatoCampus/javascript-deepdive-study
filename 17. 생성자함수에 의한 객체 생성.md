# 17. 생성자함수에 의한 객체 생성 - 22.03.07

---

## 용어

🖊️**생성자 함수 :** new 연산자와 함께 객체를 생성하는 함수

🖊️**인스턴스** : 생성자 함수에 의해 생성된 객체

🖊️ **바인딩** : 식별자와 값을 연결하는 과정 

🖊️ **this 바인딩** : 가리킬 객체를 바인딩 

---


## Object 생성자 함수

new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환

객체 생성 이후 프로퍼티 또는 메서드를 추가하여 객체를 완성 시킬 수 있다.

```jsx
//빈 객체 생성
const person = new Object();

//프로퍼티 추가
person.name = 'lee';
person.sayHello = function () {
	console.log('hello' + this.name);
};

console.log(person); //{name : 'lee' , sayHellp : f}
person.sayHello();
```

반드시 Object 생성자 함수를 사용해 빈 객체를 생성해야하는 것은 아니다.

⇒ 객체 리터럴이 더 유용함

## 생성자 함수

### 객체 리터럴에 의한 객체 생성 방식 문제점

객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편하다.

단 하나의 객체만을 생성하고, 동일한 프로퍼티를 갖는 객체를 **여러개 생성하는 경우 비효율적**

```jsx
const circle = {
	radius : 5,
	getDiameter() {
		return 2 * this.radius ; //10
	}
};

console.log(circle1.getDiameter());

const circle2 = {
	radius : 10,
	getDiameter() {
		return 2 * this.radius;
	}
};

console.log(circle2.getDiameter()); //20
```

circle1 객체와 circle2 객체는 프로퍼티 구조가 동일하다.

객체 리터럴로 객체 생성할 경우, 프로퍼티 구조가 동일함에도 불구하고 객체를 생성할 때마다 매번 똑같은 내용을기술해야 한다. 

### 생성자 함수에 의한 객체 생성 방식 장점

생성자 함수 : 객체를 생성하는 함수

템플릿 처럼 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성 가능

```jsx
//생성자 함수
function Circle(radius){
	//생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스
	this.radius = radius;
	this.getDiameter = function () {
		return 2 * this.radius;
	};
}

//인스턴스 생성
const circle1 = new Circle(5);
const circle2 = new Circle(10);

console.log(circle.getDiameter()); //10
console.log(circle.getDiameter()); //20
```

<aside>
👉 **this**
객체 자신의 프로퍼티나 메서드 참조하기 위한 **자기 참조 변수**
this가 가리키는 값, this 바인딩은 **함수 호출 방식에 따라 동적으로 결정**

| 함수 호출 방식 | this가 가리키는 값 ( this 바인딩) |
| --- | --- |
| 일반 함수로서 호출 | 전역 객체 |
| 메서드로서 호출 | 메서드로 호출한 객체 |
| 생성자 함수로서 호출 | 생성자 함수가 생성할 인스턴스 |

```jsx
//함수는 다양한 방식으로 호출
function foo() {
	console.log(this);
}
// 일반적인 함수로 호출 
foo(); //window

const obj = { foo };
//메서드로서 호출
obj.foo(); //obj

const inst = new foo();
```

</aside>

**생성자 함수 동작**

자바나 이런 언어 처럼 형식이 정해져 있는 것이 아니라 **일반 함수와 동일한 방법**으로 생성자 함수를 정의하고, new 연산자와 함께 호출하면 생성자 함수로 동작한다.

new 연산자와 함께 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작

```jsx
function Circle(radius){
	//생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스
	this.radius = radius;
	this.getDiameter = function () {
		return 2 * this.radius;
	};
}
****
//new 연산자와 함께 호출하지 않으면 생성자 함수로 동작X
//일반 함수로서 호출
const cicle3 = Circle(15);

console.log(circle3); //일반 함수 Circle은 반환문이 없어 undifined 반환

console.log(radius); //Circle내의 this 전역 객체를 가리킴 => 15
```

### 생성자 함수의 인스턴스 생성 과정

**생성자 함수의 역할**

- 인스턴스를 생성하는 것
- 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)

생성자 함수가 인스턴스를 생성하는 것은 필수이고, 생성된 인스턴스를 초기화하는 것은 옵션

**인스턴스 생성 과정**

**new 연산자**와 함께 생성자 **함수 호출** 
⇒ 자바스크립트 엔진이 **암묵적**으로 인스턴스 **생성**
⇒ 인스턴스 **초기화**
⇒ **암묵적**으로 인스턴스 **반환**

```jsx
//생성자 함수
function Circle(radius) {
//인수턴스 초기화
	this.radius = radius;
	this.getDiameter = function ( {
		return 2 * this.radius;
	};
}
//인스턴스 생성
const circle1 = new Circle(5); =>반지름이 5인 객체 생성
```

**인스턴스 생성과 this 바인딩**

생성자 함수가 인스턴스를 생성하면 암묵적으로 빈 객체(인스턴스)가 생성된다. 

런타임 이전에 인스턴스는 this에 바인딩이 되어 생성자 함수가 생성할 인스턴스를 가리키게 한다.

<aside>
👉 **this 바인딩**
this는 키워드로 분류되지만 식별자의 역학을 한다.
따라서 this가 가리킬 객체를 연결한다.

</aside>

**인스턴스 초기화**

this에 바인딩 되어 있는 **인스턴스에 프로퍼티나 메서드를 추가**하고 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화 하거나 할당한다.

**인스턴스 반환**

생성자 함수 내부의 처리가 다 끝나면 인스턴스가 바인딩된 **this가 암묵적으로 반환**된다.

this가 아닌 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손하므로 하지 말자

```jsx
**//1. 암묵적으로 빈 객체 생성, this에 바인딩됨**
function Circle(radius) {
**// 2. this에 바인딩 되어 있는 인스턴스 초기화**
	this.radius = radius;
	this.getDiameter = function ( {
		return 2 * this.radius;
	};
**//3. 바인딩된 this가 완성된 인스턴스를 반환**
}
**//인스턴스 생성, Circle 생성자 함수는 암묵적으로 this 반환**
const circle1 = new Circle(5);
```

### 내부메서드 [[call]] [[construct]]

함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드, 함수 객체를 위한 내부 슬롯과 내부 메서드를 추가로 가지고 있다.

함수가 일반 함수로서 호출되면 [[call]]이 호출되고 new 연산자와 함께 생성자 함수로서 호출되면 [[construct]]가 호출

```jsx
function foo() {}

foo(); //call 호출
new foo(); //construct 호출
```

내부 메서드 [[call]] 을 갖는 함수 객체를 callable  : 호출할 수 있는 함수

내부 메서드 [[construct]] 갖는 함수 객체를 constructor  :  생성자 함수로서 호출할 수 있는 함수
constructor를 갖지 않는 함수 객체를 non-constructor : 객체를 생성자 함수로서 호출할 수 없음

![Untitled](https://github.com/sTIL-us/javascript-deepdive-study/blob/926ada0118ae7637b8966b2abebc1da5c8932e78/17.%20%EC%83%9D%EC%84%B1%EC%9E%90%20%ED%95%A8%EC%88%98%EC%97%90%20%EC%9D%98%ED%95%9C%20%EA%B0%9D%EC%B2%B4%20%EC%83%9D%EC%84%B1/Untitled.png)

### constructor와 non-constructor의 구분

[[construct]] 여부에 의해 구분된다.

- constructor : 함수 선언문, 함수 표현식, 클래스
- non-constructor : 메서드, 화살표 함수

```jsx
function foo() {}
const var = function () {};
const baz = {
	x : function () {}
};
//일반함수로 정의된 함수만이 constructor
new foo();
new bax(); 
new baz.x(); //x {}

//call이 호출되어 일반함수 호출이다
foo(); 

//화살표 함수 정의
const arrow = () => {};
new arrow(); //TypeError

//메서드 정의
const obj = {
	x() {}
};
new obj.x(); //TypeError
```

### new 연산자

new 연산자와 함께 함수를 호출하면 해당 함수 생성자 함수로 동작

new 연산자와 함께 호출하는 함수는 constructor이어야 한다.

```jsx
//생성자 함수로서 정의하지 않은 일반 함수
function add(x, y){
	return x + y;
}
//일반함수를 new 연산자와 호출
let inst = new add();

//함수가 객체를 반환하지 않으므로 반환문 무시
console.log(inst);

//객체를 반환하는 일반 함수
function createUser(name, role) {
	return {name, role};
}

//new 연산자와 함께 호출
inst = new createUser('lee', 'admin');
// 함수가 생성한 객체 반환
console.log(inst);
```

### new.target

this와 유사하게 constructor인 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며 메타 프로퍼티이다

IE는 `new.target` 지원하지 않는다...

new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 `new.target` 은 함수 자신을 가리킨다

new 연산자 없이 일반 함수로서 호출된 함수 내부의 `new.target`  undefined

```jsx
function Circle(radius){
	if(!new.target){
	// new 연산자와 함께 생성자 함수를 재귀 호출하여 생성된 인스턴스 반환
	return new Circle(radius);
	}
	this.radius = radius;
	this.getDiameter = function () {return 2 * this.radius;
	};
}

//new 연산자 없이 호출해도 new.target을 통해 생성자 함수로서 호출
const circle = Circle(5);
console.log(circle.getDiameter());

```

<aside>
👉 **스코프 세이프 생성자 패턴**
new.target은 IE에서 지원하지 않는다.
사용할 수 없을 때는 스코프 세이프 생성자 패턴을 사용할 수 있다.

```jsx
function Circle(radius) {
//생성자 함수가 new 연산자와 함께 호출되면 빈객체 생성
//this에 바인딩
//이 함수가 new랑 호출되지 않았다면 this는 전역 객체 window
// this와 Circle은 프로토 타입에 의해 연결X
		if(!(this instanceof Circle)) {
	//new 연산자와 함께 호출하여 생성된 인스턴스 반환
		return new Circle(radius);
	}
		this.radius = radius;
		this.getDiameter = function () {return 2 * this.radius;
	};
}

//newe 연산자 없이 생성자 함수를 호출하여도 생성자 함수로서 호출
const circle = Circle(5);
console.log(circle.getDiameter()); //10
```

</aside>

> 2022-03-07 TIL
1. 바인딩 : 식별자와 값을 연결해주는 것
2.
>
