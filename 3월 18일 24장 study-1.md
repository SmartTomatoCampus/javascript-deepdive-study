# 3월 18일 24장 클로저 study-1

금일 학습 예정

1. 클로저 마저 정리하기
2. 클로저 요약 및 정리

## 24.6 자주 발생하는 실수

자바스크립트의 함수 레벨 스코프 특성으로 인해 for 문의 변수 선언문에서 var 키워드로 선언한 변수가 전역변수가 된다.
=> ES6 let 키워드를 사용하여 번거로움 해결 가능

for 문의 변수 선언문에서 let 키워드로 선언한 변수를 사용하면 for 문의 코드 블록이 반복 실행될 때마다 for 문 코드 블록의 새로운 렉시컬 환경이 생성된다. 만약 for 문의 코드 블록 내에서 정의한 함수가 있다면 이 함수의 상위 스코프는 for 문의 코드 블록이 반복 실행될 때 마다 생성된 for 문 코드 블록의 새로운 렉시컬 환경이다.

함수의 상위 스코프는 for 문의 코드 블록이 반복 실행될 때마다 식별자(for 문의 변수 선언문에서 선언한 초기화 변수 및 for 문의 코드 블록 내에서 선언한 지역 변수 등)의 값을 유지해야 한다. 이를 위해 for 문이 반복될 때마다 독립적인 렉시컬 환경을 생성하여 식별자의 값을 유지한다.

let이나 const 키워드를 사용하는 반복문(for 문, for ... in 문, for...of 문, while문 등)은 코드 블록을 반복 실행할 때마다 새로운 렉시컬 환경을 생성하여 반복할 당시의 상태를 마치 스냅숏을 찍는 것처럼 저장한다. 단, 이는 반복문의 코드 블록 내부에서 함수를 정의할 때 의미가 있다. 반복문의 코드 블록 내부에 함수 정의가 없는 반복문이 생성하는 새로운 렉시컬 환경은 반복 직후, 아무도 참조하지 않기 때문에 가비지 컬렉션의 대상이 된다.

## 17일, 18일 요약( 클로저에 대해서)

1. 자바스크립트의 모든 함수는 자신의 상위 스코프를 기억
2. 그 해당 함수가 동작하고 있는 동안에는 가비지 컬렉터로 가지 않고
   또한 누군가 참조하고 있는 메모리 공간을 가비지 컬렉터가 해제하지 않는다.
3. 클로저 : 자신이 생성될 때의 환경을 기억하는 함수
   : 반환된 내부 함수가 자신이 선언됐을 대의 환경인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수.
4. 클로저의 활용 : 상태유지(변경된 최신상태 유지), 전역변수의 사용 억제, 정보의 은닉
