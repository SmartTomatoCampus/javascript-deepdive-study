# 19장 프로토타입

자바스크립트 - 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티타입 프로그래밍 언어

> 클래스(class)
>
> > es6에서 클래스 도입. 클래스도 함수이다. 기존 프로토 타입 기반 패턴의 문법적 설탕이라고 볼 수 있다. 클래스와 생성자 함수는 모두 프로토 타입 기반의 인스턴스를 생성하지만 동일하게 동작하지는 않음. 클래스는 생성자 함수보다 엄격하며, 생성자 함수에서 제공하지 않는 기능도 제공

\*자바스크립트를 이루고 있는 거의 "모든 것"이 객체다.(원시 타입의 값을 제외한 나머지 값들)

## 19.1 객체지향 프로그래밍

객체지향 프로그래밍 : 프로그램을 명령어 함수 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나 여러개의 독립적 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임<br>
추상화 : 다양한 속성중 프로그램에 필요한 속성만 간추려 표현하는 것.<br>

객체지향 프로그래밍은 객체의 상태를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작을 하나의 논리적인 단위로 묶어 생각한다. 따라서 객체는 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조라고 할 수 있다.

- 객체의 상태 데이터 : 프로퍼티 / 동작 : 메서드

## 19.2 상속과 프로토타입

상속 : 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것.
<br> **자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거**한다. 중복을 제거하는 방법은 기존의 코드를 적극적으로 재사용하는 것.

```js
// 생성자함수
function Circle(radius) {
  this.radius = radius;
}

console.log(Circle.prototype);
// 생성자함수를 이용하여 함수를 선언하였기에 해당 출력은 constructor: f 만 나온다.

Circle.prototype.getArea = function () {
  return Math.PI * this.radius ** 2;
};

console.log(Circle.prototype);
// {getArea: f, constructor: f}
// 즉 기존의 생성자 함수로 만든 Circle에 prototype으로 getArea를 넣은 것.
// 이를 통해 Circle 생성자 함수가 인스턴스를 생성할때마다 중복되는 메서드를 생략하여 생성할 수 있다?
```

// 지금 프로토타입 이해가 잘안되는게 기존에 함수내에 this.getArea를 써서 동일한 프로퍼티 구조를 갖는 객체를 여러개 생성할 때 사용한다는건 이해됨.<br>
// 이 경우 기존의 객체 리터럴에 비해 편리하다는 것은 알겠음. 문제는 해당 생성자함수를 작성하면 내용이 동일한 메서드가 중복 생성된다는 거고. 이것을 좀 줄이기 위해서. Circle 생성자함수에 prototype으로 getArea라는 메서드를 넣어서 해당 메서드의 함수를 호출하면 해당 값이 나오도록 한건데.

// 여기서 궁금한게. 이렇게 기존의 prototype에 메서드를 추가하면, 나중에 같은 파일 내에서 다른 스코프레벨에서 해당 prototype을 불렀을 때 해당 추가된 메서드가 출력될 것인지?

상속은 코드의 재사용이란 관점에서 매우 유용. 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메서드를 프로토타입에 미리 구현해두면 생성자 함수가 생성할 모든 인스턴스는 별도의 구분 없이 상위(부모) 객체인 프로토타입의 자산을 공유하여 사용가능.

## 19.3 프로토타입 객체

프로토타입 객체는 객체 지향 프로그래밍의 근간을 이루는 객체 간 상속을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메서드 포함)를 제공. 프로토타입을 상속받은 하위(자식) 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티 처럼 자유롭게 사용 가능

이때 모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값은 프로토타입의 참조다. [[Prototype]]에 저장되는 프로토타입은 객체 생성 방식에 의해 결정된다. 즉, 객체가 생성될 때 객체 생성 방식에 따라 프로토타입이 결정되고 [[Prototype]]에 저장된다.

// 여기서 [[Prototype]]은 내부메서드이므로 우리가 직접적으로 접근할 수는 없고 **proto**를 통해서만 간접적으로 접근 가능하다. << 맞나? 맞네ㅋㅋ

- 모든 객체는 하나의 프로토타입을 갖는다. 모든 프로토타입은 생성자 함수와 연결되어 있다.

- 모든 객체는 **proto**접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 간접적으로 접근 가능

- 프로토타입 체인은 단뱡향 링크드 리스트로 구현되어야 한다.

- 모든 객체가 **proto**접근자를 사용할 수 있는 것은 아니기 때문에 코드 내에서 **proto**접근자 프로퍼티를 직접 사용하는 것은 권장하지 않는다.

  > 직접 상속을 통해 Object.prototype을 상속받지 않는 객체를 생성할 수도 있다.

- 프로토타입의 참조를 취득하고 싶은 경우에는 Object.getPrototype 메서드를 사용
- 프로토타입을 교체하고 싶은 경우 Object.setPrototypeOf 메서드를 사용

함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토 타입을 가리킨다.
즉, non-consturctor인 화살표함수와 es6 메서드 축약표현으로 정의한 메서드는 prototype 프로퍼티를 소유하지 않으며 프로토타입도 생성하지 않는다.

**proto**접근자 프로퍼티는 모든 객체가 가진다.<br>
prototype 프로퍼티는 constructor 가 가진다.

## 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

리터럴 표기법에 의해 생성된 객체도 물론 프로토타입이 존재하나 리터럴 표기법에 의해 생성된 객체의 경우 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수는 없다.

> 추상연산
>
> > ECMAScript 사양에서 내부 동작의 구현 알고리즘을 포현한 것. ECMAScript 사양에서 설명을 위해 사용되는 함수와 유사한 의사 코드

- Function 생성자 함수를 호출하여 생성한 함수는 렉시컬 스코프를 만들지 않고 전역 함수인 것처럼 스코프를 생성하여 클로저도 만들지 않는다.

프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재한다

    객체 리터럴에 의해 생성된 객체 == Object 생성자 함수에 의해 생성한 객체
    객체 리터럴에 의해 생성된 객체 !=== Object 생성자 함수에 의해 생성한 객체
    함수리터럴에 의해 생성한 함수와 Function 생성자 함수에 의해 생성한 함수는 생성과정과 스코프, 클로저 등의 차이가 있지만 결국 함수로서 동일한 특성을 갖는다.
    따라서 프로토타입의 constructor 프로퍼티를 통해 연결되어있는 생성자 함수를 리터럴 표기법으로 생성한 객체를 생성한 생성자 함수로 생각해도 크게 무리는 없다.

<br>
3/9 19장-1 study 요약

    자바스크립트를 이루고 있는 거의 모든 것(원시타입 값 제외)이 객체
    객체지향 프로그래밍의 4대 속성 : 캡슐화, 상속, 추상화, 다양성
    추상화 : 다양한 속성중에 프로그래밍에 필요한 속성만 간추려내어 표현하는 것
    상속 : 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것.
    * javascript는 프로토타입을 기반으로 상속 구현
    모든 객체는 하나의 프로토타입을 갖는다.
    모든 프로토타입은 생성자함수와 연결되어 있다.
    __proto__ 접근자 프로퍼티를 통해 간접적으로 접근이 가능하다.
    * 프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다.
    *__proto__접근자 프로퍼티를 코드내에서 직접 사용하는 것은 비권장
    프로토타입의 참조를 취득하고 싶을 때 : Object.getPrototypeOf 메서드 사용
    프로토타입을 교체하고 싶을 때 Object.setPrototypeOf 메서드 사용

    prototype 프로퍼티는 생성자 함수가 생성한 객체의 프로토타입을 가리킨다 ( == non-constructor 메서드는 prototype 프로퍼티를 소유하지 않음)

    리터럴 표기법으로 생성한 객체는 프로토타입이 존재하나, 프로토타입에서 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수는 없다.

~~4줄 요약~~ 5줄 요약

    1. 객체지향 프로그래밍 언어 4대 속성 : 캡슐화, 상속, 추상화, 다형성
    2. 추상화 : 다양한 속성중에 프로그래밍에 필요한 속성만 간추려내어 표현하는 것
    3. javascript에서는 상속을 프로토타입을 기반으로 구현
    4. 모든 객체는 하나의 프로토타입을 가진다. non-constructor는 프로토타입이 없다.
    5. 리터럴 표기법으로 생성한 객체는 프로토타입이 있으나 미묘하게 다르다. (객체 리터럴 생성 객체 == 생성자 함수 생성 객체 / 객체 리터럴 생성 객체 !=== 생성자 함수 생성 객체 (생성과정, 스코프, 클로저 등의 차이))

---

## 19.5 프로토타입의 생성 시점

## 19.6 객체 생성 방식과 프로토타입의 결정

## 19.7 프로토타입 체인

## 19.8 오버라이딩 프로퍼티 섀도잉

## 19.9 프로토타입의 교체

## 19.10 instanceof 연산자

## 19.11 직접 상속

## 19.12 정적 프로퍼티/메서드

## 19.13 프로퍼티 존재 확인

## 19.14 프로퍼티 열거
