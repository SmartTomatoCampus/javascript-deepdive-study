# 16. 프로퍼티 어트리뷰트 - 22.03.06

---

## 용어

🖊️ **프로퍼티 :** 객체 내부의 속성으로 키와 값으로 구분되어 할당

🖊️**내부슬롯 :** ECMAScript 사양에서 사용하는 의사 프로퍼티로 [[~~]]로 감싼 형태

🖊️**불변객체** : 객체를 원시값 처럼 변경불가능한 값으로 동작하게 만드는 것

---

---

## 내부슬롯과 내부 메서드

ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드이다.

자바스크립트 엔진의 내부 로직이므로 직접적으로 접근하거나 호출할 수 있는 방법을 제공하진 않는다.

일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단 제공

```jsx
const o = {};

o.[[Prototype]] -> Uncaught StntaxError
o.__propto__ => Object.prototype
```

## 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 정의한다.

**프로퍼티 상태란**

프로퍼티의 값(value), 값의 생신 가능 여부(writable), 열거 가능 여부(enumerable), 재정의 가능 여부(configurable)

> **프로퍼티 어트리뷰**트는 내부 상태 값인 `[[value]]` , `[[writable]]`, `[[enumerable]]`, `[[configurable]]` 이다. 
`Object.getOwnPropertyDescriptor`  메서드를 사용하여 간접적으로 확인
> 

프로퍼티 디스크립터 객체 반환값

```jsx
const person = {
	name : 'lee'
};
console.log(Object.getOwnPropertyDescriptor(person, 'name'));

**=======객체 person의 프로퍼티 디스크립터 객체**
=>{value : 'lee', writable : true, enumerable : true, configurable : true }
```

<aside>
🖊️ ***Object.getOwnPropertyDescriptor(객체의 참조, 프로퍼티 키);***
ES8에 도입된 메서드로 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환
retrun 값 : 프로퍼티 디스크립터 객체 / undefined

</aside>

동적 생성한 프로퍼티의 디스크립터 객체 반환값

```jsx
const person = {
	name : 'lee'
};

**=======객체 person 프로퍼티 동적 생성**
person.age = 20;

console.log(Object.getOwnPropertyDescriptor(person));
**=======객체 person의 프로퍼티 디스크립터 객체**
=>{value : 'lee', writable : true, enumerable : true, configurable : true },
	{value : 20 ,  writable : true, enumerable : true, configurable : true}
```

## 데이터 프로퍼티

키와 값으로 구성된 프로퍼티

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터
객체의 프로퍼티 | 설명 |
| --- | --- | --- |
| [[value]] | value | 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값
프로퍼티 키를 통해 값을 변경하면 [[value]]에 값을 재할당
프로퍼티가 없으면 동적 생성하고 값을 저장 |
| [[writable]] | writable | 프로퍼티 값의 변경 가능 여부를 나타냄 boolean 값 반환
false 인 경우 읽기 전용 프로퍼티 |
| [[enumerable]] | enumerable | 프로퍼티 열거 가능 여부를 나태냄 boolean 값 반환
false인 경우 for..in 문이나 Object.keys 메서드 등으로 열거 불가 |
| [[configurable]] | configurable | 프로퍼티의 재정의 가능 여부 나타냄 boolean 값 반환
false인 경우 프로퍼티 삭제, 값 변경 금지
단, writable인 true인 경우 writable 값 변경은 가능 |

```jsx
const person = {
	name : 'lee'
};
console.log(Object.getOwnPropertyDescriptor(person, 'name'));

**=======객체 person의 프로퍼티 디스크립터 객체**
=>{value : 'lee', writable : true, enumerable : true, configurable : true }

***=======객체 person의 데이터 프로퍼티 값***

[[value]] : 'lee 
[[writable]] [[enumerable]] [[configurable]] : true
```

### 접근자 프로퍼티

자체적으로 값을 갖지 않고 다른 데이터 프로퍼티 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터
객체의 프로퍼티 | 설명 |
| --- | --- | --- |
| [[get]] | get | 접근자 프로퍼티를 통해 데이터 프로퍼티 값을 읽을 때 호출
프로퍼티 값에 접근하면 getter 함수가 호출되어 값 반환 |
| [[set]] | set | 접근자 프로퍼티 통해 데이터 프로퍼티 값을 저장할 때 호출
프로퍼티 값에 접근하면 setter 함수가 호출되어 값 저장 |
| [[Enumerable]] | enumerable | 데이터 프로퍼티 Enumerable과 같다 |
| [[Configurable]] | coonfigurable | 데이터 프로퍼티 Configutable 과 같다 |

접근자 함수는 **getter / setter 함수**라고도 부른다. 
getter / setter 함수 모두 정의할 수 있고 하나만 정의할 수도 있다.

```jsx
const person = {
	name : 'lee',
	age : 20,

	//Name은 접근자 함수로 구성된 프로퍼티이다
	//getter 함수
	get Name(){
		return `${this.name}`;
	}
	//setter 함수
	set Name(name){
		[this.name] = name;
	}
};

console.log(person.name); //'lee'

**======접근자 프로퍼티 Name에 저장하면 setter 함수가 호출된다.**
person.Name = kim';
console.log(person);

**=======접근자 프로퍼티 Name에 접근하면 getter 함수가 호출된다.**
console.log(person.Name);

console.log(Object.getOwnPropertyDescriptor(person, Name));
{get : f , set : f , enumerable : true, configurable : true}
```

**해석**

person 객체의 name은 일반적인 데이터 프로퍼티이다.

앞에 get / set 붙은 메서드가 getter/ setter 메서드이다. 

함수 이름 Name이 접근자 프로퍼티이다.

**동작**

접근자 프로퍼티 Name으로 프로퍼티 값에 접근하면 다음과 같이 동작한다.

1. 프로퍼티 키가 유효한지 확인한다. ⇒ ‘Name’은 문자열이므로 OK
2. 프로토타입 체인에서 프로퍼티를 검색한다 ⇒ 객체에 Name 프로퍼티 존재
3. 검색된 프로퍼티가 데이터 프로퍼티인지 접근자 프로퍼티인지 확인한다.
⇒ ‘Name’은 접근자 프로퍼티
4. 접근자 프로퍼티의 함수를 호출하여 결과값을 반환하거나 저장한다.
    
    ⇒ get 함수 호출하면 getter 함수 호출하여 결과 반환
    
    ⇒ set 함수 호출하면 setter 함수 호출하여 값 저장
    

### getter / setter 함수

**getter 함수**

프로퍼티에 접근할 때마다 값을 계산하거나 내부 변수 상태를 병시적인 함수 없이 보여주고 시을 때

**setter 함수**

속성에 값이 변경될 때 마다 함수 실행

class를 사용하는 사용자가 잘못 사용해도 오류 방어할 수 있도록 해줌

<aside>
🖊️ **프로토타입**
어떤 객체의 **상위 객체** 역할을 하는 객체
자식 객체에게 자신의 프로퍼티와 메소드를 상속한다.
**프로토타입 체인**
프로토타입이 **단방향 링크드 리스트 형태**로 연결되어 있는 상속구조
프로토타입 체인을 따라 프로토 타입 프로퍼티나 메서드를 차례대로 검색한다.

</aside>

## 프로퍼티 정의

새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의
기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의 하는 것

```jsx
Object.defineProperty(); //메서드를 사용해서 재정의
```

```jsx
const person = {};

Object.defineProperty(person, 'firstName',{
	value : 'first',
	writable : true,
	enumerable : true,
	configurable : true
});
Object.defineProperty(person, 'lastName',{
	value : 'last'
});

let descriprot = Object.getOwnPropertyDescriptor(person, 'first);
consoe.log('firstName, descriptor);

=======person의 디스크립터 객체의 프로퍼티 firstName
firstName { value : 'first', writable : true, enumrable : true, configurable : true}

descriptor = Object.getOwnPropertyDescriptor(person, 'lastNAme');
console.log('lastName',descritor);

=======person의 디스크립터 객체의 프로퍼티 lastName
======= 객체의 프로퍼티 누락시키면 undefined, false가 기본값
firstName { value : 'last', writable : false, enumrable : false, configurable : false}

//lastName의 프로퍼티는 enumerable이 false이기 때문에 열거 되지 않음
console.log(Object.keys(person));

=======lastName은 writble이 false이므로 무시한다
person.lastName = 'kim' ; 

//접근자 프로퍼티 정의
Object.defineProperty(person, 'fullName',{
	get() {
	return `${this.firstName} ${this.lastName} `;
},
		set(name) {
		[this.firstName, this,lastName] = name.split(' ');
},
	enumerable : true,
	configurable : true
});
```

`Object.defineProperty`는 하나의 프로퍼티만 정의할 수 있다.

`Object.defineProperties`를 쓰면 **여러개의 프로퍼티**를 한번에 정의할 수 있다.

```jsx
const person = {};

Object.defineProperties(person {
	firstName : {
		value : 'first',
		writable : true,
		enumerable : true,
		configurable : true
	},
	lastName : {
		value : 'last',
		writable : true,
		enumerable : true,
		configurable : true
	},
	get() {
	return `${this.firstName} ${this.lastName} `;
	},
		set(name) {
		[this.firstName, this,lastName] = name.split(' ');
	},
	enumerable : true,
	configurable : true
}
});
```

## 객체 변경 방지

객체는 변경가능한 값이므로 재할당 없이 직접 변경할 수 있다.

자바스크립트는 객체의 변경을 방지하는 다양한 메서드로 제공한다.

객체의 변경을 금지하는 강도가 다르다.

| 구분 | 메서드 | 프로퍼티
추가 | 프로퍼티
삭제 | 프로퍼티
값 읽기 | 프로터피
값 쓰기 | 프로퍼티 어트리뷰트 재정의 |
| --- | --- | --- | --- | --- | --- | --- |
| 객체 확장 금지 | Ojbect.preventExtensions | X | O | O | O | O |
| 객체 밀봉 | Object.seal | X | X | O | O | X |
| 객체 동결 | Object.freeze | X | X | O | X | X |

### 객체 확장 금지

객체의 확장을 금지한다. 즉, 프로퍼티 추가를 금지한다.

프로퍼티 동적 추가와 Obejct.defineProperty 메서드 사용을 금지한다.

<aside>
🚫 확장 가능 여부는 : **Object.isExtensible** 메서드로 확인

</aside>

### 객체 밀봉

프로퍼티 추가, 삭제, 어트리뷰트 재정의 금지

**읽기, 쓰기만** 가능한 객체이다.

<aside>
🚫 밀봉 여부는 : **Object.isSealed** 메서드로 확인

</aside>

### 객체 동결

프로퍼티 추가, 삭제, 어트리뷰트 재정의, 값 갱신 금지

**읽기만** 가능

<aside>
🚫 밀봉 여부는 : **Object.isFrozen**메서드로 확인

</aside>

### 불변 객체

위의 세 메서드는 얕은 변경 방지로 중첩 객체에는 영향을 주지 못한다.

중첩 객체까지 동결하여 [불변 객체](16%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A5%E1%84%90%20627ef.md)를 구현하려면 모든 프로퍼티에 재귀적으로 Object.freeze 를 호출한다. 

```jsx
function deepFreeze(target){
	//객체가 아니거나 동결된 객체는 무시 
	if(target && typeof target === 'object' && !Object.isFrozen(target)) {
		Object.freeze(target);
		//모든 프로퍼티를 순회하며 재귀적으로 동결
		//자신이 열거가능한 프로퍼티 키를 Object.keys로 찾으면서
		// 각 요소에 대해 콜백함수 실행

		Object.kets(target).foreEach(key => deepFreeze(target[key]));}return target;}

const person = {
	name : 'lee',
	address : { city ; 'seoul' }
};

deepFreeze(person);

console.log(Object.isFrozen(person)); //true
console.log(Object.isFrozen(person.address)); //true

person.address.city = 'busan';
console.log(person); 

=======result
{name : 'lee', address : {city : 'seoul}}
```

> **2022-03-05 TIL**
1. 프로퍼티 어트리뷰트란 객체 내부의 각각 프로퍼티들에 대해 자바스크립트 엔진이 관리하는 프로퍼티의 상태값
2. 종류에는 데이터 프로퍼티, 접근자 프로퍼티가 있음
3. 데이터 프로퍼티는 키와 값으로 구성된 프로퍼티로 우리가 알고 있는 프로퍼티
4. 접근자 프로퍼티는 데이터 프로퍼티의 값을 읽거나 저장할때의 getter / setter 로 구성된 프로퍼티
5. 객체를 변경 방지하기 위해 3가지 함수들이 있다. 근데 이 함수들은 중첩 객체에 대해서는 처리 해주지 않는다. 중첩객체까지 처리하려면 재귀로 각 요소에 freeze 걸어줘야 한다.
6. 이렇게 중첩함수까지 다 변경 방지하여 원시값 처럼 쓰이는 객체가 불변객체
>