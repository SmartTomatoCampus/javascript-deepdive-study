# 뽀또

# async/await

- 후속 처리 메서드에 콜백 함수를 전달해서 비동기 처리 결과를 후속으로 처리할 필요 없이 동기 처리 처럼 프로미스를 사용할 수 있게 해줌
- async 함수
    - async 키워드를 사용해 정의한 함수로, 언제나 프로미스를 반환 함
    - 명시적으로 프로미스를 반환하지 않더라도 암묵적으로 resolve하는 프로미스를 반환함
- await 키워드
    - 프로미스가 settled 상태가 될 때까지 대기하다가 settled 상태가 되면 resolved한 처리 결과 반환
    - await는 프로미스 앞에서 사용해야 함
    - 서로 연관 되지 않은 프로미스의 경우 시간을 더 잡아 먹으므로 , await Promise.all을 사용해 처리함
- 에러 처리
    - 원래 비동기 함수의 콜백 함수를 호출한 것은 비동기 함수가 아니기 때문에 try...catch 문을 사용해 에러를 캐치할 수 없음
    - async/await 에서 try...catch 문으로 에러를 모두 캐치 할 수 있음
        - 프로미스를 반환하는 비동기 함수는 명시적으로 호출 가능하여 호출자가 명확함
    - async 함수 내에서 catch 문을 사용하지 않으면, async 함수는 발생한 에러를 reject하는 프로미스를 반환함

# 초생

1. 제너레이터 활용은 잘 모르겠다.
2. async/await 는 가독성 좋게 비동기 처리를 동기 처리처럼 동작하도록 구현할려고 도입했다.
3. async/await 는 프로미스를 기반으로 동작한다. 
4. async 함수는 언제나 프로미스를 반환하며 명시적으로 프로미스를 반환하지 않아도 반환값을 resolve 하는 프로미스를 반환한다.
5. await 키워드는 프로미스가 settled 상태가 될 때까지 대기하다가 settled 상태가 되면 resolve한 처리 결과를 반환하고 프로미스 앞에서 사용해야 한다. 

1. 에러가 발생하지 않는 코드를 작성하는 것은 불가능 하니 에러를 잘 처리하자
2. try문에서 오류가나면 catch 문에서 처리 하고 finally는 그런거 상관없이 한번은 실행되는 것
3. Error 객체는 message 프로퍼티와 stack 프로퍼티를 갖는다. message 프로퍼티의 값은 Error t생성자 함수에 인수로 전달한 에러메시지 이고 stack 프로퍼티의 값은 콜 스택의 호출 정보를 나타내는 문자열이다.

# 너두

async/await

알게된것

모든 프로미스에 await를 쓰면 비효율적이다(연관없이 개별적 수행)

모든 프로미스에 await를 써야한다(순서가 보장되어야 할경우)

# 애한

에러처리 - 모든 걸 막기는 힘들지만 항상 예외 상황을 생각하는 습관을 기르자.

# 꽁치

1. 제너레이터 비동기 처리는 너무 복잡하고 어렵다. 인간적으로 너무 어렵다. 하지만 async/await 이 이걸 더 간편하게 해결해준다.
- async/await 은 비동기 처리를 마치 동기 처리처럼 코드를 작성할 수 있고 try/catch 에러를 핸들링할 수도 있고, then/catch 로도 에러를 핸들링할 수 있다.
2. 에러 핸들링을 잘하자. setTimeout 이나 프로미스의 후속 처리 메서드의 콜백에서 발생한 에러는 호출자가 따로 없기 때문에 try/catch 로 에러를 처리해줄 수 없으므로 try 또는 then 구문 안에서 잡아주어야 한다.

# 명성

async 함수는 async 키워드를 사용해 정의하며 언제나 프로미스를 반환한다
 async/await를 사용하면 프로미스의 then/catch/finally 후속 처리 메서드에 콜백 함수를 전달해서 
비동기 처리 결과를 후속 처리할 필요 없이 마치 동기 처리처럼 프로미스를 사용할 수 있다.

try ...catch문을 사용해 발생한 에러에 적절하게 대응하면 프로그램이 강제 종료되지 않고
계속해서 코드를 실행시킬 수 있다.

Error는 생성과 호출이 다르게 진행된다.

에러는 야구공과 같아서 throw 키워드를 통해 던져주어야 한다!

setTimeout이나 프로미스 후속 처리 메서드의 콜백 함수는 태스크 큐나 마이크로 태스크 큐에 일시 저장되었다가 
콜 스택이 비면 이밴트 루프에 의해 콜 스택으로 푸시되어 실행된다.
이때 콜 스택에 푸시된 콜백 함수의 실행 컨텍스트는 콜 스택의 가장 하부에 존재하게 된다.
따라서 에러를 전파할 호출자가 존재하지 않는다.

- 그래서 프로미스의 후속 처리 메서드 catch를 사용하여 에러를 처리하라는 뜻인것 같다?
