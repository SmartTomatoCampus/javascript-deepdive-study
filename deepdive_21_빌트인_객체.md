# 발표문 - 21장 빌트인 객체

# 명성님

- 원시값에 마침표 표기법이나 대괄호 표기법을 사용하면 객체처럼 사용할 수 있게 하는 래퍼객체가 호출된다는 것을 알게 되었다.
    - 이후 같은 원시값에 마침표 표기법이나 대괄호 표기법으로 관련된 값을 조작하려 해도 불가능하다. 이미 다른 래퍼 객체로 바뀌었기 때문이다.
- 전역 객체를 공부하며 자바스크립트의 실행 환경에 따라 추가되는 메서드와 프로퍼티를 알게 되었다.
    - DOM BOM,XMLHttpRequest,Fetch,requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker 같은 클라이언트 사이드 Web API를 호스트 객체로 제공하며 Node.js 환경에서는Node.js 고유의 API를 호스트 객체로 제공한다.
- eval 함수는 쓰지말자.

```jsx
질문
원시값 식별자가 레퍼객체가 호출되고 그 후에 가비지 컬랙션 대상이 된다 이런게 있는데
저는 이부분이 되게 이해가 안되더라구요..설명해주실수 있나요!!!!!

답변
이는 원시값인 문자열, 숫자, 불리언 값의 경우 이들 원시값에 대해
마치 객체처럼 마침표 표기법(또는 대괄호 표기법)으로 접근하면
자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해 주기 때문이다.
즉 원시값을 객체처럼 사용하면 자바스크립트 엔진은
암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나
메서드를 호출하고 다시 원시값으로 되돌린다.
```

```jsx
질문
같은 원시값에 마침표 표기법이나 대괄호 표기법으로 관련된 값을 조작하려 해도 불가능하다.
이미 다른 래퍼 객체로 바뀌었기 때문이다. << 이 부분을 좀 더 풀어서 설명듣고 싶읍니다!

답변
str.name = 'hihi'; 이렇게 마침표 표기법으로 다가갈때 래퍼 객체가 가능하게 해줘요
그리고 나서 str.name 을 쓰면 없는데 레퍼객체는 이미 값을 호출하고 원시값으로 되돌려 놨어요
래퍼객체는 같은 값을 승계하지 않고 호출 뒤 가비지컬랙터의 대상이된다

애한님의 보충설명
래퍼객체가 기존에 있는 원시값을 객체로서 조작할수 있게 하는 거잖습니까?
그래서 래퍼객체로 위에서 객체로서 조작가능하게 된 다음
가비지컬렉션으로 들어갔으므로 기존의 래퍼 함수는 삭제되엇습니다

너두님의 보충설명
쉽게 설명하자면 레퍼객체는 형변환이 없어서 원래의 값으로 되돌아간다고 생각하시면 됩니다
그럼에도 불구하고 다른 빌트인처럼 사용가능한거에요
말도 안되는건데 편리하게 쓸려고 암묵적으로 허용했다 보시면됨
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bbb86488-ef93-4f50-8a20-03dffa48d645/Untitled.png)

# 너두님

### 알게된것

- NaN이 number 였다니
- 전역 undefined의 존재를 알게 되었다
- parseInt를 간단하게 생각했는데 활용범위가 엄청나게 넓었다
    - 10진수 2진수 16진수의 진수표기 활용법
- 래퍼 객체는 일시적인 캐스팅이 이루어진다

# 애한님

- 자바스크립트 객체는 표준 빌트인 객체(Native 객체라고도 함), 호스트 객체, 사용자 정의 객체 3가지가 있다.
- 호스트 객체는 정의되어있지는 않지만 자바스크립트 실행 환경에서 추가로 제공하는 객체

### 그래서 호스트 객체가 뭔데?

: 호스트 환경에 정의된 객체, 브라우저에서 동작하는 환경 혹은 브라우저 외부에서 동작하는 환경
브라우저에서 동작하는 환경의 호스트 객체 : window, BOM, DOM, 및 XMLhttpRequest 등
브라우저 외부에서 동작하는 환경의 호스트 객체 : Node.js 고유의 api

### 원시값과 래퍼객체.

원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없으나 원시값인 문자열이 마치 객체처럼 동작. 문자열, 숫자 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체(wrapper object)라고 함.

### 그래서 래퍼객체가 뭔데?

래퍼객체는 프로퍼티를 참조할 때 생성되며, 프로퍼티 참조가 끝나면 사라진다.
문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체

### 전역객체

- 빌트인 전역 프로퍼티(Infinity, NaN, undefined)
- 빌트인 전역 함수(eval, isFinite, isNaN, parseFloat, parseInt, encodeURI/decodeURI,
- encodeURIComponent/decodeURIComponent) 암묵적 전역
**하, 그놈의 암묵적 소리**

### 그래서 암묵적 전역이 뭔데?

- 선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티로 등록된다.
- (var, let, const를 사용하지 않은 식별자에 값을 할당) 등록된 전역객체의 프로퍼티는 변수가 아님
- 등록된 전역객체의 프로퍼티는 변수 호이스팅이 발생하지 않음
- 등록된 전역객체의 프로퍼티는 delete 연산자로 삭제할 수 있다.

# 루피님

1. 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인객체의 prototype 프로퍼티에 바인딩 된 객체이다.
2. 표준 빌트인 객체는 인스턴스 없이 사용 할 수 있는 정적 메서드를 제공한다.
3. 전역 객체가 최상위 객체라는 것은 프로토타입 상속 관계상에서 최상위 객체라는 것은 아니며, 어떤 객체의 프로퍼티도 아니고
객체의 계층적 구조상 표준 빌트인 객체와 호스트 객체를 프로퍼티로 소유한다.
4. 전역객체의 프로퍼티를 참조할 때 window를 생략 할 수 있다.
5. eval 함수는 자바스크립트 코드를 나타내는 문자열을 인수로 받으며, 전달받은 문자열 코드가 표현식이면 런타임에 평가해서 값을 생성하고,
표현식이 아닌 문이라면 문자열 코드를 런타임에 실행한다.

그러나 `eval`의 사용은 많은 경우에 금기시된다. **치명적인 보안 위험**이 있기 때문이다. [GOTO](https://namu.wiki/w/GOTO)문의 경우보다도 위험한데, GOTO는 아무리 잘못 써 봤자 그 코드를 다시 편집할 수 없게 만드는 정도에서 그치는 반면 `eval`문을 잘못 사용하는 경우, 예를 들면 **네트워크 상에서 가져온 문자열을 실행**하는 경우 악의적으로 표현식을 작성한 사람에 의해 **모든 너 데이터 다 내거다요 등의 사태**가 일어날 수 있기 때문이다.

# 뽀또님

- 자바스크립트는 Object, String, Number, Boolean , Symbol, Date, Math, RegExp, Array, Map/Set, WeakMap/ WeakSet, Function, Promise, Reflect, Proxy, JSON, Error 등 40여 개의 표준 빌트인을 제공한다.
- encodeURI / decodeURI
    - 쿼리 스트링 구분자로 사용되는 =, ? , & 까지 인코딩 한다.
        - ? : URL주소와 쿼리스트링을 구분
        - = : (변수=값)으로 구성
        - & : 여러 쌍의 변수와 값을 전달할때 구분하기 위해 사용
    - `A-Z a-z 0-9 ; , / ? : @ & = + $ - _ . ! ~ * ' ( ) #` 이스케이프 하지 않는 문자
- encodeURIComponent / decodeURIComponent

# 피치님

- 객체에는 딱 3가지로 구분된다
    - 표준빌트인객체
    - 호스트객체
    - 사용자정의객체
- 래퍼객체에 대해 배웠읍니다.
- 전역객체가 코드 실행 이전 단계, 즉 가장 먼저 생성되는 특수한 객체다
- 브라우저 환경의 모든 스크립트 파일은 하나의 전역 객체 window를 공유한다

# 꽁치님

22장 발표를 하도록 하겠다.
